///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.20.1.2476 for 8051               09/Apr/2017  15:54:02
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  near
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_mem.c
//    Command line       =  
//        "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_mem.c" -lB
//        "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\" -o "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI
//        CC2540\APP\IAR Project\Debug\Obj\" -e --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --debug --core=plain
//        --dptr=16,1 --data_model=large --code_model=near
//        --calling_convention=xdata_reentrant --place_constants=data
//        --nr_virtual_regs 8 -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Source\" -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Ports\51-CC2540\Generic\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\51-CC2540\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\BSP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\" -Ol
//    List file          =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\lib_mem.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME lib_mem

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?L_EQ_X
        EXTERN ?L_MOV_X
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?UL_SWITCH_SPARSE
        EXTERN ?US_DIV_MOD
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP100_8
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC Mem_Clr
        PUBLIC Mem_Cmp
        PUBLIC Mem_Copy
        PUBLIC Mem_Heap
        PUBLIC Mem_HeapAlloc
        PUBLIC Mem_HeapGetSizeRem
        PUBLIC Mem_Init
        PUBLIC Mem_Move
        PUBLIC Mem_PoolBlkFree
        PUBLIC Mem_PoolBlkGet
        PUBLIC Mem_PoolBlkGetNbrAvail
        PUBLIC Mem_PoolBlkGetUsedAtIx
        PUBLIC Mem_PoolBlkIxGet
        PUBLIC Mem_PoolClr
        PUBLIC Mem_PoolCreate
        PUBLIC Mem_PoolHeap
        PUBLIC Mem_PoolTbl
        PUBLIC Mem_SegGetSizeRem
        PUBLIC Mem_Set
        PUBWEAK __Constant_4f504c4f

        EXTERN CPU_SR_Restore
        EXTERN CPU_SR_Save
        EXTERN CPU_SW_Exception

// H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_mem.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/LIB
//    4 *                                        CUSTOM LIBRARY MODULES
//    5 *
//    6 *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
//    7 *
//    8 *               All rights reserved.  Protected by international copyright laws.
//    9 *
//   10 *               uC/LIB is provided in source form to registered licensees ONLY.  It is
//   11 *               illegal to distribute this source code to any third party unless you receive
//   12 *               written permission by an authorized Micrium representative.  Knowledge of
//   13 *               the source code may NOT be used to develop a similar product.
//   14 *
//   15 *               Please help us continue to provide the Embedded community with the finest
//   16 *               software available.  Your honesty is greatly appreciated.
//   17 *
//   18 *               You can contact us at www.micrium.com.
//   19 *********************************************************************************************************
//   20 */
//   21 
//   22 /*
//   23 *********************************************************************************************************
//   24 *
//   25 *                                     STANDARD MEMORY OPERATIONS
//   26 *
//   27 * Filename      : lib_mem.c
//   28 * Version       : V1.37.01
//   29 * Programmer(s) : ITJ
//   30 *                 FGK
//   31 *                 JFD
//   32 *                 FBJ
//   33 *********************************************************************************************************
//   34 * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
//   35 *
//   36 *                     (a) ALL standard library functions are implemented in the custom library modules :
//   37 *
//   38 *                         (1) \<Custom Library Directory>\lib_*.*
//   39 *
//   40 *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
//   41 *
//   42 *                               where
//   43 *                                       <Custom Library Directory>      directory path for custom library software
//   44 *                                       <cpu>                           directory name for specific processor (CPU)
//   45 *                                       <compiler>                      directory name for specific compiler
//   46 *
//   47 *                     (b) Product-specific library functions are implemented in individual products.
//   48 *********************************************************************************************************
//   49 */
//   50 
//   51 
//   52 /*
//   53 *********************************************************************************************************
//   54 *                                            INCLUDE FILES
//   55 *********************************************************************************************************
//   56 */
//   57 
//   58 #define    MICRIUM_SOURCE
//   59 #define    LIB_MEM_MODULE
//   60 #include  <lib_mem.h>
//   61 
//   62 
//   63 /*$PAGE*/
//   64 /*
//   65 *********************************************************************************************************
//   66 *                                            LOCAL DEFINES
//   67 *********************************************************************************************************
//   68 */
//   69 
//   70 
//   71 /*
//   72 *********************************************************************************************************
//   73 *                                           LOCAL CONSTANTS
//   74 *********************************************************************************************************
//   75 */
//   76 
//   77 
//   78 /*
//   79 *********************************************************************************************************
//   80 *                                          LOCAL DATA TYPES
//   81 *********************************************************************************************************
//   82 */
//   83 
//   84 
//   85 /*
//   86 *********************************************************************************************************
//   87 *                                            LOCAL TABLES
//   88 *********************************************************************************************************
//   89 */
//   90 
//   91 
//   92 /*
//   93 *********************************************************************************************************
//   94 *                                       LOCAL GLOBAL VARIABLES
//   95 *********************************************************************************************************
//   96 */
//   97 
//   98 #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   99 MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
Mem_PoolTbl:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  100 MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
Mem_PoolHeap:
        DS 38
        REQUIRE __INIT_XDATA_Z
//  101 
//  102 #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  103 CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
Mem_Heap:
        DS 27648
        REQUIRE __INIT_XDATA_Z
//  104 #endif
//  105 #endif
//  106 
//  107 
//  108 /*
//  109 *********************************************************************************************************
//  110 *                                      LOCAL FUNCTION PROTOTYPES
//  111 *********************************************************************************************************
//  112 */
//  113 
//  114 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
//  115 
//  116 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  117 static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL          *pmem_pool,
//  118                                              void              *pmem_blk);
//  119 #endif
//  120 
//  121 
//  122 static  CPU_SIZE_T    Mem_SegCalcTotSize    (void              *pmem_addr,
//  123                                              MEM_POOL_BLK_QTY   blk_nbr,
//  124                                              CPU_SIZE_T         blk_size,
//  125                                              CPU_SIZE_T         blk_align);
//  126 
//  127 static  void         *Mem_SegAlloc          (MEM_POOL          *pmem_pool,
//  128                                              CPU_SIZE_T         size,
//  129                                              CPU_SIZE_T         align);
//  130 
//  131 #endif
//  132 
//  133 
//  134 /*
//  135 *********************************************************************************************************
//  136 *                                     LOCAL CONFIGURATION ERRORS
//  137 *********************************************************************************************************
//  138 */
//  139 
//  140 
//  141 /*$PAGE*/
//  142 /*
//  143 *********************************************************************************************************
//  144 *                                             Mem_Init()
//  145 *
//  146 * Description : (1) Initialize Memory Management Module :
//  147 *
//  148 *                   (a) Initialize heap memory pool
//  149 *                   (b) Initialize      memory pool table
//  150 *
//  151 *
//  152 * Argument(s) : none.
//  153 *
//  154 * Return(s)   : none.
//  155 *
//  156 * Caller(s)   : Application.
//  157 *
//  158 * Note(s)     : (2) Mem_Init() MUST be called ... :
//  159 *
//  160 *                   (a) ONLY ONCE from a product's application; ...
//  161 *                   (b) BEFORE product's application calls any memory library module function(s)
//  162 *********************************************************************************************************
//  163 */
//  164 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  165 void  Mem_Init (void)
Mem_Init:
        CODE
//  166 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
//  167 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
//  168     MEM_POOL  *pmem_pool;
//  169 
//  170                                                                         /* --------- INIT MEM HEAP SEG / POOL --------- */
//  171     pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
        MOV     R2,#Mem_PoolHeap & 0xff
        MOV     R3,#(Mem_PoolHeap >> 8) & 0xff
//  172     pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
        MOV     R4,#0x41
        MOV     R5,#0x50
        MOV     R6,#0x48
        MOV     R7,#0x45
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  173     pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#Mem_PoolHeap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_PoolHeap >> 8) & 0xff
        MOVX    @DPTR,A
//  174     pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  175     pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  176     pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  177     pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
        MOV     A,R2
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  178     pmem_pool->PoolAddrStart    = (void       *) 0;
        MOV     A,R2
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  179     pmem_pool->PoolAddrEnd      = (void       *) 0;
        MOV     A,R2
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  180     pmem_pool->PoolPtrs         = (void      **) 0;
        MOV     A,R2
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  181     pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
        MOV     A,R2
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  182     pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
        MOV     A,R2
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  183     pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
        MOV     A,R2
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  184 
//  185 #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
//  186     pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
//  187     pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
//  188 #else
//  189     pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
        MOV     A,R2
        ADD     A,#0x1e
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#Mem_Heap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_Heap >> 8) & 0xff
        MOVX    @DPTR,A
//  190     pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
        MOV     A,R2
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#Mem_Heap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_Heap >> 8) & 0xff
        MOVX    @DPTR,A
//  191 #endif
//  192 
//  193     pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
        MOV     A,R2
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6c
        MOVX    @DPTR,A
//  194     pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
        MOV     A,R2
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6c
        MOVX    @DPTR,A
//  195 
//  196                                                                         /* ------------ INIT MEM POOL TBL ------------- */
//  197     Mem_PoolTbl = &Mem_PoolHeap;
        MOV     DPTR,#Mem_PoolTbl
        MOV     A,#Mem_PoolHeap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_PoolHeap >> 8) & 0xff
        MOVX    @DPTR,A
//  198 #endif
//  199 }
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
//  200 
//  201 
//  202 /*$PAGE*/
//  203 /*
//  204 *********************************************************************************************************
//  205 *                                              Mem_Clr()
//  206 *
//  207 * Description : Clear data buffer (see Note #2).
//  208 *
//  209 * Argument(s) : pmem        Pointer to memory buffer to clear.
//  210 *
//  211 *               size        Number of data buffer octets to clear (see Note #1).
//  212 *
//  213 * Return(s)   : none.
//  214 *
//  215 * Caller(s)   : Application.
//  216 *
//  217 * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
//  218 *
//  219 *                   See also 'Mem_Set()  Note #1'.
//  220 *
//  221 *               (2) Clear data by setting each data octet to 0.
//  222 *********************************************************************************************************
//  223 */
//  224 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  225 void  Mem_Clr (void        *pmem,
Mem_Clr:
        CODE
//  226                CPU_SIZE_T   size)
//  227 {
        ; Saved register size: 0
        ; Auto size: 0
//  228     Mem_Set(pmem,
//  229             0u,                                                 /* See Note #2.                                         */
//  230             size);
        ; Setup parameters for call to function Mem_Set
        MOV     R1,#0x0
        LJMP    Mem_Set
//  231 }
//  232 
//  233 
//  234 /*$PAGE*/
//  235 /*
//  236 *********************************************************************************************************
//  237 *                                              Mem_Set()
//  238 *
//  239 * Description : Fill data buffer with specified data octet.
//  240 *
//  241 * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
//  242 *
//  243 *               data_val    Data fill octet value.
//  244 *
//  245 *               size        Number of data buffer octets to fill (see Note #1).
//  246 *
//  247 * Return(s)   : none.
//  248 *
//  249 * Caller(s)   : Application.
//  250 *
//  251 * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
//  252 *
//  253 *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
//  254 *                   words.
//  255 *
//  256 *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
//  257 *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
//  258 *                       addresses.
//  259 *
//  260 *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
//  261 *                   address boundary.
//  262 *
//  263 *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
//  264 *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
//  265 *                  'mem_align_mod' arithmetic operation.
//  266 *********************************************************************************************************
//  267 */
//  268 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  269 void  Mem_Set (void        *pmem,
Mem_Set:
        CODE
//  270                CPU_INT08U   data_val,
//  271                CPU_SIZE_T   size)
//  272 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R1
        MOV     R6,A
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
//  273     CPU_SIZE_T   size_rem;
//  274     CPU_ALIGN    data_align;
//  275     CPU_ALIGN   *pmem_align;
//  276     CPU_INT08U  *pmem_08;
//  277     CPU_DATA     mem_align_mod;
//  278     CPU_DATA     i;
//  279 
//  280 
//  281 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  282     if (size < 1) {                                             /* See Note #1.                                         */
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??Mem_Set_0
//  283         return;
//  284     }
//  285     if (pmem == (void *)0) {
        MOV     A,DPL
        ORL     A,DPH
        JNZ     $+5
        LJMP    ??Mem_Set_0
//  286         return;
//  287     }
//  288 #endif
//  289 
//  290 
//  291     data_align = 0u;
        MOV     R2,#0x0
        MOV     R3,#0x0
//  292     for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        MOV     ?V0,#0x0
        MOV     ?V1,#0x0
        SJMP    ??Mem_Set_1
//  293         data_align <<=  DEF_OCTET_NBR_BITS;
??Mem_Set_2:
        CLR     A
        XCH     A,R2
        MOV     R3,A
//  294         data_align  |= (CPU_ALIGN)data_val;
        MOV     A,R6
        MOV     R4,A
        MOV     R5,#0x0
        MOV     A,R4
        ORL     A,R2
        MOV     R2,A
        MOV     A,R5
        ORL     A,R3
        MOV     R3,A
//  295     }
        INC     ?V0
        MOV     A,?V0
        JNZ     ??Mem_Set_1
        INC     ?V1
??Mem_Set_1:
        CLR     C
        MOV     A,?V0
        SUBB    A,#0x2
        MOV     A,?V1
        SUBB    A,#0x0
        JC      ??Mem_Set_2
//  296 
//  297     size_rem      =  size;
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
//  298     mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
        MOV     A,DPL
        ANL     A,#0x1
        MOV     R0,A
        MOV     R1,#0x0
//  299 
//  300     pmem_08 = (CPU_INT08U *)pmem;
//  301     if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_Set_3
//  302         i = mem_align_mod;
        MOV     ?V0,R0
        MOV     ?V1,R1
        SJMP    ??Mem_Set_4
//  303         while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
//  304                (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
//  305            *pmem_08++ = data_val;
??Mem_Set_5:
        MOV     A,R6
        PUSH    A
        POP     A
        MOVX    @DPTR,A
        INC     DPTR
//  306             size_rem -= sizeof(CPU_INT08U);
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  307             i++;
        INC     ?V0
        MOV     A,?V0
        JNZ     ??Mem_Set_4
        INC     ?V1
//  308         }
??Mem_Set_4:
        MOV     A,R4
        ORL     A,R5
        JZ      ??Mem_Set_3
        CLR     C
        MOV     A,?V0
        SUBB    A,#0x2
        MOV     A,?V1
        SUBB    A,#0x0
        JC      ??Mem_Set_5
//  309     }
//  310 
//  311     pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
??Mem_Set_3:
        MOV     R0,DPL
        MOV     R1,DPH
        SJMP    ??Mem_Set_6
//  312     while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
//  313        *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
??Mem_Set_7:
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,R0
        ADD     A,#0x2
        MOV     R0,A
        JNC     ??Mem_Set_8
        INC     R1
//  314         size_rem    -= sizeof(CPU_ALIGN);
??Mem_Set_8:
        MOV     A,R4
        ADD     A,#-0x2
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  315     }
??Mem_Set_6:
        CLR     C
        MOV     A,R4
        SUBB    A,#0x2
        MOV     A,R5
        SUBB    A,#0x0
        JNC     ??Mem_Set_7
//  316 
//  317     pmem_08 = (CPU_INT08U *)pmem_align;
        MOV     DPL,R0
        MOV     DPH,R1
        SJMP    ??Mem_Set_9
//  318     while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
//  319        *pmem_08++   = data_val;
??Mem_Set_10:
        MOV     A,R6
        PUSH    A
        POP     A
        MOVX    @DPTR,A
        INC     DPTR
//  320         size_rem   -= sizeof(CPU_INT08U);
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  321     }
??Mem_Set_9:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Mem_Set_10
//  322 }
??Mem_Set_0:
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  323 
//  324 
//  325 /*$PAGE*/
//  326 /*
//  327 *********************************************************************************************************
//  328 *                                             Mem_Copy()
//  329 *
//  330 * Description : Copy data octets from one memory buffer to another memory buffer.
//  331 *
//  332 * Argument(s) : pdest       Pointer to destination memory buffer.
//  333 *
//  334 *               psrc        Pointer to source      memory buffer.
//  335 *
//  336 *               size        Number of octets to copy (see Note #1).
//  337 *
//  338 * Return(s)   : none.
//  339 *
//  340 * Caller(s)   : Application.
//  341 *
//  342 * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
//  343 *
//  344 *               (2) Memory buffers NOT checked for overlapping.
//  345 *
//  346 *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
//  347 *                       copying takes place between objects that overlap, the behavior is undefined".
//  348 *
//  349 *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
//  350 *                       successfully copy to a destination memory buffer at a lower  address value even
//  351 *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
//  352 *                       word copy overlaps.
//  353 *
//  354 *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
//  355 *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
//  356 *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
//  357 *                       ever overlap.
//  358 *
//  359 *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
//  360 *                       buffers as long as the source memory buffer is at a higher address value than the
//  361 *                       destination memory buffer.
//  362 *
//  363 *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
//  364 *                   words.
//  365 *
//  366 *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
//  367 *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
//  368 *                       addresses.
//  369 *
//  370 *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
//  371 *                   address boundary.
//  372 *
//  373 *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
//  374 *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
//  375 *                  'mem_align_mod' arithmetic operation.
//  376 *********************************************************************************************************
//  377 */
//  378 /*$PAGE*/
//  379 #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  380 void  Mem_Copy (       void        *pdest,
Mem_Copy:
        CODE
//  381                 const  void        *psrc,
//  382                        CPU_SIZE_T   size)
//  383 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  384            CPU_SIZE_T    size_rem;
//  385            CPU_SIZE_T    mem_gap_octets;
//  386            CPU_ALIGN    *pmem_align_dest;
//  387     const  CPU_ALIGN    *pmem_align_src;
//  388            CPU_INT08U   *pmem_08_dest;
//  389     const  CPU_INT08U   *pmem_08_src;
//  390            CPU_DATA      i;
//  391            CPU_DATA      mem_align_mod_dest;
//  392            CPU_DATA      mem_align_mod_src;
//  393            CPU_BOOLEAN   mem_aligned;
//  394 
//  395 
//  396 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  397     if (size < 1) {                                             /* See Note #1.                                         */
        MOV     A,R6
        ORL     A,R7
        JNZ     $+5
        LJMP    ??Mem_Copy_0
//  398         return;
//  399     }
//  400     if (pdest == (void *)0) {
        MOV     A,R2
        ORL     A,R3
        JNZ     $+5
        LJMP    ??Mem_Copy_0
//  401         return;
//  402     }
//  403     if (psrc  == (void *)0) {
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??Mem_Copy_0
//  404         return;
//  405     }
//  406 #endif
//  407 
//  408 
//  409     size_rem           =  size;
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
//  410 
//  411     pmem_08_dest       = (      CPU_INT08U *)pdest;
//  412     pmem_08_src        = (const CPU_INT08U *)psrc;
//  413 
//  414     mem_gap_octets     = pmem_08_src - pmem_08_dest;
        MOV     A,R0
        CLR     C
        SUBB    A,R2
        MOV     R6,A
        MOV     A,R1
        SUBB    A,R3
        MOV     R7,A
//  415 
//  416 
//  417     if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        JNC     $+5
        LJMP    ??Mem_Copy_1
//  418                                                                 /* See Note #4.                                         */
//  419         mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
        MOV     A,R2
        ANL     A,#0x1
        MOV     R6,A
        MOV     R7,#0x0
//  420         mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
        MOV     A,R0
        ANL     A,#0x1
        MOV     ?V0,A
        MOV     ?V1,#0x0
//  421 
//  422         mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
        MOV     A,?V0
        XRL     A,R6
        JNZ     ??Mem_Copy_2
        MOV     A,?V1
        XRL     A,R7
??Mem_Copy_2:
        JNZ     ??Mem_Copy_3
        MOV     ?V0,#0x1
        SJMP    ??Mem_Copy_4
??Mem_Copy_3:
        MOV     ?V0,#0x0
//  423 
//  424         if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
??Mem_Copy_4:
        MOV     A,#0x1
        XRL     A,?V0
        JZ      $+5
        LJMP    ??Mem_Copy_1
//  425                                                                 /* ... optimize copy for mem buf alignment.             */
//  426             if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
        MOV     A,R6
        ORL     A,R7
        JZ      ??Mem_Copy_5
//  427                 i = mem_align_mod_dest;
        MOV     ?V0,R6
        MOV     ?V1,R7
        SJMP    ??Mem_Copy_6
//  428                 while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
//  429                        (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
//  430                    *pmem_08_dest++ = *pmem_08_src++;
??Mem_Copy_7:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  431                     size_rem      -=  sizeof(CPU_INT08U);
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  432                     i++;
        INC     ?V0
        MOV     A,?V0
        JNZ     ??Mem_Copy_6
        INC     ?V1
//  433                 }
??Mem_Copy_6:
        MOV     A,R4
        ORL     A,R5
        JZ      ??Mem_Copy_5
        CLR     C
        MOV     A,?V0
        SUBB    A,#0x2
        MOV     A,?V1
        SUBB    A,#0x0
        JC      ??Mem_Copy_7
//  434             }
//  435 
//  436             pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3a.                                        */
//  437             pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
        SJMP    ??Mem_Copy_5
//  438             while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
//  439                *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
??Mem_Copy_8:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        MOV     A,R0
        ADD     A,#0x2
        MOV     R0,A
        JNC     ??Mem_Copy_9
        INC     R1
??Mem_Copy_9:
        MOV     A,R2
        ADD     A,#0x2
        MOV     R2,A
        JNC     ??Mem_Copy_10
        INC     R3
//  440                 size_rem         -=  sizeof(CPU_ALIGN);
??Mem_Copy_10:
        MOV     A,R4
        ADD     A,#-0x2
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  441             }
??Mem_Copy_5:
        CLR     C
        MOV     A,R4
        SUBB    A,#0x2
        MOV     A,R5
        SUBB    A,#0x0
        JNC     ??Mem_Copy_8
//  442 
//  443             pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
//  444             pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
        SJMP    ??Mem_Copy_1
//  445         }
//  446     }
//  447 
//  448     while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
//  449        *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
??Mem_Copy_11:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  450         size_rem      -=  sizeof(CPU_INT08U);
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
//  451     }
??Mem_Copy_1:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Mem_Copy_11
//  452 }
??Mem_Copy_0:
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  453 #endif
//  454 
//  455 
//  456 /*
//  457 *********************************************************************************************************
//  458 *                                             Mem_Move()
//  459 *
//  460 * Description : Move data octets from one memory buffer to another memory buffer, or within the same
//  461 *               memory buffer. Overlapping is correctly handled for all move operations.
//  462 *
//  463 * Argument(s) : pdest       Pointer to destination memory buffer.
//  464 *
//  465 *               psrc        Pointer to source      memory buffer.
//  466 *
//  467 *               size        Number of octets to move (see Note #1).
//  468 *
//  469 * Return(s)   : none.
//  470 *
//  471 * Caller(s)   : Application.
//  472 *
//  473 * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
//  474 *
//  475 *               (2) Memory buffers checked for overlapping.
//  476 *
//  477 *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
//  478 *                   words.
//  479 *
//  480 *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
//  481 *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
//  482 *                       addresses.
//  483 *
//  484 *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
//  485 *                   address boundary.
//  486 *
//  487 *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
//  488 *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
//  489 *                  'mem_align_mod' arithmetic operation.
//  490 *********************************************************************************************************
//  491 */
//  492 /*$PAGE*/
//  493 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  494 void  Mem_Move (       void        *pdest,
Mem_Move:
        CODE
//  495                 const  void        *psrc,
//  496                        CPU_SIZE_T   size)
//  497 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
//  498            CPU_SIZE_T    size_rem;
//  499            CPU_SIZE_T    mem_gap_octets;
//  500            CPU_ALIGN    *pmem_align_dest;
//  501     const  CPU_ALIGN    *pmem_align_src;
//  502            CPU_INT08U   *pmem_08_dest;
//  503     const  CPU_INT08U   *pmem_08_src;
//  504            CPU_INT08S    i;
//  505            CPU_DATA      mem_align_mod_dest;
//  506            CPU_DATA      mem_align_mod_src;
//  507            CPU_BOOLEAN   mem_aligned;
//  508 
//  509 
//  510 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  511     if (size < 1) {
        MOV     A,?V0
        ORL     A,?V1
        JNZ     $+5
        LJMP    ??Mem_Move_0
//  512         return;
//  513     }
//  514     if (pdest == (void *)0) {
        MOV     A,R2
        ORL     A,R3
        JNZ     $+5
        LJMP    ??Mem_Move_0
//  515         return;
//  516     }
//  517     if (psrc  == (void *)0) {
        MOV     A,R4
        ORL     A,R5
        JNZ     $+5
        LJMP    ??Mem_Move_0
//  518         return;
//  519     }
//  520 #endif
//  521 
//  522     pmem_08_src  = (const CPU_INT08U *)psrc;
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  523     pmem_08_dest = (      CPU_INT08U *)pdest;
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
//  524     if (pmem_08_src > pmem_08_dest) {
        CLR     C
        MOV     A,R0
        SUBB    A,R6
        MOV     A,R1
        SUBB    A,R7
        JNC     ??Mem_Move_1
//  525         Mem_Copy(pdest, psrc, size);
        ; Setup parameters for call to function Mem_Copy
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Mem_Copy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  526         return;
        LJMP    ??Mem_Move_0
//  527     }
//  528 
//  529     size_rem           =  size;
??Mem_Move_1:
        MOV     ?V2,?V0
        MOV     ?V3,?V1
//  530 
//  531     pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
        MOV     A,R2
        ADD     A,?V0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,?V1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  532     pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
        MOV     A,R4
        ADD     A,?V0
        MOV     R2,A
        MOV     A,R5
        ADDC    A,?V1
        MOV     R3,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R7,A
//  533     
//  534     mem_gap_octets     = pmem_08_dest - pmem_08_src;
        MOV     A,R0
        CLR     C
        SUBB    A,R6
        MOV     R2,A
        MOV     A,R1
        SUBB    A,R7
        MOV     R3,A
//  535     
//  536 
//  537     if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
        CLR     C
        MOV     A,R2
        SUBB    A,#0x2
        MOV     A,R3
        SUBB    A,#0x0
        JNC     $+5
        LJMP    ??Mem_Move_2
//  538     
//  539                                                                 /* See Note #4.                                         */
//  540         mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
        MOV     A,R0
        ANL     A,#0x1
        MOV     R2,A
        MOV     R3,#0x0
//  541         mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
        MOV     A,R6
        ANL     A,#0x1
        MOV     R4,A
        MOV     R5,#0x0
//  542 
//  543         mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
        MOV     A,R4
        XRL     A,R2
        JNZ     ??Mem_Move_3
        MOV     A,R5
        XRL     A,R3
??Mem_Move_3:
        JNZ     ??Mem_Move_4
        MOV     R4,#0x1
        SJMP    ??Mem_Move_5
??Mem_Move_4:
        MOV     R4,#0x0
//  544 
//  545         if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
??Mem_Move_5:
        MOV     A,#0x1
        XRL     A,R4
        JZ      $+5
        LJMP    ??Mem_Move_2
//  546                                                                 /* ... optimize copy for mem buf alignment.             */
//  547             if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
        MOV     A,#0x1
        XRL     A,R2
        JNZ     ??Mem_Move_6
        MOV     A,#0x0
        XRL     A,R3
??Mem_Move_6:
        JZ      ??Mem_Move_7
//  548                 i = mem_align_mod_dest;
        MOV     A,R2
        MOV     R2,A
        SJMP    ??Mem_Move_8
//  549                 while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
//  550                        (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
//  551                    *pmem_08_dest-- = *pmem_08_src--;
??Mem_Move_9:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        MOVX    @DPTR,A
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  552                     size_rem      -=  sizeof(CPU_INT08U);
        MOV     A,?V2
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
//  553                     i--;
        MOV     A,#-0x1
        ADD     A,R2
        MOV     R2,A
//  554                 }
??Mem_Move_8:
        MOV     A,?V2
        ORL     A,?V3
        JZ      ??Mem_Move_7
        MOV     A,R2
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??Mem_Move_9
//  555             }
//  556 
//  557                                                                 /* See Note #3a.                                        */
//  558             pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
??Mem_Move_7:
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R5,A
//  559             pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R3,A
        SJMP    ??Mem_Move_10
//  560             while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
//  561                *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
??Mem_Move_11:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x2
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R4
        ADD     A,#-0x2
        MOV     R0,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
//  562                 size_rem         -=  sizeof(CPU_ALIGN);
        MOV     A,?V2
        ADD     A,#-0x2
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
//  563             }
??Mem_Move_10:
        CLR     C
        MOV     A,?V2
        SUBB    A,#0x2
        MOV     A,?V3
        SUBB    A,#0x0
        JNC     ??Mem_Move_11
//  564 
//  565             pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  566             pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
        SJMP    ??Mem_Move_2
//  567 
//  568         }
//  569     }
//  570 
//  571     while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
//  572        *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
??Mem_Move_12:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        MOVX    @DPTR,A
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  573         size_rem      -=  sizeof(CPU_INT08U);
        MOV     A,?V2
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
//  574     }
??Mem_Move_2:
        MOV     A,?V2
        ORL     A,?V3
        JNZ     ??Mem_Move_12
//  575 }
??Mem_Move_0:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
//  576 
//  577 
//  578 /*$PAGE*/
//  579 /*
//  580 *********************************************************************************************************
//  581 *                                              Mem_Cmp()
//  582 *
//  583 * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
//  584 *
//  585 * Argument(s) : p1_mem      Pointer to first  memory buffer.
//  586 *
//  587 *               p2_mem      Pointer to second memory buffer.
//  588 *
//  589 *               size        Number of data buffer octets to compare (see Note #1).
//  590 *
//  591 * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
//  592 *
//  593 *               DEF_NO,  otherwise.
//  594 *
//  595 * Caller(s)   : Application.
//  596 *
//  597 * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
//  598 *                   identical null compare.
//  599 *
//  600 *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
//  601 *                   network address buffers.  Consequently, memory buffer comparison is more efficient
//  602 *                   if the comparison starts from the end of the memory buffers which will abort sooner
//  603 *                   on dissimilar memory buffers that vary only in the least significant octets.
//  604 *
//  605 *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
//  606 *                   data words.
//  607 *
//  608 *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
//  609 *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
//  610 *                       addresses.
//  611 *
//  612 *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
//  613 *                   address boundary.
//  614 *
//  615 *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
//  616 *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
//  617 *                  'mem_align_mod' arithmetic operation.
//  618 *********************************************************************************************************
//  619 */
//  620 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  621 CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
Mem_Cmp:
        CODE
//  622                       const  void        *p2_mem,
//  623                              CPU_SIZE_T   size)
//  624 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
//  625            CPU_SIZE_T    size_rem;
//  626            CPU_ALIGN    *p1_mem_align;
//  627            CPU_ALIGN    *p2_mem_align;
//  628     const  CPU_INT08U   *p1_mem_08;
//  629     const  CPU_INT08U   *p2_mem_08;
//  630            CPU_DATA      i;
//  631            CPU_DATA      mem_align_mod_1;
//  632            CPU_DATA      mem_align_mod_2;
//  633            CPU_BOOLEAN   mem_aligned;
//  634            CPU_BOOLEAN   mem_cmp;
//  635 
//  636 
//  637     if (size < 1) {                                             /* See Note #1.                                         */
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Mem_Cmp_0
//  638         return (DEF_YES);
        MOV     R1,#0x1
        LJMP    ??Mem_Cmp_1
//  639     }
//  640     if (p1_mem == (void *)0) {
??Mem_Cmp_0:
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_Cmp_2
//  641         return (DEF_NO);
        MOV     R1,#0x0
        LJMP    ??Mem_Cmp_1
//  642     }
//  643     if (p2_mem == (void *)0) {
??Mem_Cmp_2:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_Cmp_3
//  644         return (DEF_NO);
        MOV     R1,#0x0
        LJMP    ??Mem_Cmp_1
//  645     }
//  646 
//  647 
//  648     mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
??Mem_Cmp_3:
        MOV     R4,#0x1
//  649     size_rem        =  size;
        MOV     R2,?V0
        MOV     R3,?V1
//  650                                                                 /* Start @ end of mem bufs (see Note #2).               */
//  651     p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
        MOV     A,R0
        ADD     A,?V0
        MOV     R0,A
        MOV     A,R1
        ADDC    A,?V1
        MOV     R1,A
//  652     p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
        MOV     A,R6
        ADD     A,?V0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V1
        MOV     R7,A
//  653                                                                 /* See Note #4.                                         */
//  654     mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
        MOV     A,R0
        ANL     A,#0x1
        MOV     ?V0,A
        MOV     ?V1,#0x0
//  655     mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
        MOV     A,R6
        ANL     A,#0x1
        MOV     ?V2,A
        MOV     ?V3,#0x0
//  656 
//  657     mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
        MOV     A,?V2
        XRL     A,?V0
        JNZ     ??Mem_Cmp_4
        MOV     A,?V3
        XRL     A,?V1
??Mem_Cmp_4:
        JNZ     ??Mem_Cmp_5
        MOV     R5,#0x1
        SJMP    ??Mem_Cmp_6
??Mem_Cmp_5:
        MOV     R5,#0x0
//  658 
//  659     if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
??Mem_Cmp_6:
        MOV     A,#0x1
        XRL     A,R5
        JZ      $+5
        LJMP    ??Mem_Cmp_7
//  660                                                                 /* ... optimize cmp for mem buf alignment.              */
//  661         if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
        MOV     A,?V0
        ORL     A,?V1
        JZ      ??Mem_Cmp_8
//  662             i = mem_align_mod_1;
        MOV     ?V2,?V0
        MOV     ?V3,?V1
        SJMP    ??Mem_Cmp_9
//  663             while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
//  664                    (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
//  665                    (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
//  666                 p1_mem_08--;
??Mem_Cmp_10:
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  667                 p2_mem_08--;
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
//  668                 if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,R5
        JZ      ??Mem_Cmp_11
//  669                      mem_cmp = DEF_NO;
        MOV     R4,#0x0
//  670                 }
//  671                 size_rem -= sizeof(CPU_INT08U);
??Mem_Cmp_11:
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
//  672                 i--;
        MOV     A,?V2
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
//  673             }
??Mem_Cmp_9:
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??Mem_Cmp_8
        MOV     A,R2
        ORL     A,R3
        JZ      ??Mem_Cmp_8
        MOV     A,?V2
        ORL     A,?V3
        JNZ     ??Mem_Cmp_10
//  674         }
//  675 
//  676         if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
??Mem_Cmp_8:
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??Mem_Cmp_7
//  677             p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
//  678             p2_mem_align = (CPU_ALIGN *)p2_mem_08;
        SJMP    ??Mem_Cmp_12
//  679 
//  680             while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
//  681                    (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
//  682                 p1_mem_align--;
??Mem_Cmp_13:
        MOV     A,R0
        ADD     A,#-0x2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  683                 p2_mem_align--;
        MOV     A,R6
        ADD     A,#-0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
//  684                 if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,?V0
        JNZ     ??Mem_Cmp_14
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,?V1
??Mem_Cmp_14:
        JZ      ??Mem_Cmp_15
//  685                      mem_cmp = DEF_NO;
        MOV     R4,#0x0
//  686                 }
//  687                 size_rem -= sizeof(CPU_ALIGN);
??Mem_Cmp_15:
        MOV     A,R2
        ADD     A,#-0x2
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
//  688             }
??Mem_Cmp_12:
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??Mem_Cmp_7
        CLR     C
        MOV     A,R2
        SUBB    A,#0x2
        MOV     A,R3
        SUBB    A,#0x0
        JNC     ??Mem_Cmp_13
//  689 
//  690             p1_mem_08 = (CPU_INT08U *)p1_mem_align;
//  691             p2_mem_08 = (CPU_INT08U *)p2_mem_align;
        SJMP    ??Mem_Cmp_7
//  692         }
//  693     }
//  694 
//  695     while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
//  696            (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
//  697         p1_mem_08--;
??Mem_Cmp_16:
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
//  698         p2_mem_08--;
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
//  699         if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,R5
        JZ      ??Mem_Cmp_17
//  700              mem_cmp = DEF_NO;
        MOV     R4,#0x0
//  701         }
//  702         size_rem -= sizeof(CPU_INT08U);
??Mem_Cmp_17:
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
//  703     }
??Mem_Cmp_7:
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??Mem_Cmp_18
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Mem_Cmp_16
//  704 
//  705     return (mem_cmp);
??Mem_Cmp_18:
        MOV     A,R4
        MOV     R1,A
??Mem_Cmp_1:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
//  706 }
//  707 
//  708 
//  709 /*$PAGE*/
//  710 /*
//  711 *********************************************************************************************************
//  712 *                                           Mem_HeapAlloc()
//  713 *
//  714 * Description : Allocate a memory block from the heap memory pool.
//  715 *
//  716 * Argument(s) : size            Size      of memory block to allocate (in octets).
//  717 *
//  718 *               align           Alignment of memory block to specific word boundary (in octets).
//  719 *
//  720 *               poctets_reqd    Optional pointer to a variable to ... :
//  721 *
//  722 *                                   (a) Return the number of octets required to successfully
//  723 *                                           allocate the memory block, if any error(s);
//  724 *                                   (b) Return 0, otherwise.
//  725 *
//  726 *               perr        Pointer to variable that will receive the return error code from this function :
//  727 *
//  728 *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
//  729 *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
//  730 *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
//  731 *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available
//  732 *                                                                   memory from heap.
//  733 *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
//  734 *
//  735 * Return(s)   : Pointer to memory block, if NO error(s).
//  736 *
//  737 *               Pointer to NULL,         otherwise.
//  738 *
//  739 * Caller(s)   : Application.
//  740 *
//  741 * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
//  742 *                   validation or function handling in case of any error(s).
//  743 *
//  744 *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
//  745 *********************************************************************************************************
//  746 */
//  747 /*$PAGE*/
//  748 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  749 void  *Mem_HeapAlloc (CPU_SIZE_T   size,
Mem_HeapAlloc:
        CODE
//  750                       CPU_SIZE_T   align,
//  751                       CPU_SIZE_T  *poctets_reqd,
//  752                       LIB_ERR     *perr)
//  753 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  754     MEM_POOL    *pmem_pool_heap;
//  755     void        *pmem_addr;
//  756     void        *pmem_blk;
//  757     CPU_SIZE_T   octets_reqd_unused;
//  758     CPU_SIZE_T   size_rem;
//  759     CPU_SIZE_T   size_req;
//  760     CPU_SR_ALLOC();
        MOV     ?V2,#0x0
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
//  761 
//  762 
//  763 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
//  764     if (perr == (LIB_ERR *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_HeapAlloc_0
//  765         CPU_SW_EXCEPTION((void *)0);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
//  766     }
//  767 #endif
//  768 
//  769                                                                     /* ------------ VALIDATE RTN OCTETS PTR ----------- */
//  770     if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
??Mem_HeapAlloc_0:
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_HeapAlloc_1
//  771         poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP100_8
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  772        (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP100_8
//  773     }
//  774    *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
??Mem_HeapAlloc_1:
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  775 
//  776 
//  777 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
//  778     if (size < 1) {
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Mem_HeapAlloc_2
//  779        *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x74
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  780         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_HeapAlloc_3
//  781     }
//  782 
//  783     if (align < 1) {
??Mem_HeapAlloc_2:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_HeapAlloc_4
//  784        *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x75
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  785         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_HeapAlloc_3
//  786     }
//  787 #endif
//  788 
//  789                                                                     /* -------------- ALLOC HEAP MEM BLK -------------- */
//  790     pmem_pool_heap = &Mem_PoolHeap;
??Mem_HeapAlloc_4:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#Mem_PoolHeap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_PoolHeap >> 8) & 0xff
        MOVX    @DPTR,A
//  791 
//  792     CPU_CRITICAL_ENTER();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     ?V2,A
//  793 
//  794     pmem_addr = pmem_pool_heap->SegAddrNextAvail;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x20
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
//  795     size_rem  = pmem_pool_heap->SegSizeRem;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  796     size_req  = Mem_SegCalcTotSize(pmem_addr,
//  797                                    1u,                              /* Calc alloc for single mem blk from heap.         */
//  798                                    size,
//  799                                    align);
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     ?V6,R6
        MOV     ?V7,R7
        MOV     R0,#?V6
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#0x1
        MOV     R5,#0x0
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  800 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  801     if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_HeapAlloc_5
//  802         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V2
        LCALL   CPU_SR_Restore
//  803        *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        MOVX    @DPTR,A
//  804        *perr         = LIB_MEM_ERR_HEAP_OVF;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x1d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  805         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_HeapAlloc_3
//  806     }
//  807 #endif
//  808 
//  809     if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
??Mem_HeapAlloc_5:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        PUSH    DPH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JNC     ??Mem_HeapAlloc_6
//  810         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V2
        LCALL   CPU_SR_Restore
//  811        *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        PUSH    DPL
        PUSH    DPH
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        POP     DPL
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  812        *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x1e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  813         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_HeapAlloc_3
//  814     }
//  815 
//  816     pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
??Mem_HeapAlloc_6:
        ; Setup parameters for call to function Mem_SegAlloc
        MOV     ?V6,R6
        MOV     ?V7,R7
        MOV     R0,#?V6
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,?V0
        MOV     R5,?V1
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegAlloc
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R6,?V0
        MOV     R7,?V1
//  817     if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_HeapAlloc_7
//  818         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V2
        LCALL   CPU_SR_Restore
//  819        *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  820        *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x1e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  821         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_HeapAlloc_3
//  822     }
//  823 
//  824     CPU_CRITICAL_EXIT();
??Mem_HeapAlloc_7:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V2
        LCALL   CPU_SR_Restore
//  825 
//  826    *perr =  LIB_MEM_ERR_NONE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  827 
//  828     return (pmem_blk);
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??Mem_HeapAlloc_3:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
//  829 }
//  830 #endif
//  831 
//  832 
//  833 /*$PAGE*/
//  834 /*
//  835 *********************************************************************************************************
//  836 *                                        Mem_HeapGetSizeRem()
//  837 *
//  838 * Description : Get remaining heap memory size available to allocate.
//  839 *
//  840 * Argument(s) : align       Desired word boundary alignment (in octets) to return remaining memory size from.
//  841 *
//  842 *               perr        Pointer to variable that will receive the return error code from this function :
//  843 *
//  844 *                                                               ---- RETURNED BY Mem_PoolGetSizeRem() : ----
//  845 *                               LIB_MEM_ERR_NONE                Heap memory pool remaining size successfully
//  846 *                                                                   returned.
//  847 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
//  848 *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
//  849 *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
//  850 *
//  851 * Return(s)   : Remaining heap memory size (in octets), if NO error(s).
//  852 *
//  853 *               0,                                      otherwise.
//  854 *
//  855 * Caller(s)   : Application.
//  856 *
//  857 * Note(s)     : none.
//  858 *********************************************************************************************************
//  859 */
//  860 
//  861 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  862 CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
Mem_HeapGetSizeRem:
        CODE
//  863                                 LIB_ERR     *perr)
//  864 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  865     CPU_SIZE_T  size_rem;
//  866 
//  867 
//  868     size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
        ; Setup parameters for call to function Mem_SegGetSizeRem
        MOV     ?V0,R4
        MOV     ?V1,R5
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     R2,#Mem_PoolHeap & 0xff
        MOV     R3,#(Mem_PoolHeap >> 8) & 0xff
        LCALL   Mem_SegGetSizeRem
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
//  869 
//  870     return (size_rem);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  871 }
//  872 #endif
//  873 
//  874 
//  875 /*$PAGE*/
//  876 /*
//  877 *********************************************************************************************************
//  878 *                                         Mem_SegGetSizeRem()
//  879 *
//  880 * Description : Get memory pool's remaining segment size available to allocate.
//  881 *
//  882 * Argument(s) : pmem_pool   Pointer to a memory pool structure.
//  883 *
//  884 *               align       Desired word boundary alignment (in octets) to return remaining memory size from.
//  885 *
//  886 *               perr        Pointer to variable that will receive the return error code from this function :
//  887 *
//  888 *                               LIB_MEM_ERR_NONE                Memory segment remaining size successfully
//  889 *                                                                   returned.
//  890 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
//  891 *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
//  892 *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
//  893 *
//  894 * Return(s)   : Remaining memory segment size (in octets) [see Note #1], if NO error(s).
//  895 *
//  896 *               0,                                                       otherwise.
//  897 *
//  898 * Caller(s)   : Application.
//  899 *
//  900 * Note(s)     : (1) Remaining size of memory segment returned from either :
//  901 *
//  902 *                   (a) Segment's configured dedicated memory, if any
//  903 *                   (b) Heap memory pool,                      otherwise
//  904 *
//  905 *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
//  906 *********************************************************************************************************
//  907 */
//  908 /*$PAGE*/
//  909 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  910 CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
Mem_SegGetSizeRem:
        CODE
//  911                                CPU_SIZE_T   align,
//  912                                LIB_ERR     *perr)
//  913 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     ?V6,R2
        MOV     ?V7,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  914     MEM_POOL    *pmem_seg;
//  915     MEM_POOL    *pmem_seg_size;
//  916     CPU_SIZE_T   size_rem;
//  917     CPU_SIZE_T   size_rem_mod;
//  918     CPU_SIZE_T   seg_addr_mod;
//  919     CPU_ADDR     seg_addr;
//  920     CPU_SR_ALLOC();
        MOV     R1,#0x0
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
//  921 
//  922 
//  923 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  924                                                                 /* --------------- VALIDATE RTN ERR PTR --------------- */
//  925     if (perr == (LIB_ERR *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_SegGetSizeRem_0
//  926         CPU_SW_EXCEPTION(0u);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
//  927     }
//  928                                                                 /* ---------------- VALIDATE MEM ALIGN ---------------- */
//  929     if (align < 1) {
??Mem_SegGetSizeRem_0:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_SegGetSizeRem_1
//  930        *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x75
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  931         return (0u);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_SegGetSizeRem_2
//  932     }
//  933 	if (align > DEF_ALIGN_MAX_NBR_OCTETS) {
??Mem_SegGetSizeRem_1:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x1
        MOV     A,R7
        SUBB    A,#0x10
        JC      ??Mem_SegGetSizeRem_3
//  934 	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x75
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  935         return (0u);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_SegGetSizeRem_2
//  936     }
//  937                                                                 /* ---------------- VALIDATE MEM POOL ----------------- */
//  938     if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
??Mem_SegGetSizeRem_3:
        MOV     A,?V6
        ORL     A,?V7
        JNZ     ??Mem_SegGetSizeRem_4
//  939        *perr =  LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  940         return (0u);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_SegGetSizeRem_2
//  941     }
//  942 #endif
//  943 
//  944     CPU_CRITICAL_ENTER();
??Mem_SegGetSizeRem_4:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
//  945 
//  946 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
//  947     switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0
        LCALL   ?UL_SWITCH_SPARSE
`?<Jumptable for Mem_SegGetSizeRem>_0`:
        DATA
        DATA32
        DATA
        DATA32
        DATA
        DATA32
        DD        0
        DATA
        DATA32
        DATA
        DATA32
        DATA
        DATA32
        DD        2
        DATA
        DATA32
        DATA
        DATA32
        DATA
        DATA32
        DD        1162367041
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??Mem_SegGetSizeRem_5
        DATA
        DATA32
        DATA
        DATA32
        DATA
        DATA32
        DD        1330662479
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??Mem_SegGetSizeRem_5
        DATA
        DATA16
        DATA
        DATA16
        DW        ??Mem_SegGetSizeRem_6
        CODE
//  948         case LIB_MEM_TYPE_HEAP:
//  949         case LIB_MEM_TYPE_POOL:
//  950              break;
//  951 
//  952 
//  953         case LIB_MEM_TYPE_NONE:
//  954         default:
//  955              CPU_CRITICAL_EXIT();
//  956             *perr =  LIB_MEM_ERR_INVALID_POOL;
//  957              return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
//  958     }
//  959 #endif
//  960 
//  961                                                                 /* ------------- GET REM'ING MEM SEG SIZE ------------- */
//  962     pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
??Mem_SegGetSizeRem_5:
        MOV     DPL,?V6
        MOV     DPH,?V7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
//  963     pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
//  964                   ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
        MOV     A,R2
        ADD     A,#0x1e
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        ORL     A,R5
        JZ      ??Mem_SegGetSizeRem_7
        SJMP    ??Mem_SegGetSizeRem_8
??Mem_SegGetSizeRem_6:
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegGetSizeRem_2
??Mem_SegGetSizeRem_7:
        MOV     R2,#Mem_PoolHeap & 0xff
        MOV     R3,#(Mem_PoolHeap >> 8) & 0xff
//  965     size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
??Mem_SegGetSizeRem_8:
        MOV     A,R2
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
//  966     seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
        MOV     A,R2
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
//  967 
//  968     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
//  969 
//  970     if (align > 1) {                                            /* If align > 1 octet, ...                              */
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        JC      ??Mem_SegGetSizeRem_9
//  971         seg_addr_mod  =  seg_addr % align;
        MOV     R0,?V0
        MOV     R1,?V1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R0,?V0
        MOV     R1,?V1
//  972         size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_SegGetSizeRem_10
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        MOV     A,R7
        SUBB    A,R1
        MOV     R1,A
        SJMP    ??Mem_SegGetSizeRem_11
??Mem_SegGetSizeRem_10:
        MOV     R0,#0x0
        MOV     R1,#0x0
//  973         size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
??Mem_SegGetSizeRem_11:
        CLR     C
        MOV     A,?V2
        SUBB    A,R0
        MOV     ?V2,A
        MOV     A,?V3
        SUBB    A,R1
        MOV     ?V3,A
//  974     }
//  975 
//  976 
//  977    *perr =  LIB_MEM_ERR_NONE;
??Mem_SegGetSizeRem_9:
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
//  978 
//  979     return (size_rem);
        MOV     R2,?V2
        MOV     R3,?V3
??Mem_SegGetSizeRem_2:
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
//  980 }
//  981 #endif
//  982 
//  983 
//  984 /*$PAGE*/
//  985 /*
//  986 *********************************************************************************************************
//  987 *                                            Mem_PoolClr()
//  988 *
//  989 * Description : Clear a memory pool (see Note #1).
//  990 *
//  991 * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
//  992 *
//  993 *               perr        Pointer to variable that will receive the return error code from this function :
//  994 *
//  995 *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
//  996 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
//  997 *
//  998 * Return(s)   : none.
//  999 *
// 1000 * Caller(s)   : Application,
// 1001 *               Mem_PoolCreate().
// 1002 *
// 1003 * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
// 1004 *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
// 1005 *
// 1006 *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
// 1007 *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
// 1008 *                       this will likely corrupt the memory pool management.
// 1009 *
// 1010 *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
// 1011 *********************************************************************************************************
// 1012 */
// 1013 
// 1014 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1015 void  Mem_PoolClr (MEM_POOL  *pmem_pool,
Mem_PoolClr:
        CODE
// 1016                    LIB_ERR   *perr)
// 1017 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0,R4
        MOV     ?V1,R5
// 1018 
// 1019 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
// 1020     if (perr == (LIB_ERR *)0) {
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Mem_PoolClr_0
// 1021         CPU_SW_EXCEPTION(;);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1022     }
// 1023 #endif
// 1024 
// 1025                                                                 /* -------------- VALIDATE MEM POOL PTR --------------- */
// 1026     if (pmem_pool == (MEM_POOL *)0) {
??Mem_PoolClr_0:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_PoolClr_1
// 1027        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V0
        MOV     DPH,?V1
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1028         return;
        LJMP    ??Mem_PoolClr_2
// 1029     }
// 1030 
// 1031 
// 1032     pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
??Mem_PoolClr_1:
        MOV     R2,#0x4e
        MOV     R3,#0x45
        MOV     R4,#0x4e
        MOV     R5,#0x4f
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1033     pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1034     pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1035     pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1036     pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1037     pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
        MOV     A,R6
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1038     pmem_pool->PoolAddrStart    = (void       *)0;
        MOV     A,R6
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1039     pmem_pool->PoolAddrEnd      = (void       *)0;
        MOV     A,R6
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1040     pmem_pool->PoolPtrs         = (void      **)0;
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1041     pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x16
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1042     pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1043     pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1044     pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1045     pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1046     pmem_pool->SegAddr          = (void       *)0;
        MOV     A,R6
        ADD     A,#0x1e
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1047     pmem_pool->SegAddrNextAvail = (void       *)0;
        MOV     A,R6
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1048     pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1049     pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1050 
// 1051 
// 1052    *perr = LIB_MEM_ERR_NONE;
        MOV     DPL,?V0
        MOV     DPH,?V1
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1053 }
??Mem_PoolClr_2:
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1054 #endif
// 1055 
// 1056 
// 1057 /*$PAGE*/
// 1058 /*
// 1059 *********************************************************************************************************
// 1060 *                                          Mem_PoolCreate()
// 1061 *
// 1062 * Description : (1) Create a memory pool :
// 1063 *
// 1064 *                   (a) Create    memory pool from heap or dedicated memory
// 1065 *                   (b) Allocate  memory pool memory blocks
// 1066 *                   (c) Update    memory pool table
// 1067 *                   (d) Configure memory pool
// 1068 *
// 1069 *
// 1070 *               (2) Memory pools are indexed by the Memory Segments they use.
// 1071 *
// 1072 *                   (a) The memory pool table is composed by a two-dimensional list :
// 1073 *
// 1074 *                       (1) Memory segments manage the following memory segment/pool information :
// 1075 *
// 1076 *                           (A) Memory segment base           address
// 1077 *                           (B) Memory segment next available address
// 1078 *                           (C) Memory segment total     size
// 1079 *                           (D) Memory segment remaining size
// 1080 *
// 1081 *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
// 1082 *                           segment information.  To access the memory segment information, the head
// 1083 *                           memory segment must be accessed via each memory pool's 'SegHeadPtr'.
// 1084 *
// 1085 *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
// 1086 *                       memory segment for the memory blocks they have.  The heads of the memory pool are
// 1087 *                       linked horizontally to form a memory pool table.
// 1088 *
// 1089 *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
// 1090 *
// 1091 *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
// 1092 *                           form the list of memory segments.
// 1093 *
// 1094 *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
// 1095 *                           each memory segment.
// 1096 *
// 1097 *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
// 1098 *                       Segments Primary List.  The point of insertion is such to keep ascended order by
// 1099 *                       memory segment base address.
// 1100 *
// 1101 *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
// 1102 *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
// 1103 *
// 1104 *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
// 1105 *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
// 1106 *                           memory pool.
// 1107 *
// 1108 *
// 1109 *                                        |                                                                 |
// 1110 *                                        |<----------------------- Memory Segments ----------------------->|
// 1111 *                                        |                         (see Note #2a1)                         |
// 1112 *
// 1113 *                                 Lowest Memory Segment                                      Highest Memory Segment
// 1114 *                                     Base Address                                                Base Address
// 1115 *                                    (see Note #2c)                                              (see Note #2c)
// 1116 *
// 1117 *                                           |             SegNextPtr             Heap Memory Pool       |
// 1118 *                                           |          (see Note #2b2)            (see Note #2d)        |
// 1119 *                                           |                     |                                     |
// 1120 *                                           v                     |                      |              v
// 1121 *                                                                 |                      v
// 1122 *        ---          Head of Memory     -------        -------   v    -------        -------        -------
// 1123 *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
// 1124 *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
// 1125 *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
// 1126 *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
// 1127 *         |                              |     |        |     |   |    |     |        |  P  |        |     |
// 1128 *         |                              |     |        |     |   |    |     |        |     |        |     |
// 1129 *         |                              -------        -------   |    -------        -------        -------
// 1130 *         |                                | ^                    |      | ^
// 1131 *         |                                | |            SegPrevPtr     | |
// 1132 *         |                                v |         (see Note #2b2)   v |
// 1133 *         |                              -------                       -------
// 1134 *                                        |     |                       |     |
// 1135 *    Memory Pools                        |     |                       |     |
// 1136 *  (see Note #2a2)                       |     |                       |     |
// 1137 *                                        |     |                       |     |
// 1138 *         |                              |     |                       |     |
// 1139 *         |                              -------                       -------
// 1140 *         |                                | ^
// 1141 *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
// 1142 *         |             (see Note #2b3)    v |    (see Note #2b3)
// 1143 *         |                              -------
// 1144 *         |                              |     |
// 1145 *         |                              |     |
// 1146 *         |                              |     |
// 1147 *         |                              |     |
// 1148 *         v                              |     |
// 1149 *        ---                             -------
// 1150 *
// 1151 *$PAGE*
// 1152 * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
// 1153 *
// 1154 *               pmem_base_addr      Memory pool base address :
// 1155 *
// 1156 *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
// 1157 *                                       (b) Non-null address    Memory pool allocated from dedicated memory
// 1158 *                                                                   specified by its base address.
// 1159 *
// 1160 *               mem_size            Size      of memory pool segment          (in octets).
// 1161 *
// 1162 *               blk_nbr             Number    of memory pool blocks to create.
// 1163 *
// 1164 *               blk_size            Size      of memory pool blocks to create (in octets).
// 1165 *
// 1166 *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
// 1167 *
// 1168 *               poctets_reqd        Optional pointer to a variable to ... :
// 1169 *
// 1170 *                                       (a) Return the number of octets required to successfully
// 1171 *                                               allocate the memory pool, if any error(s);
// 1172 *                                       (b) Return 0, otherwise.
// 1173 *
// 1174 *               perr        Pointer to variable that will receive the return error code from this function :
// 1175 *
// 1176 *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
// 1177 *
// 1178 *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
// 1179 *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available
// 1180 *                                                                       memory from heap.
// 1181 *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
// 1182 *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available
// 1183 *                                                                       memory from segment for memory pools.
// 1184 *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
// 1185 *
// 1186 *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
// 1187 *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
// 1188 *                                                                       segment(s) in memory pool table.
// 1189 *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
// 1190 *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
// 1191 *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
// 1192 *
// 1193 *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
// 1194 *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
// 1195 *
// 1196 * Return(s)   : none.
// 1197 *
// 1198 * Caller(s)   : Application.
// 1199 *
// 1200 * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
// 1201 *
// 1202 *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other
// 1203 *                   validation or function handling in case of any error(s).
// 1204 *
// 1205 *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 1206 *********************************************************************************************************
// 1207 */
// 1208 /*$PAGE*/
// 1209 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1210 void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
Mem_PoolCreate:
        CODE
// 1211                       void              *pmem_base_addr,
// 1212                       CPU_SIZE_T         mem_size,
// 1213                       MEM_POOL_BLK_QTY   blk_nbr,
// 1214                       CPU_SIZE_T         blk_size,
// 1215                       CPU_SIZE_T         blk_align,
// 1216                       CPU_SIZE_T        *poctets_reqd,
// 1217                       LIB_ERR           *perr)
// 1218 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 23
        MOV     A,#-0x17
        LCALL   ?ALLOC_XSTACK8
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V6,R2
        MOV     ?V7,R3
// 1219     MEM_POOL           *pmem_pool_heap;
// 1220     MEM_POOL           *pmem_pool_next;
// 1221     MEM_POOL           *pmem_seg;
// 1222     MEM_POOL           *pmem_seg_prev;
// 1223     MEM_POOL           *pmem_seg_next;
// 1224     void              **ppool_ptr;
// 1225     void               *pmem_blk;
// 1226     CPU_INT08U         *pmem_addr_ptrs;
// 1227     CPU_INT08U         *pmem_addr_pool;
// 1228     CPU_INT08U         *pmem_base_addr_start;
// 1229     CPU_INT08U         *pmem_base_addr_end;
// 1230     CPU_INT08U         *pmem_seg_addr_start;
// 1231     CPU_INT08U         *pmem_seg_addr_end;
// 1232     MEM_POOL_BLK_QTY    blk_rem;
// 1233     CPU_SIZE_T          octets_reqd_unused;
// 1234     CPU_SIZE_T          size_tot;
// 1235     CPU_SIZE_T          size_tot_ptrs;
// 1236     CPU_SIZE_T          size_tot_pool;
// 1237     CPU_SIZE_T          size_rem;
// 1238     CPU_SIZE_T          size_pool_ptrs;
// 1239     CPU_SIZE_T          i;
// 1240     CPU_SR_ALLOC();
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1241 
// 1242 
// 1243 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
// 1244     if (perr == (LIB_ERR *)0) {
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_0
// 1245         CPU_SW_EXCEPTION(;);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1246     }
// 1247 #endif
// 1248 
// 1249                                                                     /* ------------ VALIDATE RTN OCTETS PTR ----------- */
// 1250     if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
??Mem_PoolCreate_0:
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_1
// 1251         poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP100_8
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1252        (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP100_8
// 1253     }
// 1254    *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
??Mem_PoolCreate_1:
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1255 
// 1256 
// 1257 
// 1258     Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
        ; Setup parameters for call to function Mem_PoolClr
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   Mem_PoolClr
// 1259     if (*perr != LIB_MEM_ERR_NONE) {
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        XRL     A,#0x10
        JNZ     ??Mem_PoolCreate_2
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x27
??Mem_PoolCreate_2:
        JZ      $+5
        LJMP    ??Mem_PoolCreate_3
// 1260          return;
// 1261     }
// 1262 
// 1263 
// 1264                                                                     /* ----------- VALIDATE MEM POOL CREATE ----------- */
// 1265 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1266     if (pmem_base_addr != (void *)0) {
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_PoolCreate_4
// 1267         if (mem_size < 1) {
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_4
// 1268            *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x7e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1269             return;
        LJMP    ??Mem_PoolCreate_3
// 1270         }
// 1271     }
// 1272 
// 1273     if (blk_nbr < 1) {
??Mem_PoolCreate_4:
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_5
// 1274        *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x6e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1275         return;
        LJMP    ??Mem_PoolCreate_3
// 1276     }
??Mem_PoolCreate_5:
        MOV     A,#0x2a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
// 1277 
// 1278     if (blk_size < 1) {
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_PoolCreate_6
// 1279        *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x6d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1280         return;
        LJMP    ??Mem_PoolCreate_3
// 1281     }
??Mem_PoolCreate_6:
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
// 1282 
// 1283     if (blk_align < 1) {
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Mem_PoolCreate_7
// 1284        *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x6c
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1285         return;
        LJMP    ??Mem_PoolCreate_3
// 1286     }
// 1287 #endif
// 1288 
// 1289 
// 1290                                                                     /* ------------ VALIDATE MEM POOL TBL ------------- */
// 1291     if (Mem_PoolTbl == (MEM_POOL *)0) {
??Mem_PoolCreate_7:
        MOV     DPTR,#Mem_PoolTbl
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_8
// 1292        *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x19
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1293         return;
        LJMP    ??Mem_PoolCreate_3
// 1294     }
// 1295 
// 1296 
// 1297 
// 1298 /*$PAGE*/
// 1299                                                                     /* ---------------- CREATE MEM POOL --------------- */
// 1300     pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
??Mem_PoolCreate_8:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#Mem_PoolHeap & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(Mem_PoolHeap >> 8) & 0xff
        MOVX    @DPTR,A
// 1301     size_tot       = (CPU_SIZE_T) 0u;
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1302 
// 1303     CPU_CRITICAL_ENTER();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        PUSH    A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        POP     A
        MOVX    @DPTR,A
// 1304 
// 1305     if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??Mem_PoolCreate_9
// 1306         pmem_seg        =  pmem_pool_heap;
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1307         pmem_seg_prev   =  pmem_pool_heap;
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1308         pmem_seg_next   =  pmem_pool_heap;
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1309 
// 1310                                                                     /* --------------- VALIDATE MEM SEG --------------- */
// 1311                                                                     /* Calc tot mem   size for mem pool ptrs.           */
// 1312         pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x20
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1313         size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
// 1314                                               (CPU_SIZE_T)blk_nbr,
// 1315                                               (CPU_SIZE_T)sizeof(void *),
// 1316                                               (CPU_SIZE_T)sizeof(void *));
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     ?V2,#0x2
        MOV     ?V3,#0x0
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V2,#0x2
        MOV     ?V3,#0x0
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1317 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1318         if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_10
// 1319             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1320            *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1321             return;
        LJMP    ??Mem_PoolCreate_3
// 1322         }
// 1323 #endif
// 1324                                                                     /* Calc tot mem   size for mem blks.                */
// 1325         pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
??Mem_PoolCreate_10:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1326         size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
// 1327                                               (CPU_SIZE_T)blk_nbr,
// 1328                                               (CPU_SIZE_T)blk_size,
// 1329                                               (CPU_SIZE_T)blk_align);
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1330 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1331         if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_11
// 1332             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1333            *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1334             return;
        LJMP    ??Mem_PoolCreate_3
// 1335         }
// 1336 #endif
// 1337 
// 1338         size_tot = size_tot_ptrs + size_tot_pool;
??Mem_PoolCreate_11:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R7,A
// 1339 
// 1340 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1341         if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
// 1342             (size_tot < size_tot_pool)) {
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JC      ??Mem_PoolCreate_12
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JNC     ??Mem_PoolCreate_13
// 1343             CPU_CRITICAL_EXIT();
??Mem_PoolCreate_12:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1344            *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1345             return;
        LJMP    ??Mem_PoolCreate_3
// 1346         }
// 1347 #endif
// 1348 
// 1349         size_rem = pmem_pool_heap->SegSizeRem;
??Mem_PoolCreate_13:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
// 1350         if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
        CLR     C
        MOV     A,?V2
        SUBB    A,R6
        MOV     A,?V3
        SUBB    A,R7
        JC      $+5
        LJMP    ??Mem_PoolCreate_14
// 1351             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1352            *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
        MOV     A,R6
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        MOV     A,R7
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1353            *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1354             return;
        LJMP    ??Mem_PoolCreate_3
// 1355         }
// 1356 
// 1357 /*$PAGE*/
// 1358     } else {                                                        /* Else cfg mem pool from dedicated mem.            */
// 1359                                                                     /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
// 1360         pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
??Mem_PoolCreate_9:
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1361         pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R3,A
// 1362 
// 1363 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1364         if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        JNC     ??Mem_PoolCreate_15
// 1365             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1366            *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x69
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1367             return;
        LJMP    ??Mem_PoolCreate_3
// 1368         }
// 1369 #endif
// 1370 
// 1371         pmem_seg      = (MEM_POOL *)0;
??Mem_PoolCreate_15:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1372         pmem_seg_prev = (MEM_POOL *)0;
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1373         pmem_seg_next =  Mem_PoolTbl;
        MOV     DPTR,#Mem_PoolTbl
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_16
// 1374 
// 1375         while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
// 1376 
// 1377             if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
// 1378                 (mem_size       == pmem_seg_next->SegSizeTot)) {
// 1379 
// 1380                  pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
// 1381                  break;
// 1382 
// 1383             } else {
// 1384                 pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
// 1385                 pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
// 1386 
// 1387 
// 1388                 if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
// 1389                     break;                                          /* ... new mem seg NOT avail in tbl.                */
// 1390 
// 1391                                                                     /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
// 1392                 } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
// 1393                             (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
// 1394                            ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
// 1395                             (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
// 1396                            ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
// 1397                             (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
// 1398                     CPU_CRITICAL_EXIT();
// 1399                    *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
// 1400                     return;
// 1401                 }
// 1402             }
// 1403                                                                     /* If mem seg NOT found, adv to next mem seg.       */
// 1404             pmem_seg_prev = pmem_seg_next;
??Mem_PoolCreate_17:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1405             pmem_seg_next = pmem_seg_next->SegNextPtr;
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x8
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
??Mem_PoolCreate_16:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_PoolCreate_18
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x1e
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R4
        JNZ     ??Mem_PoolCreate_19
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R5
??Mem_PoolCreate_19:
        JZ      $+5
        LJMP    ??Mem_PoolCreate_20
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x22
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R4
        JNZ     ??Mem_PoolCreate_21
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R5
??Mem_PoolCreate_21:
        JZ      $+5
        LJMP    ??Mem_PoolCreate_20
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1406         }
// 1407 
// 1408         if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
??Mem_PoolCreate_18:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_22
// 1409             pmem_seg                    = pmem_pool;
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
// 1410             pmem_pool->SegAddr          = pmem_base_addr;
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x1e
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1411             pmem_pool->SegAddrNextAvail = pmem_base_addr;
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1412             pmem_pool->SegSizeTot       = mem_size;
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1413             pmem_pool->SegSizeRem       = mem_size;
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1414         }
// 1415 
// 1416 /*$PAGE*/
// 1417                                                                     /* --------------- VALIDATE MEM SEG --------------- */
// 1418                                                                     /* Calc tot mem size for mem pool ptrs.             */
// 1419         pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
??Mem_PoolCreate_22:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x20
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1420         size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
// 1421                                              (CPU_SIZE_T)blk_nbr,
// 1422                                              (CPU_SIZE_T)sizeof(void *),
// 1423                                              (CPU_SIZE_T)sizeof(void *));
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     ?V2,#0x2
        MOV     ?V3,#0x0
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V2,#0x2
        MOV     ?V3,#0x0
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1424 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1425         if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??Mem_PoolCreate_23
// 1426             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1427            *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1428             return;
        LJMP    ??Mem_PoolCreate_3
// 1429         }
??Mem_PoolCreate_20:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x1e
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x22
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x1e
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,?V2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V3
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     ?V3,A
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     $+5
        LJMP    ??Mem_PoolCreate_18
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,R4
        SUBB    A,R0
        MOV     A,R5
        SUBB    A,R1
        JC      ??Mem_PoolCreate_24
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     ??Mem_PoolCreate_25
??Mem_PoolCreate_24:
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JC      ??Mem_PoolCreate_26
        CLR     C
        MOV     A,?V2
        SUBB    A,R2
        MOV     A,?V3
        SUBB    A,R3
        JNC     ??Mem_PoolCreate_25
??Mem_PoolCreate_26:
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,?V2
        SUBB    A,R0
        MOV     A,?V3
        SUBB    A,R1
        JNC     $+5
        LJMP    ??Mem_PoolCreate_17
        CLR     C
        MOV     A,R2
        SUBB    A,?V2
        MOV     A,R3
        SUBB    A,?V3
        JNC     $+5
        LJMP    ??Mem_PoolCreate_17
??Mem_PoolCreate_25:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x7f
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
        LJMP    ??Mem_PoolCreate_3
// 1430 #endif
// 1431 
// 1432         size_rem = pmem_pool_heap->SegSizeRem;
??Mem_PoolCreate_23:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
// 1433         if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,?V2
        SUBB    A,R0
        MOV     A,?V3
        SUBB    A,R1
        JNC     ??Mem_PoolCreate_27
// 1434             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1435            *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1436            *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1437             return;
        LJMP    ??Mem_PoolCreate_3
// 1438         }
// 1439 
// 1440                                                                     /* Calc tot mem size for mem blks.                  */
// 1441         pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
??Mem_PoolCreate_27:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x20
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1442         size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
// 1443                                              (CPU_SIZE_T)blk_nbr,
// 1444                                              (CPU_SIZE_T)blk_size,
// 1445                                              (CPU_SIZE_T)blk_align);
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1446 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1447         if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_28
// 1448             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1449            *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x27
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1450             return;
        LJMP    ??Mem_PoolCreate_3
// 1451         }
// 1452 #endif
// 1453 
// 1454         size_rem = pmem_seg->SegSizeRem;
??Mem_PoolCreate_28:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
// 1455         if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,?V2
        SUBB    A,R0
        MOV     A,?V3
        SUBB    A,R1
        JNC     ??Mem_PoolCreate_14
// 1456             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1457            *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1458            *perr         = LIB_MEM_ERR_SEG_EMPTY;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x28
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1459             return;
        LJMP    ??Mem_PoolCreate_3
// 1460         }
// 1461     }
// 1462 
// 1463 
// 1464 /*$PAGE*/
// 1465                                                                     /* ---------------- ALLOC MEM BLKs ---------------- */
// 1466     size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
??Mem_PoolCreate_14:
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1467                                                                     /* Alloc stk of ptrs for mem blks from heap.        */
// 1468     ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
// 1469                                            (CPU_SIZE_T)size_pool_ptrs,
// 1470                                            (CPU_SIZE_T)sizeof(void *));
        ; Setup parameters for call to function Mem_SegAlloc
        MOV     ?V2,#0x2
        MOV     ?V3,#0x0
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegAlloc
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1471     if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??Mem_PoolCreate_29
// 1472         size_rem = pmem_pool_heap->SegSizeRem;
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
// 1473         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1474                                                                     /* ... rtn add'l heap size needed.                  */
// 1475         if (pmem_base_addr == (void *)0) {
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolCreate_30
// 1476             if (size_tot > size_rem) {
        CLR     C
        MOV     A,?V2
        SUBB    A,R6
        MOV     A,?V3
        SUBB    A,R7
        JNC     ??Mem_PoolCreate_31
// 1477                *poctets_reqd = size_tot - size_rem;
        MOV     A,R6
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        MOV     A,R7
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_32
// 1478             } else {
// 1479                *poctets_reqd = size_tot;
??Mem_PoolCreate_31:
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_32
// 1480             }
// 1481         } else {
// 1482             if (size_pool_ptrs > size_rem) {
??Mem_PoolCreate_30:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,?V2
        SUBB    A,R0
        MOV     A,?V3
        SUBB    A,R1
        JNC     ??Mem_PoolCreate_33
// 1483                *poctets_reqd = size_pool_ptrs - size_rem;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_32
// 1484             } else {
// 1485                *poctets_reqd = size_pool_ptrs;
??Mem_PoolCreate_33:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1486             }
// 1487         }
// 1488        *perr = LIB_MEM_ERR_HEAP_EMPTY;
??Mem_PoolCreate_32:
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x1e
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1489         return;
        LJMP    ??Mem_PoolCreate_3
// 1490     }
// 1491 
// 1492     for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
??Mem_PoolCreate_29:
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??Mem_PoolCreate_34
// 1493         pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
// 1494         if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
// 1495             pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
// 1496             size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
// 1497             CPU_CRITICAL_EXIT();
// 1498             blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
// 1499             size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
// 1500                                                  (MEM_POOL_BLK_QTY)blk_rem,
// 1501                                                  (CPU_SIZE_T      )blk_size,
// 1502                                                  (CPU_SIZE_T      )blk_align);
// 1503                                                                     /* ... rtn add'l seg  size needed.                  */
// 1504             if (size_tot > size_rem) {
// 1505                *poctets_reqd = size_tot - size_rem;
// 1506             } else {
// 1507                *poctets_reqd = size_tot;
// 1508             }
// 1509            *perr = LIB_MEM_ERR_SEG_EMPTY;
// 1510             return;
// 1511         }
// 1512         ppool_ptr[i] = pmem_blk;
??Mem_PoolCreate_35:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
        MOV     A,R6
        JNZ     ??Mem_PoolCreate_34
        INC     R7
??Mem_PoolCreate_34:
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JC      $+5
        LJMP    ??Mem_PoolCreate_36
        ; Setup parameters for call to function Mem_SegAlloc
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,?V4
        MOV     R5,?V5
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegAlloc
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R2,?V2
        MOV     R3,?V3
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Mem_PoolCreate_35
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x20
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x24
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R6
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R7
        MOV     R5,A
        ; Setup parameters for call to function Mem_SegCalcTotSize
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Mem_SegCalcTotSize
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R6,?V0
        MOV     R7,?V1
        CLR     C
        MOV     A,?V2
        SUBB    A,R6
        MOV     A,?V3
        SUBB    A,R7
        JNC     ??Mem_PoolCreate_37
        MOV     A,R6
        CLR     C
        SUBB    A,?V2
        MOV     R0,A
        MOV     A,R7
        SUBB    A,?V3
        MOV     R1,A
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_38
??Mem_PoolCreate_37:
        MOV     A,#0x2e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
??Mem_PoolCreate_38:
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x28
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
        LJMP    ??Mem_PoolCreate_3
// 1513     }
// 1514 
// 1515 
// 1516 /*$PAGE*/
// 1517                                                                     /* ------------- UPDATE MEM POOL TBL -------------- */
// 1518     if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
??Mem_PoolCreate_36:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        XRL     A,R0
        JNZ     ??Mem_PoolCreate_39
        MOV     A,?V7
        XRL     A,R1
??Mem_PoolCreate_39:
        JZ      $+5
        LJMP    ??Mem_PoolCreate_40
// 1519                                                                     /* Update cur  mem seg  links.                      */
// 1520         pmem_pool->SegPrevPtr = pmem_seg_prev;
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V6
        MOV     DPH,?V7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1521         pmem_pool->SegNextPtr = pmem_seg_next;
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V6
        MOV     DPH,?V7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1522 
// 1523         if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_PoolCreate_41
// 1524             pmem_seg_prev->SegNextPtr = pmem_pool;
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x8
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_42
// 1525         } else {
// 1526             Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
??Mem_PoolCreate_41:
        MOV     DPTR,#Mem_PoolTbl
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
// 1527         }
// 1528 
// 1529         if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
??Mem_PoolCreate_42:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??Mem_PoolCreate_43
// 1530             pmem_seg_next->SegPrevPtr = pmem_pool;
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x6
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
        SJMP    ??Mem_PoolCreate_43
// 1531         }
// 1532 
// 1533     } else {                                                        /* Add mem pool into mem seg.                       */
// 1534                                                                     /* Update cur  mem pool links.                      */
// 1535         pmem_pool_next         = pmem_seg->PoolNextPtr;
??Mem_PoolCreate_40:
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 1536         pmem_pool->PoolPrevPtr = pmem_seg;
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V6
        MOV     DPH,?V7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1537         pmem_pool->PoolNextPtr = pmem_pool_next;
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1538 
// 1539         pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
// 1540 
// 1541         if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
        MOV     A,R2
        ORL     A,R3
        JZ      ??Mem_PoolCreate_43
// 1542             pmem_pool_next->PoolPrevPtr = pmem_pool;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V7
        MOVX    @DPTR,A
// 1543         }
// 1544     }
// 1545 
// 1546 
// 1547 
// 1548                                                                     /* ----------------- CFG MEM POOL ----------------- */
// 1549     pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
??Mem_PoolCreate_43:
        MOV     R4,#0x4f
        MOV     R5,#0x4c
        MOV     R6,#0x50
        MOV     R7,#0x4f
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 1550     pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V6
        MOV     DPH,?V7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1551     pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1552     pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1553     pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1554     pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x16
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1555     pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
        MOV     A,?V6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        MOVX    @DPTR,A
// 1556     pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
        MOV     A,?V6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,?V4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V5
        MOVX    @DPTR,A
// 1557     pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1558     pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,?V7
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1559 
// 1560 
// 1561     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 1562 
// 1563    *perr = LIB_MEM_ERR_NONE;
        MOV     A,#0x30
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1564 }
??Mem_PoolCreate_3:
        MOV     A,#0x17
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 1565 #endif
// 1566 
// 1567 
// 1568 /*$PAGE*/
// 1569 /*
// 1570 *********************************************************************************************************
// 1571 *                                      Mem_PoolBlkGetNbrAvail()
// 1572 *
// 1573 * Description : Get memory pools remaining number of blocks available to allocate.
// 1574 *
// 1575 * Argument(s) : pmem_pool   Pointer to a memory pool structure.
// 1576 *
// 1577 *               perr        Pointer to variable that will receive the return error code from this function :
// 1578 *
// 1579 *                               LIB_MEM_ERR_NONE                Memory pool available number of blocks
// 1580 *                                                                   successfully returned.
// 1581 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
// 1582 *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
// 1583 *
// 1584 * Return(s)   : Remaining memory pool blocks (see Note #1), if NO error(s).
// 1585 *
// 1586 *               0,                                          otherwise.
// 1587 *
// 1588 * Caller(s)   : Application.
// 1589 *
// 1590 * Note(s)     : (1) (a) Mem_PoolBlkGetNbrAvail() ONLY supports non-heap memory pools.
// 1591 *                   (b) Mem_HeapGetSizeRem()/Mem_SegGetSizeRem() should be used for heap memory pool/segment.
// 1592 *
// 1593 *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 1594 *********************************************************************************************************
// 1595 */
// 1596 /*$PAGE*/
// 1597 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1598 MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
Mem_PoolBlkGetNbrAvail:
        CODE
// 1599                                           LIB_ERR   *perr)
// 1600 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 1601     MEM_POOL_BLK_QTY  nbr_blk_rem;
// 1602     CPU_SR_ALLOC();
        MOV     R1,#0x0
// 1603 
// 1604 
// 1605 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1606                                                                 /* --------------- VALIDATE RTN ERR PTR --------------- */
// 1607     if (perr == (LIB_ERR *)0) {
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_PoolBlkGetNbrAvail_0
// 1608         CPU_SW_EXCEPTION(0u);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1609     }
// 1610                                                                 /* ---------------- VALIDATE MEM POOL ----------------- */
// 1611     if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
??Mem_PoolBlkGetNbrAvail_0:
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_PoolBlkGetNbrAvail_1
// 1612        *perr =  LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1613         return (0u);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_PoolBlkGetNbrAvail_2
// 1614     }
// 1615 #endif
// 1616 
// 1617     CPU_CRITICAL_ENTER();
??Mem_PoolBlkGetNbrAvail_1:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
// 1618 
// 1619 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1620     switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
        MOV     DPTR,#__Constant_4f504c4f
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     R0,#?V0
        LCALL   ?L_EQ_X
        JNZ     ??Mem_PoolBlkGetNbrAvail_3
// 1621         case LIB_MEM_TYPE_POOL:
// 1622              break;
// 1623 
// 1624 
// 1625         case LIB_MEM_TYPE_NONE:
// 1626         case LIB_MEM_TYPE_HEAP:
// 1627         default:
// 1628              CPU_CRITICAL_EXIT();
// 1629             *perr =  LIB_MEM_ERR_INVALID_POOL;
// 1630              return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
// 1631     }
// 1632 #endif
// 1633 
// 1634                                                                 /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
// 1635     nbr_blk_rem = pmem_pool->BlkIx;
        MOV     A,?V4
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
// 1636 
// 1637     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1638 
// 1639 
// 1640    *perr =  LIB_MEM_ERR_NONE;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1641 
// 1642     return (nbr_blk_rem);
        MOV     R2,?V0
        MOV     R3,?V1
        SJMP    ??Mem_PoolBlkGetNbrAvail_2
??Mem_PoolBlkGetNbrAvail_3:
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
        MOV     R2,#0x0
        MOV     R3,#0x0
??Mem_PoolBlkGetNbrAvail_2:
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 1643 }
// 1644 #endif
// 1645 
// 1646 
// 1647 /*$PAGE*/
// 1648 /*
// 1649 *********************************************************************************************************
// 1650 *                                          Mem_PoolBlkGet()
// 1651 *
// 1652 * Description : Get a memory block from memory pool.
// 1653 *
// 1654 * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
// 1655 *
// 1656 *               size        Size of requested memory (in octets).
// 1657 *
// 1658 *               perr        Pointer to variable that will receive the return error code from this function :
// 1659 *
// 1660 *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
// 1661 *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
// 1662 *
// 1663 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
// 1664 *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
// 1665 *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
// 1666 *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
// 1667 *
// 1668 * Return(s)   : Pointer to memory block, if NO error(s).
// 1669 *
// 1670 *               Pointer to NULL,         otherwise.
// 1671 *
// 1672 * Caller(s)   : Application.
// 1673 *
// 1674 * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 1675 *********************************************************************************************************
// 1676 */
// 1677 /*$PAGE*/
// 1678 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1679 void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
Mem_PoolBlkGet:
        CODE
// 1680                        CPU_SIZE_T   size,
// 1681                        LIB_ERR     *perr)
// 1682 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1683     void  *pmem_blk;
// 1684     CPU_SR_ALLOC();
        MOV     R1,#0x0
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
// 1685 
// 1686 
// 1687 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
// 1688     if (perr == (LIB_ERR *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_PoolBlkGet_0
// 1689         CPU_SW_EXCEPTION((void *)0);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1690     }
// 1691 #endif
// 1692 
// 1693                                                                     /* ------------ VALIDATE MEM POOL GET ------------- */
// 1694 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1695     if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
??Mem_PoolBlkGet_0:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_PoolBlkGet_1
// 1696        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1697         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGet_2
// 1698     }
// 1699 
// 1700     if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
??Mem_PoolBlkGet_1:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolBlkGet_3
// 1701        *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1702         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGet_2
// 1703     }
// 1704 #endif
// 1705 
// 1706     CPU_CRITICAL_ENTER();
??Mem_PoolBlkGet_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
// 1707 
// 1708 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1709     if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        MOV     DPTR,#__Constant_4f504c4f
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0
        LCALL   ?L_EQ_X
        JZ      ??Mem_PoolBlkGet_4
// 1710         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1711        *perr = LIB_MEM_ERR_INVALID_POOL;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1712         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGet_2
// 1713     }
// 1714 
// 1715     if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
??Mem_PoolBlkGet_4:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        PUSH    DPL
        PUSH    DPH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JNC     ??Mem_PoolBlkGet_5
// 1716         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1717        *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6d
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1718         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGet_2
// 1719     }
// 1720 #endif
// 1721 
// 1722    (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
??Mem_PoolBlkGet_5:
        MOV     R2,?XSP + 0
        MOV     R3,?XSP + 1
// 1723 
// 1724     if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Mem_PoolBlkGet_6
// 1725         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1726        *perr = LIB_MEM_ERR_POOL_EMPTY;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x22
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1727         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGet_2
// 1728     }
// 1729 
// 1730     if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
??Mem_PoolBlkGet_6:
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        PUSH    DPL
        PUSH    DPH
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JNC     ??Mem_PoolBlkGet_7
// 1731         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1732        *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6b
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1733         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_PoolBlkGet_2
// 1734     }
// 1735 
// 1736                                                                     /* ------------ GET MEM BLK FROM POOL ------------- */
// 1737     pmem_pool->BlkIx--;
??Mem_PoolBlkGet_7:
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
// 1738     pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R0
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1739 
// 1740     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1741 
// 1742    *perr =  LIB_MEM_ERR_NONE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1743 
// 1744     return (pmem_blk);
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??Mem_PoolBlkGet_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 1745 }
// 1746 #endif
// 1747 
// 1748 
// 1749 /*$PAGE*/
// 1750 /*
// 1751 *********************************************************************************************************
// 1752 *                                      Mem_PoolBlkGetUsedAtIx()
// 1753 *
// 1754 * Description : Get a used memory block from memory pool, by index.
// 1755 *
// 1756 * Argument(s) : pmem_pool   Pointer to memory pool to get memory block from.
// 1757 *
// 1758 *               used_ix     Index of the used memory block to get.
// 1759 *
// 1760 *               perr        Pointer to variable that will receive the return error code from this function :
// 1761 *
// 1762 *                               LIB_MEM_ERR_NONE                    Memory block successfully returned.
// 1763 *                               LIB_MEM_ERR_POOL_FULL           All memory blocks available in memory pool.
// 1764 *
// 1765 *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
// 1766 *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
// 1767 *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
// 1768 *
// 1769 * Return(s)   : Pointer to memory block, if NO error(s).
// 1770 *
// 1771 *               Pointer to NULL,         otherwise.
// 1772 *
// 1773 * Caller(s)   : Application.
// 1774 *
// 1775 * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 1776 *
// 1777 *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
// 1778 *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
// 1779 *                   lock to avoid the index to be modified.
// 1780 *********************************************************************************************************
// 1781 */
// 1782 /*$PAGE*/
// 1783 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1784 void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
Mem_PoolBlkGetUsedAtIx:
        CODE
// 1785                                MEM_POOL_IX        used_ix,
// 1786                                LIB_ERR           *perr)
// 1787 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V6,R4
        MOV     ?V7,R5
// 1788     MEM_POOL_IX   blk_ix;
// 1789     void         *pmem_blk;
// 1790     CPU_SR_ALLOC();
        MOV     R1,#0x0
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
// 1791 
// 1792 
// 1793 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
// 1794     if (perr == (LIB_ERR *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_PoolBlkGetUsedAtIx_0
// 1795         CPU_SW_EXCEPTION((void *)0);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1796     }
// 1797 #endif
// 1798 
// 1799                                                                     /* ------------ VALIDATE MEM POOL GET ------------- */
// 1800 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1801     if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
??Mem_PoolBlkGetUsedAtIx_0:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_PoolBlkGetUsedAtIx_1
// 1802        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1803         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGetUsedAtIx_2
// 1804     }
// 1805 #endif
// 1806 
// 1807     CPU_CRITICAL_ENTER();
??Mem_PoolBlkGetUsedAtIx_1:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
// 1808 
// 1809 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1810     if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        MOV     DPTR,#__Constant_4f504c4f
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0
        LCALL   ?L_EQ_X
        JZ      ??Mem_PoolBlkGetUsedAtIx_3
// 1811         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1812        *perr = LIB_MEM_ERR_INVALID_POOL;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1813         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGetUsedAtIx_2
// 1814     }
// 1815 
// 1816     if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
??Mem_PoolBlkGetUsedAtIx_3:
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        PUSH    DPL
        PUSH    DPH
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JC      ??Mem_PoolBlkGetUsedAtIx_4
// 1817         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1818        *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6b
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1819         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_PoolBlkGetUsedAtIx_2
// 1820     }
// 1821 #endif
// 1822 
// 1823     blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
??Mem_PoolBlkGetUsedAtIx_4:
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,?V6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,?V7
        MOV     R3,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
// 1824 
// 1825     if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JC      ??Mem_PoolBlkGetUsedAtIx_5
// 1826         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1827        *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6b
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1828         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_PoolBlkGetUsedAtIx_2
// 1829     }
// 1830 
// 1831     if (blk_ix < pmem_pool->BlkIx) {
??Mem_PoolBlkGetUsedAtIx_5:
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     ??Mem_PoolBlkGetUsedAtIx_6
// 1832         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1833        *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#-0x6b
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1834         return ((void *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_PoolBlkGetUsedAtIx_2
// 1835     }
// 1836                                                                     /* ------------ GET MEM BLK FROM POOL ------------- */
// 1837     pmem_blk = pmem_pool->PoolPtrs[blk_ix];
??Mem_PoolBlkGetUsedAtIx_6:
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R0
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1838 
// 1839     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
// 1840 
// 1841    *perr =  LIB_MEM_ERR_NONE;
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1842 
// 1843     return (pmem_blk);
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??Mem_PoolBlkGetUsedAtIx_2:
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 1844 }
// 1845 #endif
// 1846 
// 1847 
// 1848 /*$PAGE*/
// 1849 /*
// 1850 *********************************************************************************************************
// 1851 *                                          Mem_PoolBlkFree()
// 1852 *
// 1853 * Description : Free a memory block to memory pool.
// 1854 *
// 1855 * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
// 1856 *
// 1857 *               pmem_blk    Pointer to memory block address to free.
// 1858 *
// 1859 *               perr        Pointer to variable that will receive the return error code from this function :
// 1860 *
// 1861 *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
// 1862 *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
// 1863 *                                                                           memory pool.
// 1864 *
// 1865 *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
// 1866 *                                                                           a NULL pointer.
// 1867 *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
// 1868 *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
// 1869 *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
// 1870 *                                                                            in memory pool.
// 1871 *
// 1872 * Return(s)   : none.
// 1873 *
// 1874 * Caller(s)   : Application.
// 1875 *
// 1876 * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 1877 *********************************************************************************************************
// 1878 */
// 1879 /*$PAGE*/
// 1880 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1881 void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
Mem_PoolBlkFree:
        CODE
// 1882                        void      *pmem_blk,
// 1883                        LIB_ERR   *perr)
// 1884 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1885     void         *p_addr;
// 1886     CPU_BOOLEAN   addr_valid;
// 1887     MEM_POOL_IX   i;
// 1888     CPU_SR_ALLOC();
        MOV     ?V4,#0x0
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V7,A
// 1889 
// 1890 
// 1891 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
// 1892     if (perr == (LIB_ERR *)0) {
        MOV     A,?V6
        ORL     A,?V7
        JNZ     ??Mem_PoolBlkFree_0
// 1893         CPU_SW_EXCEPTION(;);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 1894     }
// 1895 #endif
// 1896 
// 1897                                                                     /* ------------ VALIDATE MEM POOL FREE ------------ */
// 1898 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
// 1899     if (pmem_pool == (MEM_POOL *)0) {
??Mem_PoolBlkFree_0:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Mem_PoolBlkFree_1
// 1900        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1901         return;
        LJMP    ??Mem_PoolBlkFree_2
// 1902     }
// 1903 
// 1904     if (pmem_blk == (void *)0) {
??Mem_PoolBlkFree_1:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolBlkFree_3
// 1905        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1906         return;
        LJMP    ??Mem_PoolBlkFree_2
// 1907     }
// 1908 #endif
// 1909 
// 1910     CPU_CRITICAL_ENTER();
??Mem_PoolBlkFree_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     ?V4,A
// 1911 
// 1912 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1913     if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        MOV     DPTR,#__Constant_4f504c4f
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0
        LCALL   ?L_EQ_X
        JZ      ??Mem_PoolBlkFree_4
// 1914         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
// 1915        *perr = LIB_MEM_ERR_INVALID_POOL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1916         return;
        LJMP    ??Mem_PoolBlkFree_2
// 1917     }
// 1918 
// 1919     addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
??Mem_PoolBlkFree_4:
        ; Setup parameters for call to function Mem_PoolBlkIsValidAddr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   Mem_PoolBlkIsValidAddr
        MOV     A,R1
        MOV     R4,A
// 1920     if (addr_valid != DEF_OK) {
        MOV     A,#0x1
        XRL     A,R4
        JZ      ??Mem_PoolBlkFree_5
// 1921         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
// 1922        *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x69
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1923         return;
        LJMP    ??Mem_PoolBlkFree_2
// 1924     }
// 1925 
// 1926     for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
??Mem_PoolBlkFree_5:
        MOV     R0,#0x0
        MOV     R1,#0x0
        SJMP    ??Mem_PoolBlkFree_6
??Mem_PoolBlkFree_7:
        INC     R0
        MOV     A,R0
        JNZ     ??Mem_PoolBlkFree_6
        INC     R1
??Mem_PoolBlkFree_6:
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        JNC     ??Mem_PoolBlkFree_8
// 1927         if (pmem_blk == pmem_pool->PoolPtrs[i]) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     ?V0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,?V0
        MOV     ?V0,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,?V0
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,?V0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R4
        JNZ     ??Mem_PoolBlkFree_9
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R5
??Mem_PoolBlkFree_9:
        JNZ     ??Mem_PoolBlkFree_7
// 1928             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
// 1929            *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x68
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1930             return;
        LJMP    ??Mem_PoolBlkFree_2
// 1931         }
// 1932     }
// 1933 #endif
// 1934 
// 1935     if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
??Mem_PoolBlkFree_8:
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        PUSH    DPL
        PUSH    DPH
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JC      ??Mem_PoolBlkFree_10
// 1936         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
// 1937        *perr = LIB_MEM_ERR_POOL_FULL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x23
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1938         return;
        LJMP    ??Mem_PoolBlkFree_2
// 1939     }
// 1940 
// 1941                                                                     /* ------------- FREE MEM BLK TO POOL ------------- */
// 1942     addr_valid = DEF_NO;
??Mem_PoolBlkFree_10:
        MOV     R4,#0x0
// 1943     for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        SJMP    ??Mem_PoolBlkFree_11
??Mem_PoolBlkFree_12:
        INC     R0
        MOV     A,R0
        JNZ     ??Mem_PoolBlkFree_11
        INC     R1
??Mem_PoolBlkFree_11:
        MOV     A,R6
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        JNC     ??Mem_PoolBlkFree_13
// 1944         p_addr = pmem_pool->PoolPtrs[i];
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R5,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R5
        MOV     R5,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R5
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 1945         if (p_addr == pmem_blk) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     A,R2
        XRL     A,?V0
        JNZ     ??Mem_PoolBlkFree_14
        MOV     A,R3
        XRL     A,?V1
??Mem_PoolBlkFree_14:
        JNZ     ??Mem_PoolBlkFree_12
// 1946             addr_valid = DEF_YES;
        MOV     R4,#0x1
// 1947             break;
// 1948         }
// 1949     }
// 1950                                                                     /* Swap addr of mem blk to free in tbl.             */
// 1951     if (addr_valid == DEF_YES) {
??Mem_PoolBlkFree_13:
        MOV     A,#0x1
        XRL     A,R4
        JZ      $+5
        LJMP    ??Mem_PoolBlkFree_15
// 1952         pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R4
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R4
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1953     } else {
// 1954 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 1955         CPU_CRITICAL_EXIT();
// 1956        *perr = LIB_MEM_ERR_INVALID_POOL;
// 1957         return;
// 1958 #endif
// 1959     }
// 1960 
// 1961                                                                     /* Free mem blk.                                    */
// 1962     pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1963     pmem_pool->BlkIx++;
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1964 
// 1965     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
// 1966 
// 1967    *perr = LIB_MEM_ERR_NONE;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 1968 }
        SJMP    ??Mem_PoolBlkFree_2
??Mem_PoolBlkFree_15:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     R1,?V4
        LCALL   CPU_SR_Restore
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
??Mem_PoolBlkFree_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 1969 #endif
// 1970 
// 1971 
// 1972 /*$PAGE*/
// 1973 /*
// 1974 *********************************************************************************************************
// 1975 *                                          Mem_PoolBlkIxGet()
// 1976 *
// 1977 * Description : Get temporary index of a memory block in a memory pool.
// 1978 *
// 1979 * Argument(s) : pmem_pool   Pointer to memory pool.
// 1980 *
// 1981 *               pmem_blk    Pointer to memory block to get index for.
// 1982 *
// 1983 *               perr        Pointer to variable that will receive the return error code from this function :
// 1984 *
// 1985 *                               LIB_MEM_ERR_NONE                        Memory block successfully freed.
// 1986 *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
// 1987 *                                                                           memory pool.
// 1988 *
// 1989 *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
// 1990 *                                                                           a NULL pointer.
// 1991 *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
// 1992 *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
// 1993 *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
// 1994 *                                                                            in memory pool.
// 1995 *
// 1996 * Return(s)   : Index of the memory block.
// 1997 *
// 1998 * Caller(s)   : Application.
// 1999 *
// 2000 * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 2001 *
// 2002 *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
// 2003 *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
// 2004 *                   lock to avoid the index to be modified.
// 2005 *********************************************************************************************************
// 2006 */
// 2007 /*$PAGE*/
// 2008 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2009 MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
Mem_PoolBlkIxGet:
        CODE
// 2010                                void      *pmem_blk,
// 2011                                LIB_ERR   *perr)
// 2012 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V4,R2
        MOV     ?V5,R3
// 2013     void         *p_addr;
// 2014     CPU_BOOLEAN   addr_valid;
// 2015     MEM_POOL_IX   i;
// 2016     MEM_POOL_IX   pool_ix;
// 2017     MEM_POOL_IX   invalid_ix;
// 2018     CPU_SR_ALLOC();
        MOV     R6,#0x0
// 2019 
// 2020 
// 2021     invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x1
        MOVX    @DPTR,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V7,A
// 2022 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
// 2023     if (perr == (LIB_ERR *)0) {
        MOV     A,?V6
        ORL     A,?V7
        JNZ     ??Mem_PoolBlkIxGet_0
// 2024         CPU_SW_EXCEPTION(invalid_ix);
        ; Setup parameters for call to function CPU_SW_Exception
        LCALL   CPU_SW_Exception
// 2025     }
// 2026 #endif
// 2027 
// 2028                                                                     /* ------------ VALIDATE MEM POOL FREE ------------ */
// 2029 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
// 2030     if (pmem_pool == (MEM_POOL *)0) {
??Mem_PoolBlkIxGet_0:
        MOV     A,?V4
        ORL     A,?V5
        JNZ     ??Mem_PoolBlkIxGet_1
// 2031        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2032         return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2033     }
// 2034 
// 2035     if (pmem_blk == (void *)0) {
??Mem_PoolBlkIxGet_1:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Mem_PoolBlkIxGet_3
// 2036        *perr = LIB_MEM_ERR_NULL_PTR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2037         return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2038     }
// 2039 #endif
// 2040 
// 2041     CPU_CRITICAL_ENTER();
??Mem_PoolBlkIxGet_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
// 2042 
// 2043 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 2044     if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        MOV     DPTR,#__Constant_4f504c4f
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOV     R0,#?V0
        LCALL   ?L_EQ_X
        JZ      ??Mem_PoolBlkIxGet_4
// 2045         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2046        *perr = LIB_MEM_ERR_INVALID_POOL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2047         return(invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2048     }
// 2049 
// 2050     addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
??Mem_PoolBlkIxGet_4:
        ; Setup parameters for call to function Mem_PoolBlkIsValidAddr
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V4
        MOV     R3,?V5
        LCALL   Mem_PoolBlkIsValidAddr
        MOV     A,R1
        MOV     R4,A
// 2051     if (addr_valid != DEF_OK) {
        MOV     A,#0x1
        XRL     A,R4
        JZ      ??Mem_PoolBlkIxGet_5
// 2052         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2053        *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x69
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2054         return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2055     }
// 2056 
// 2057     for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
??Mem_PoolBlkIxGet_5:
        MOV     R0,#0x0
        MOV     R1,#0x0
        SJMP    ??Mem_PoolBlkIxGet_6
??Mem_PoolBlkIxGet_7:
        INC     R0
        MOV     A,R0
        JNZ     ??Mem_PoolBlkIxGet_6
        INC     R1
??Mem_PoolBlkIxGet_6:
        MOV     A,?V4
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        JNC     ??Mem_PoolBlkIxGet_8
// 2058         if (pmem_blk == pmem_pool->PoolPtrs[i]) {
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R7,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R7
        MOV     R7,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R7
        MOV     R3,A
        MOV     A,?V4
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R7,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R4
        JNZ     ??Mem_PoolBlkIxGet_9
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R5
??Mem_PoolBlkIxGet_9:
        JNZ     ??Mem_PoolBlkIxGet_7
// 2059             CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2060            *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x68
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2061             return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2062         }
// 2063     }
// 2064 #endif
// 2065 
// 2066     if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
??Mem_PoolBlkIxGet_8:
        MOV     A,?V4
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        PUSH    DPL
        PUSH    DPH
        MOV     A,?V4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JC      ??Mem_PoolBlkIxGet_10
// 2067         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2068        *perr = LIB_MEM_ERR_POOL_FULL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x23
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2069         return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LJMP    ??Mem_PoolBlkIxGet_2
// 2070     }
// 2071 
// 2072     addr_valid = DEF_NO;
??Mem_PoolBlkIxGet_10:
        MOV     R4,#0x0
// 2073     for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
        MOV     A,?V4
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        SJMP    ??Mem_PoolBlkIxGet_11
??Mem_PoolBlkIxGet_12:
        INC     R0
        MOV     A,R0
        JNZ     ??Mem_PoolBlkIxGet_11
        INC     R1
??Mem_PoolBlkIxGet_11:
        MOV     A,?V4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        JNC     ??Mem_PoolBlkIxGet_13
// 2074         p_addr = pmem_pool->PoolPtrs[i];
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        MOV     B,#0x2
        MUL     AB
        XCH     A,R2
        MOV     R5,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R5
        MOV     R5,A
        MOV     B,#0x2
        MOV     A,R3
        MUL     AB
        ADD     A,R5
        MOV     R3,A
        MOV     A,?V4
        ADD     A,#0x12
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 2075         if (p_addr == pmem_blk) {
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     A,R2
        XRL     A,?V0
        JNZ     ??Mem_PoolBlkIxGet_14
        MOV     A,R3
        XRL     A,?V1
??Mem_PoolBlkIxGet_14:
        JNZ     ??Mem_PoolBlkIxGet_12
// 2076             addr_valid = DEF_YES;
        MOV     R4,#0x1
// 2077             break;
// 2078         }
// 2079     }
// 2080                                                                     /* Return ix of mem blk in tbl.                     */
// 2081     if (addr_valid == DEF_YES) {
??Mem_PoolBlkIxGet_13:
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??Mem_PoolBlkIxGet_15
// 2082         pool_ix = pmem_pool->BlkNbr - 1 - i;
        MOV     A,?V4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V5
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOV     R3,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     ?V0,A
        MOV     A,R3
        SUBB    A,R1
        MOV     ?V1,A
// 2083         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2084        *perr = LIB_MEM_ERR_NONE;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2085         return (pool_ix);
        MOV     R2,?V0
        MOV     R3,?V1
        SJMP    ??Mem_PoolBlkIxGet_2
// 2086     } else {
// 2087         CPU_CRITICAL_EXIT();
??Mem_PoolBlkIxGet_15:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2088        *perr = LIB_MEM_ERR_INVALID_POOL;
        MOV     DPL,?V6
        MOV     DPH,?V7
        MOV     A,#-0x78
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x27
        MOVX    @DPTR,A
// 2089         return (invalid_ix);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
??Mem_PoolBlkIxGet_2:
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 2090     }
// 2091 
// 2092 }
// 2093 #endif
// 2094 
// 2095 
// 2096 /*$PAGE*/
// 2097 /*
// 2098 *********************************************************************************************************
// 2099 *********************************************************************************************************
// 2100 *                                           LOCAL FUNCTIONS
// 2101 *********************************************************************************************************
// 2102 *********************************************************************************************************
// 2103 */
// 2104 
// 2105 /*
// 2106 *********************************************************************************************************
// 2107 *                                      Mem_PoolBlkIsValidAddr()
// 2108 *
// 2109 * Description : Calculates if a given memory block address is valid for the memory pool.
// 2110 *
// 2111 * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
// 2112 *               ---------   Argument validated in Mem_PoolBlkFree().
// 2113 *
// 2114 *               pmem_blk    Pointer to memory block address to validate.
// 2115 *               --------    Argument validated in Mem_PoolBlkFree().
// 2116 *
// 2117 * Return(s)   : DEF_YES, if valid memory pool block address.
// 2118 *
// 2119 *               DEF_NO,  otherwise.
// 2120 *
// 2121 * Caller(s)   : Mem_PoolBlkFree().
// 2122 *
// 2123 * Note(s)     : none.
// 2124 *********************************************************************************************************
// 2125 */
// 2126 
// 2127 #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \ 
// 2128      (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2129 static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
Mem_PoolBlkIsValidAddr:
        CODE
// 2130                                              void      *pmem_blk)
// 2131 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V6,R4
        MOV     ?V7,R5
// 2132     CPU_INT08U   *ppool_addr_first;
// 2133     void         *ppool_addr_start;
// 2134     void         *ppool_addr_end;
// 2135     CPU_SIZE_T    align_offset;
// 2136     CPU_SIZE_T    blk_align;
// 2137     CPU_SIZE_T    blk_align_offset;
// 2138     CPU_SIZE_T    blk_size;
// 2139     CPU_SIZE_T    mem_align;
// 2140     CPU_SIZE_T    mem_align_offset;
// 2141     CPU_SIZE_T    mem_diff;
// 2142     CPU_BOOLEAN   addr_valid;
// 2143 
// 2144 
// 2145     ppool_addr_start = pmem_pool->PoolAddrStart;
        MOV     A,R6
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
// 2146     ppool_addr_end   = pmem_pool->PoolAddrEnd;
        MOV     A,R6
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 2147 
// 2148     if ((pmem_blk < ppool_addr_start) ||
// 2149         (pmem_blk > ppool_addr_end)) {
        CLR     C
        MOV     A,?V6
        SUBB    A,?V0
        MOV     A,?V7
        SUBB    A,?V1
        JC      ??Mem_PoolBlkIsValidAddr_0
        CLR     C
        MOV     A,R0
        SUBB    A,?V6
        MOV     A,R1
        SUBB    A,?V7
        JNC     ??Mem_PoolBlkIsValidAddr_1
// 2150         return (DEF_NO);
??Mem_PoolBlkIsValidAddr_0:
        MOV     R1,#0x0
        LJMP    ??Mem_PoolBlkIsValidAddr_2
// 2151     }
// 2152 
// 2153     blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
??Mem_PoolBlkIsValidAddr_1:
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2154     align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
        MOV     R0,?V0
        MOV     R1,?V1
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 2155     if (align_offset != 0u) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_PoolBlkIsValidAddr_3
// 2156         mem_align_offset = blk_align - align_offset;
        MOV     A,R4
        CLR     C
        SUBB    A,R0
        MOV     ?V4,A
        MOV     A,R5
        SUBB    A,R1
        MOV     ?V5,A
        SJMP    ??Mem_PoolBlkIsValidAddr_4
// 2157     } else {
// 2158         mem_align_offset = 0u;
??Mem_PoolBlkIsValidAddr_3:
        MOV     ?V4,#0x0
        MOV     ?V5,#0x0
// 2159     }
// 2160 
// 2161     blk_size     = pmem_pool->BlkSize;
??Mem_PoolBlkIsValidAddr_4:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2162     align_offset = blk_size % blk_align;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 2163     if (align_offset != 0u) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_PoolBlkIsValidAddr_5
// 2164         blk_align_offset = blk_align - align_offset;
        MOV     A,R4
        CLR     C
        SUBB    A,R0
        MOV     R2,A
        MOV     A,R5
        SUBB    A,R1
        MOV     R3,A
        SJMP    ??Mem_PoolBlkIsValidAddr_6
// 2165     } else {
// 2166         blk_align_offset = 0u;
??Mem_PoolBlkIsValidAddr_5:
        MOV     R2,#0x0
        MOV     R3,#0x0
// 2167     }
// 2168 
// 2169     ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
??Mem_PoolBlkIsValidAddr_6:
        MOV     A,?V0
        ADD     A,?V4
        MOV     R0,A
        MOV     A,?V1
        ADDC    A,?V5
        MOV     R1,A
// 2170     mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
        MOV     A,?V6
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        MOV     A,?V7
        SUBB    A,R1
        MOV     R1,A
// 2171     mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
        MOV     A,R6
        ADD     A,R2
        MOV     R2,A
        MOV     A,R7
        ADDC    A,R3
        MOV     R3,A
// 2172 
// 2173     addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
        LCALL   ?US_DIV_MOD
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Mem_PoolBlkIsValidAddr_7
        MOV     R1,#0x1
        SJMP    ??Mem_PoolBlkIsValidAddr_2
??Mem_PoolBlkIsValidAddr_7:
        MOV     R1,#0x0
// 2174 
// 2175     return (addr_valid);
??Mem_PoolBlkIsValidAddr_2:
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 2176 }
// 2177 #endif
// 2178 
// 2179 
// 2180 /*$PAGE*/
// 2181 /*
// 2182 *********************************************************************************************************
// 2183 *                                        Mem_SegCalcTotSize()
// 2184 *
// 2185 * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
// 2186 *
// 2187 *
// 2188 *                       -----                     ======================  ---
// 2189 *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
// 2190 *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
// 2191 *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
// 2192 *                         |                       |  /  /  /  /  /  /  |   v
// 2193 *                         |                       ======================  ---
// 2194 *                         |                       |                    |   ^
// 2195 *                         |                       |                    |   |
// 2196 *                         |                       |     Mem Blk #1     |   |        Blk Size
// 2197 *                         |                       |                    |   |     (see Note #1c)
// 2198 *                         |                       |                    |   v
// 2199 *                         |                       ----------------------  ---
// 2200 *                         |                       |  /  /  /  /  /  /  |   ^
// 2201 *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
// 2202 *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
// 2203 *                         |                       |  /  /  /  /  /  /  |   v
// 2204 *                         |                       ======================  ---
// 2205 *                                                 |         .          |
// 2206 *                     Total Size                  |         .          |
// 2207 *                   (see Note #2c)                |         .          |
// 2208 *                                                 ======================  ---
// 2209 *                         |                       |                    |   ^
// 2210 *                         |                       |                    |   |
// 2211 *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
// 2212 *                         |                       |                    |   |     (see Note #1c)
// 2213 *                         |                       |                    |   v
// 2214 *                         |                       ----------------------  ---
// 2215 *                         |                       |  /  /  /  /  /  /  |   ^
// 2216 *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
// 2217 *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
// 2218 *                         |                       |  /  /  /  /  /  /  |   v
// 2219 *                         |                       ======================  ---
// 2220 *                         |                       |                    |   ^
// 2221 *                         |                       |                    |   |
// 2222 *                         |                       |     Mem Blk #N     |   |        Blk Size
// 2223 *                         |                       |                    |   |     (see Note #1c)
// 2224 *                         v                       |                    |   v
// 2225 *                       -----                     ======================  ---
// 2226 *
// 2227 *               where
// 2228 *
// 2229 *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
// 2230 *
// 2231 *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
// 2232 *
// 2233 *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
// 2234 *
// 2235 *                   (d) Align               Required block memory alignment     ('blk_align')
// 2236 *
// 2237 *                   (e) Mem Align Offset    Offset required to align first memory block
// 2238 *
// 2239 *                   (f) Blk Align Offset    Offset required to align every memory block
// 2240 *
// 2241 *
// 2242 *               (2) The total size is calculated based on the following equations :
// 2243 *
// 2244 *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
// 2245 *                   (a) Mem Align Offset  =  {
// 2246 *                                            { (2) 0                          , if memory address is     aligned
// 2247 *
// 2248 *
// 2249 *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
// 2250 *                   (b) Blk Align Offset  =  {
// 2251 *                                            { (2) 0                          , if memory block   is     aligned
// 2252 *
// 2253 *
// 2254 *                   (c) Total Size        =   Mem Align Offset
// 2255 *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
// 2256 *                                         +   Blk Size
// 2257 *
// 2258 *
// 2259 * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
// 2260 *
// 2261 *               blk_nbr     Number of memory blocks to allocate.
// 2262 *               -------     Argument checked in Mem_HeapAlloc(),
// 2263 *                                               Mem_PoolCreate().
// 2264 *
// 2265 *               blk_size    Size   of memory block  to allocate.
// 2266 *               --------    Argument checked in Mem_HeapAlloc(),
// 2267 *                                               Mem_PoolCreate().
// 2268 *
// 2269 *               blk_align   Required block word-boundary memory alignment (in octets).
// 2270 *               ---------   Argument checked in Mem_HeapAlloc(),
// 2271 *                                               Mem_PoolCreate().
// 2272 *
// 2273 * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
// 2274 *
// 2275 *               0,                                                                  otherwise.
// 2276 *$PAGE*
// 2277 * Caller(s)   : Mem_HeapAlloc(),
// 2278 *               Mem_PoolCreate().
// 2279 *
// 2280 * Note(s)     : none.
// 2281 *********************************************************************************************************
// 2282 */
// 2283 
// 2284 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2285 static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
Mem_SegCalcTotSize:
        CODE
// 2286                                         MEM_POOL_BLK_QTY   blk_nbr,
// 2287                                         CPU_SIZE_T         blk_size,
// 2288                                         CPU_SIZE_T         blk_align)
// 2289 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        MOV     A,#-0xe
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0,R4
        MOV     ?V1,R5
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2290 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 2291     CPU_SIZE_T  blk_size_mem_aligned;
// 2292     CPU_SIZE_T  blk_size_aligned;
// 2293     CPU_SIZE_T  blk_size_aligned_nbr;
// 2294     CPU_SIZE_T  blk_size_tot;
// 2295 #endif
// 2296     CPU_SIZE_T  align_offset;
// 2297     CPU_SIZE_T  mem_align_offset;
// 2298     CPU_SIZE_T  blk_align_offset;
// 2299     CPU_SIZE_T  size_tot;
// 2300 
// 2301                                                                     /* Calc mem align (see Note #2a).                   */
// 2302     align_offset = (CPU_ADDR)pmem_addr % blk_align;
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 2303     if (align_offset != 0u) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_SegCalcTotSize_0
// 2304         mem_align_offset = blk_align - align_offset;
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        MOV     ?V4,A
        MOV     A,R7
        SUBB    A,R1
        MOV     ?V5,A
        SJMP    ??Mem_SegCalcTotSize_1
// 2305     } else {
// 2306         mem_align_offset = 0u;
??Mem_SegCalcTotSize_0:
        MOV     ?V4,#0x0
        MOV     ?V5,#0x0
??Mem_SegCalcTotSize_1:
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2307     }
// 2308                                                                     /* Calc blk align (see Note #2b).                   */
// 2309     align_offset = blk_size % blk_align;
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 2310     if (align_offset != 0u) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_SegCalcTotSize_2
// 2311         blk_align_offset = blk_align - align_offset;
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        MOV     R6,A
        MOV     A,R7
        SUBB    A,R1
        MOV     R7,A
        SJMP    ??Mem_SegCalcTotSize_3
// 2312     } else {
// 2313         blk_align_offset = 0u;
??Mem_SegCalcTotSize_2:
        MOV     R6,#0x0
        MOV     R7,#0x0
// 2314     }
// 2315                                                                     /* Calc tot size  (see Note #2c).                   */
// 2316     size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
??Mem_SegCalcTotSize_3:
        MOV     A,R4
        ADD     A,R6
        MOV     R0,A
        MOV     A,R5
        ADDC    A,R7
        MOV     R1,A
        MOV     A,?V0
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V1
        ADDC    A,#-0x1
        MOV     ?V3,A
        MOV     A,R0
        MOV     B,?V2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,?V3
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,?V2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V4
        ADD     A,R0
        MOV     R0,A
        MOV     A,?V5
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,R4
        MOV     R2,A
        MOV     A,R1
        ADDC    A,R5
        MOV     R3,A
// 2317 
// 2318 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
// 2319     blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
        MOV     A,?V4
        ADD     A,R4
        MOV     ?V2,A
        MOV     A,?V5
        ADDC    A,R5
        MOV     ?V3,A
// 2320     if ((blk_size_mem_aligned < mem_align_offset) ||
// 2321         (blk_size_mem_aligned < blk_size)) {
        CLR     C
        MOV     A,?V2
        SUBB    A,?V4
        MOV     A,?V3
        SUBB    A,?V5
        JC      ??Mem_SegCalcTotSize_4
        CLR     C
        MOV     A,?V2
        SUBB    A,R4
        MOV     A,?V3
        SUBB    A,R5
        JNC     ??Mem_SegCalcTotSize_5
// 2322         return (0u);
??Mem_SegCalcTotSize_4:
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Mem_SegCalcTotSize_6
// 2323     }
// 2324 
// 2325     if (blk_nbr > 1) {
??Mem_SegCalcTotSize_5:
        CLR     C
        MOV     A,?V0
        SUBB    A,#0x2
        MOV     A,?V1
        SUBB    A,#0x0
        JNC     $+5
        LJMP    ??Mem_SegCalcTotSize_6
// 2326         blk_size_aligned = blk_size + blk_align_offset;
        MOV     A,R4
        ADD     A,R6
        MOV     ?V4,A
        MOV     A,R5
        ADDC    A,R7
        MOV     ?V5,A
// 2327         if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
// 2328             (blk_size_aligned < blk_size)) {
        CLR     C
        MOV     A,?V4
        SUBB    A,R6
        MOV     A,?V5
        SUBB    A,R7
        JC      ??Mem_SegCalcTotSize_7
        CLR     C
        MOV     A,?V4
        SUBB    A,R4
        MOV     A,?V5
        SUBB    A,R5
        JNC     ??Mem_SegCalcTotSize_8
// 2329             return (0u);
??Mem_SegCalcTotSize_7:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegCalcTotSize_6
// 2330         }
// 2331 
// 2332         blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
??Mem_SegCalcTotSize_8:
        MOV     R0,?V4
        MOV     R1,?V5
        MOV     A,?V0
        ADD     A,#-0x1
        MOV     ?V0,A
        MOV     A,?V1
        ADDC    A,#-0x1
        MOV     ?V1,A
        MOV     A,R0
        MOV     B,?V0
        MUL     AB
        XCH     A,R0
        MOV     ?V6,B
        MOV     B,?V1
        MUL     AB
        ADD     A,?V6
        MOV     ?V6,A
        MOV     B,?V0
        MOV     A,R1
        MUL     AB
        ADD     A,?V6
        MOV     R1,A
// 2333         if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
// 2334             (blk_size_aligned_nbr < blk_align_offset) ||
// 2335             (blk_size_aligned_nbr < blk_size)) {
        CLR     C
        MOV     A,R0
        SUBB    A,?V4
        MOV     A,R1
        SUBB    A,?V5
        JC      ??Mem_SegCalcTotSize_9
        CLR     C
        MOV     A,R0
        SUBB    A,R6
        MOV     A,R1
        SUBB    A,R7
        JC      ??Mem_SegCalcTotSize_9
        CLR     C
        MOV     A,R0
        SUBB    A,R4
        MOV     A,R1
        SUBB    A,R5
        JNC     ??Mem_SegCalcTotSize_10
// 2336             return (0u);
??Mem_SegCalcTotSize_9:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegCalcTotSize_6
// 2337         }
// 2338 
// 2339         blk_size_tot = blk_size_aligned_nbr + blk_size;
??Mem_SegCalcTotSize_10:
        MOV     A,R0
        ADD     A,R4
        MOV     R6,A
        MOV     A,R1
        ADDC    A,R5
        MOV     R7,A
// 2340         if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
// 2341             (blk_size_tot < blk_size)) {
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JC      ??Mem_SegCalcTotSize_11
        CLR     C
        MOV     A,R6
        SUBB    A,R4
        MOV     A,R7
        SUBB    A,R5
        JNC     ??Mem_SegCalcTotSize_12
// 2342             return (0u);
??Mem_SegCalcTotSize_11:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegCalcTotSize_6
// 2343         }
// 2344 
// 2345         if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
// 2346             (size_tot < blk_size_aligned_nbr) ||
// 2347             (size_tot < blk_size_tot)) {
??Mem_SegCalcTotSize_12:
        CLR     C
        MOV     A,R2
        SUBB    A,?V2
        MOV     A,R3
        SUBB    A,?V3
        JC      ??Mem_SegCalcTotSize_13
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        JC      ??Mem_SegCalcTotSize_13
        CLR     C
        MOV     A,R2
        SUBB    A,R6
        MOV     A,R3
        SUBB    A,R7
        JNC     ??Mem_SegCalcTotSize_6
// 2348             return (0u);
??Mem_SegCalcTotSize_13:
        MOV     R2,#0x0
        MOV     R3,#0x0
// 2349         }
// 2350     }
// 2351 #endif
// 2352 
// 2353     return (size_tot);
??Mem_SegCalcTotSize_6:
        MOV     R7,#0x7
        LJMP    ?FUNC_LEAVE_XDATA
// 2354 }
// 2355 #endif
// 2356 
// 2357 
// 2358 /*$PAGE*/
// 2359 /*
// 2360 *********************************************************************************************************
// 2361 *                                           Mem_SegAlloc()
// 2362 *
// 2363 * Description : Allocates memory from specific segment.
// 2364 *
// 2365 * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
// 2366 *               ---------   Argument validated in Mem_HeapAlloc(),
// 2367 *                                                 Mem_PoolCreate().
// 2368 *
// 2369 *               size        Size of memory to allocate.
// 2370 *               ----        Argument validated in Mem_HeapAlloc(),
// 2371 *                                                 Mem_PoolCreate().
// 2372 *
// 2373 *               align       Required starting word-boundary memory alignment (in octets).
// 2374 *               -----       Argument validated in Mem_HeapAlloc(),
// 2375 *                                                 Mem_PoolCreate().
// 2376 *
// 2377 * Return(s)   : Pointer to allocated memory, if NO error(s).
// 2378 *
// 2379 *               Pointer to NULL,             otherwise.
// 2380 *
// 2381 * Caller(s)   : Mem_HeapAlloc(),
// 2382 *               Mem_PoolCreate().
// 2383 *
// 2384 * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
// 2385 *
// 2386 *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
// 2387 *
// 2388 *                   (a) However, this function is already called within critical sections.
// 2389 *********************************************************************************************************
// 2390 */
// 2391 
// 2392 #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2393 static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
Mem_SegAlloc:
        CODE
// 2394                              CPU_SIZE_T   size,
// 2395                              CPU_SIZE_T   align)
// 2396 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0,R4
        MOV     ?V1,R5
// 2397     CPU_INT08U  *pmem_addr;
// 2398     CPU_INT08U  *pmem_addr_next;
// 2399     CPU_SIZE_T   mem_align;
// 2400     CPU_SIZE_T   align_offset;
// 2401     CPU_SIZE_T   size_tot;
// 2402 
// 2403 
// 2404     pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
        MOV     A,R6
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
// 2405 
// 2406     mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        MOV     R2,?V4
        MOV     R3,?V5
        LCALL   ?US_DIV_MOD
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 2407 
// 2408     if (mem_align != 0u) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??Mem_SegAlloc_0
// 2409         align_offset = align - mem_align;
        MOV     A,?V4
        CLR     C
        SUBB    A,R0
        MOV     ?V2,A
        MOV     A,?V5
        SUBB    A,R1
        MOV     ?V3,A
        SJMP    ??Mem_SegAlloc_1
// 2410     } else {
// 2411         align_offset = 0u;
??Mem_SegAlloc_0:
        MOV     ?V2,#0x0
        MOV     ?V3,#0x0
// 2412     }
// 2413 
// 2414     size_tot = align_offset + size;
??Mem_SegAlloc_1:
        MOV     A,?V2
        ADD     A,?V0
        MOV     R0,A
        MOV     A,?V3
        ADDC    A,?V1
        MOV     R1,A
// 2415     if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JNC     ??Mem_SegAlloc_2
// 2416         return ((void *)0);                                         /* ... rtn NULL.                                    */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegAlloc_3
// 2417     }
// 2418 
// 2419 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 2420     if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
// 2421         (size_tot < size)) {
??Mem_SegAlloc_2:
        CLR     C
        MOV     A,R0
        SUBB    A,?V2
        MOV     A,R1
        SUBB    A,?V3
        JC      ??Mem_SegAlloc_4
        CLR     C
        MOV     A,R0
        SUBB    A,?V0
        MOV     A,R1
        SUBB    A,?V1
        JNC     ??Mem_SegAlloc_5
// 2422         return ((void *)0);                                         /* ... rtn NULL.                                    */
??Mem_SegAlloc_4:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegAlloc_3
// 2423     }
// 2424 #endif
// 2425 
// 2426     pmem_addr_next = pmem_addr + size_tot;
??Mem_SegAlloc_5:
        MOV     A,R4
        ADD     A,R0
        MOV     R2,A
        MOV     A,R5
        ADDC    A,R1
        MOV     R3,A
// 2427 
// 2428 #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
// 2429     if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     ??Mem_SegAlloc_6
// 2430         return ((void *)0);                                         /* ... rtn NULL.                                    */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Mem_SegAlloc_3
// 2431     }
// 2432 #endif
// 2433 
// 2434     pmem_addr += align_offset;                                      /* Align mem addr.                                  */
??Mem_SegAlloc_6:
        MOV     A,R4
        ADD     A,?V2
        MOV     R4,A
        MOV     A,R5
        ADDC    A,?V3
        MOV     R5,A
// 2435 
// 2436     pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
        MOV     A,R6
        ADD     A,#0x20
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2437     pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOVX    @DPTR,A
// 2438 
// 2439     return ((void *)pmem_addr);
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
??Mem_SegAlloc_3:
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 2440 }

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_4f504c4f:
        DS 4
        REQUIRE `?<Initializer for __Constant_4f504c4f>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_4f504c4f>`:
        DATA32
        DD 1330662479

        END
// 2441 #endif
// 2442 
// 
//  9 238 bytes in segment NEAR_CODE
//      4 bytes in segment XDATA_I
//      4 bytes in segment XDATA_ID
// 27 688 bytes in segment XDATA_Z
// 
//  9 238 bytes of CODE  memory (+ 4 bytes shared)
// 27 688 bytes of XDATA memory (+ 4 bytes shared)
//
//Errors: none
//Warnings: none
