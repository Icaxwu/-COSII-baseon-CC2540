///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.20.1.2476 for 8051               09/Apr/2017  15:54:02
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  near
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_str.c
//    Command line       =  
//        "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_str.c" -lB
//        "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\" -o "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI
//        CC2540\APP\IAR Project\Debug\Obj\" -e --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --debug --core=plain
//        --dptr=16,1 --data_model=large --code_model=near
//        --calling_convention=xdata_reentrant --place_constants=data
//        --nr_virtual_regs 8 -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Source\" -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Ports\51-CC2540\Generic\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\51-CC2540\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\BSP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\" -Ol
//    List file          =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\lib_str.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME lib_str

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?L_ADD
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?L_MUL
        EXTERN ?L_NEG
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?SL_GE_X
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_GE_X
        EXTERN ?UL_GT
        EXTERN ?UL_GT_X
        EXTERN ?XLOAD_R4567
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP100_8
        EXTERN __INIT_XDATA_I

        PUBLIC Str_Cat
        PUBLIC Str_Cat_N
        PUBLIC Str_Char
        PUBLIC Str_Char_Last
        PUBLIC Str_Char_Last_N
        PUBLIC Str_Char_N
        PUBLIC Str_Char_Replace
        PUBLIC Str_Char_Replace_N
        PUBLIC Str_Cmp
        PUBLIC Str_CmpIgnoreCase
        PUBLIC Str_CmpIgnoreCase_N
        PUBLIC Str_Cmp_N
        PUBLIC Str_Copy
        PUBLIC Str_Copy_N
        PUBLIC Str_FmtNbr_Int32S
        PUBLIC Str_FmtNbr_Int32U
        PUBLIC Str_Len
        PUBLIC Str_Len_N
        PUBLIC Str_ParseNbr_Int32S
        PUBLIC Str_ParseNbr_Int32U
        PUBLIC Str_Str
        PUBLIC Str_Str_N
        PUBWEAK __Constant_0
        PUBWEAK __Constant_80000000

        EXTERN ASCII_IsAlphaNum
        EXTERN ASCII_IsDig
        EXTERN ASCII_IsDigHex
        EXTERN ASCII_IsLower
        EXTERN ASCII_IsPrint
        EXTERN ASCII_IsSpace
        EXTERN ASCII_ToLower

// H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\lib_str.c
//    1 /*
//    2 *********************************************************************************************************
//    3 *                                                uC/LIB
//    4 *                                        CUSTOM LIBRARY MODULES
//    5 *
//    6 *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
//    7 *
//    8 *               All rights reserved.  Protected by international copyright laws.
//    9 *
//   10 *               uC/LIB is provided in source form to registered licensees ONLY.  It is 
//   11 *               illegal to distribute this source code to any third party unless you receive 
//   12 *               written permission by an authorized Micrium representative.  Knowledge of 
//   13 *               the source code may NOT be used to develop a similar product.
//   14 *
//   15 *               Please help us continue to provide the Embedded community with the finest 
//   16 *               software available.  Your honesty is greatly appreciated.
//   17 *
//   18 *               You can contact us at www.micrium.com.
//   19 *********************************************************************************************************
//   20 */
//   21 
//   22 /*
//   23 *********************************************************************************************************
//   24 *
//   25 *                                       ASCII STRING MANAGEMENT
//   26 *
//   27 * Filename      : lib_str.c
//   28 * Version       : V1.37.01
//   29 * Programmer(s) : ITJ
//   30 *                 BAN
//   31 *                 JDH
//   32 *********************************************************************************************************
//   33 * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
//   34 *
//   35 *                     (a) ALL standard library functions are implemented in the custom library modules :
//   36 *
//   37 *                         (1) \<Custom Library Directory>\lib_*.*
//   38 *
//   39 *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
//   40 *
//   41 *                               where
//   42 *                                       <Custom Library Directory>      directory path for custom library software
//   43 *                                       <cpu>                           directory name for specific processor (CPU)
//   44 *                                       <compiler>                      directory name for specific compiler
//   45 *
//   46 *                     (b) Product-specific library functions are implemented in individual products.
//   47 *
//   48 *********************************************************************************************************
//   49 * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
//   50 *                     us permission to reprint portions of their documentation.  Portions of this text are
//   51 *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
//   52 *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
//   53 *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
//   54 *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
//   55 *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
//   56 *                     the original IEEE and The Open Group Standard is the referee document.  The original
//   57 *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
//   58 *********************************************************************************************************
//   59 */
//   60 
//   61 
//   62 /*
//   63 *********************************************************************************************************
//   64 *                                            INCLUDE FILES
//   65 *********************************************************************************************************
//   66 */
//   67 
//   68 #define    MICRIUM_SOURCE
//   69 #define    LIB_STR_MODULE
//   70 #include  <lib_str.h>
//   71 
//   72 
//   73 /*$PAGE*/
//   74 /*
//   75 *********************************************************************************************************
//   76 *                                            LOCAL DEFINES
//   77 *********************************************************************************************************
//   78 */
//   79 
//   80 
//   81 /*
//   82 *********************************************************************************************************
//   83 *                                           LOCAL CONSTANTS
//   84 *********************************************************************************************************
//   85 */
//   86 
//   87 
//   88 /*
//   89 *********************************************************************************************************
//   90 *                                          LOCAL DATA TYPES
//   91 *********************************************************************************************************
//   92 */
//   93 
//   94 
//   95 /*
//   96 *********************************************************************************************************
//   97 *                                            LOCAL TABLES
//   98 *********************************************************************************************************
//   99 */
//  100 

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
//  101 static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
Str_MultOvfThTbl_Int32U:
        DS 148
        REQUIRE `?<Initializer for Str_MultOvfThTbl_Int32U>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_0:
        DS 4
        REQUIRE `?<Initializer for __Constant_0>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_80000000:
        DS 4
        REQUIRE `?<Initializer for __Constant_80000000>`
        REQUIRE __INIT_XDATA_I
//  102    (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
//  103    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
//  104    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
//  105    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
//  106    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
//  107    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
//  108    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
//  109    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
//  110    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
//  111    (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
//  112    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
//  113    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
//  114    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
//  115    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
//  116    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
//  117    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
//  118    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
//  119    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
//  120    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
//  121    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
//  122    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
//  123    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
//  124    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
//  125    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
//  126    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
//  127    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
//  128    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
//  129    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
//  130    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
//  131    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
//  132    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
//  133    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
//  134    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
//  135    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
//  136    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
//  137    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
//  138    (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
//  139 };
//  140 
//  141 
//  142 /*
//  143 *********************************************************************************************************
//  144 *                                       LOCAL GLOBAL VARIABLES
//  145 *********************************************************************************************************
//  146 */
//  147 
//  148 
//  149 /*$PAGE*/
//  150 /*
//  151 *********************************************************************************************************
//  152 *                                      LOCAL FUNCTION PROTOTYPES
//  153 *********************************************************************************************************
//  154 */
//  155 
//  156 static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
//  157                                                CPU_INT08U     nbr_dig,
//  158                                                CPU_INT08U     nbr_base,
//  159                                                CPU_BOOLEAN    nbr_neg,
//  160                                                CPU_CHAR       lead_char,
//  161                                                CPU_BOOLEAN    lower_case,
//  162                                                CPU_BOOLEAN    nul,
//  163                                                CPU_CHAR      *pstr);
//  164 
//  165 static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
//  166                                                CPU_CHAR     **pstr_next,
//  167                                                CPU_INT08U     nbr_base,
//  168                                                CPU_BOOLEAN    nbr_signed,
//  169                                                CPU_BOOLEAN   *pnbr_neg);
//  170 
//  171 
//  172 /*
//  173 *********************************************************************************************************
//  174 *                                     LOCAL CONFIGURATION ERRORS
//  175 *********************************************************************************************************
//  176 */
//  177 
//  178 
//  179 /*$PAGE*/
//  180 /*
//  181 *********************************************************************************************************
//  182 *                                              Str_Len()
//  183 *
//  184 * Description : Calculate length of a string.
//  185 *
//  186 * Argument(s) : pstr        Pointer to string (see Note #1).
//  187 *
//  188 * Return(s)   : Length of string; number of characters in string before terminating NULL character 
//  189 *                   (see Note #2b1).
//  190 *
//  191 * Caller(s)   : Application.
//  192 *
//  193 * Note(s)     : (1) String buffer NOT modified.
//  194 *
//  195 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
//  196 *
//  197 *                       (1) "The strlen() function shall compute the number of bytes in the string to 
//  198 *                            which 's' ('pstr') points," ...
//  199 *                       (2) "not including the terminating null byte."
//  200 *
//  201 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
//  202 *
//  203 *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
//  204 *                       (2) "no return value shall be reserved to indicate an error."
//  205 *
//  206 *               (3) String length calculation terminates when :
//  207 *
//  208 *                   (a) String pointer points to NULL.
//  209 *                       (1) String buffer overlaps with NULL address.
//  210 *                       (2) String length calculated for string up to but NOT beyond or including
//  211 *                           the NULL address.
//  212 *
//  213 *                   (b) Terminating NULL character found.
//  214 *                       (1) String length calculated for string up to but NOT           including
//  215 *                           the NULL character (see Note #2a2).
//  216 *********************************************************************************************************
//  217 */
//  218 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  219 CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
Str_Len:
        CODE
//  220 {
        REQUIRE ?V0
        REQUIRE ?V1
        PUSH    ?V0
        PUSH    ?V1
        ; Saved register size: 2
        ; Auto size: 0
//  221     CPU_SIZE_T  len;
//  222 
//  223 
//  224     len = Str_Len_N(pstr,
//  225                     DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Len_N
        MOV     R4,#-0x1
        MOV     R5,#-0x1
        LCALL   Str_Len_N
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
//  226 
//  227     return (len);
        POP     ?V1
        POP     ?V0
        RET
//  228 }
//  229 
//  230 
//  231 /*$PAGE*/
//  232 /*
//  233 *********************************************************************************************************
//  234 *                                             Str_Len_N()
//  235 *
//  236 * Description : Calculate length of a string, up to a maximum number of characters.
//  237 *
//  238 * Argument(s) : pstr        Pointer to string (see Note #1).
//  239 *
//  240 *               len_max     Maximum number of characters to search (see Note #3c).
//  241 *
//  242 * Return(s)   : Length of string; number of characters in string before terminating NULL character, 
//  243 *                   if terminating NULL character     found (see Note #2b1).
//  244 *
//  245 *               Requested maximum number of characters to search, 
//  246 *                   if terminating NULL character NOT found (see Note #3c).
//  247 *
//  248 * Caller(s)   : Application.
//  249 *
//  250 * Note(s)     : (1) String buffer NOT modified.
//  251 *
//  252 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
//  253 *
//  254 *                       (1) "The strlen() function shall compute the number of bytes in the string to 
//  255 *                            which 's' ('pstr') points," ...
//  256 *                       (2) "not including the terminating null byte."
//  257 *
//  258 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
//  259 *
//  260 *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
//  261 *                       (2) "no return value shall be reserved to indicate an error."
//  262 *
//  263 *               (3) String length calculation terminates when :
//  264 *
//  265 *                   (a) String pointer points to NULL.
//  266 *                       (1) String buffer overlaps with NULL address.
//  267 *                       (2) String length calculated for string up to but NOT beyond or including
//  268 *                           the NULL address.
//  269 *
//  270 *                   (b) Terminating NULL character found.
//  271 *                       (1) String length calculated for string up to but NOT           including
//  272 *                           the NULL character (see Note #2a2).
//  273 *
//  274 *                   (c) 'len_max' number of characters searched.
//  275 *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
//  276 *********************************************************************************************************
//  277 */
//  278 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  279 CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
Str_Len_N:
        CODE
//  280                               CPU_SIZE_T   len_max)
//  281 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
//  282     const  CPU_CHAR    *pstr_len;
//  283            CPU_SIZE_T   len;
//  284 
//  285 
//  286     pstr_len = pstr;
        MOV     DPL,R2
        MOV     DPH,R3
//  287     len      = 0u;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Len_N_0
//  288     while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
//  289            (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
//  290            ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
//  291         pstr_len++;
??Str_Len_N_1:
        INC     DPTR
//  292         len++;
        INC     R2
        MOV     A,R2
        JNZ     ??Str_Len_N_0
        INC     R3
//  293     }
??Str_Len_N_0:
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??Str_Len_N_2
        MOVX    A,@DPTR
        JZ      ??Str_Len_N_2
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JC      ??Str_Len_N_1
//  294 
//  295     return (len);                                               /* Rtn str len (see Note #3b1).                         */
??Str_Len_N_2:
        POP     DPH
        POP     DPL
        RET
//  296 }
//  297 
//  298 
//  299 /*$PAGE*/
//  300 /*
//  301 *********************************************************************************************************
//  302 *                                             Str_Copy()
//  303 *
//  304 * Description : Copy source string to destination string buffer.
//  305 *
//  306 * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
//  307 *
//  308 *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
//  309 *
//  310 * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
//  311 *
//  312 *               Pointer to NULL,               otherwise      (see Note #2b2A).
//  313 *
//  314 * Caller(s)   : Application.
//  315 *
//  316 * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
//  317 *
//  318 *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
//  319 *                           string size including the terminating NULL character.
//  320 *
//  321 *                   (b) Source buffer NOT modified.
//  322 *
//  323 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
//  324 *
//  325 *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src') 
//  326 *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
//  327 *                       (2) "(including the terminating null byte)."
//  328 *
//  329 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
//  330 *
//  331 *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
//  332 *                       (2) "no return value is reserved to indicate an error."
//  333 *                           (A) #### This requirement is intentionally NOT implemented in order to return 
//  334 *                               NULL for any error(s).
//  335 *
//  336 *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
//  337 *                       copying takes place between objects that overlap, the behavior is undefined".
//  338 *
//  339 *               (3) String copy terminates when :
//  340 *
//  341 *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
//  342 *                       (1) No string copy performed; NULL pointer returned.
//  343 *
//  344 *                   (b) Destination/Source string pointer(s) point to NULL.
//  345 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
//  346 *
//  347 *                   (c) Source string's terminating NULL character found.
//  348 *                       (1) Entire source string copied into destination string buffer (see Note #2a).
//  349 *********************************************************************************************************
//  350 */
//  351 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  352 CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
Str_Copy:
        CODE
//  353                      const  CPU_CHAR  *pstr_src)
//  354 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  355     CPU_CHAR  *pstr_rtn;
//  356 
//  357 
//  358     pstr_rtn = Str_Copy_N(pstr_dest,
//  359                           pstr_src,
//  360                           DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Copy_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Str_Copy_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
//  361 
//  362     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  363 }
//  364 
//  365 
//  366 /*$PAGE*/
//  367 /*
//  368 *********************************************************************************************************
//  369 *                                            Str_Copy_N()
//  370 *
//  371 * Description : Copy source string to destination string buffer, up to a maximum number of characters.
//  372 *
//  373 * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
//  374 *
//  375 *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
//  376 *
//  377 *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
//  378 *
//  379 * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
//  380 *
//  381 *               Pointer to NULL,               otherwise      (see Note #2b2A).
//  382 *
//  383 * Caller(s)   : Application.
//  384 *
//  385 * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
//  386 *
//  387 *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
//  388 *                           string size including the terminating NULL character.
//  389 *
//  390 *                   (b) Source string buffer NOT modified.
//  391 *
//  392 *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
//  393 *
//  394 *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2' 
//  395 *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
//  396 *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
//  397 *                           (C)  &   "(bytes that follow a null byte are not copied)".
//  398 *
//  399 *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that 
//  400 *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter 
//  401 *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in 
//  402 *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes 
//  403 *                               in all are written."
//  404 *
//  405 *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy 
//  406 *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters, 
//  407 *                                   this requirement is intentionally NOT implemented to avoid appending 
//  408 *                                   a potentially large number of unnecessary terminating NULL characters.
//  409 *
//  410 *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also  
//  411 *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of 
//  412 *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
//  413 *
//  414 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
//  415 *
//  416 *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
//  417 *                       (2) "no return value is reserved to indicate an error."
//  418 *                           (A) #### This requirement is intentionally ignored in order to return NULL 
//  419 *                               for any error(s).
//  420 *
//  421 *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
//  422 *                       copying takes place between objects that overlap, the behavior is undefined".
//  423 *
//  424 *               (3) String copy terminates when :
//  425 *
//  426 *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
//  427 *                       (1) No string copy performed; NULL pointer returned.
//  428 *
//  429 *                   (b) Destination/Source string pointer(s) point to NULL.
//  430 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
//  431 *
//  432 *                   (c) Source string's terminating NULL character found.
//  433 *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
//  434 *
//  435 *                   (d) 'len_max' number of characters copied.
//  436 *                       (1) 'len_max' number of characters MAY include the terminating NULL character 
//  437 *                           (see Note #2a1C).
//  438 *                       (2) Null copies allowed (i.e. zero-length copies).
//  439 *                           (A) No string copy performed; destination string returned  (see Note #2b1).
//  440 *********************************************************************************************************
//  441 */
//  442 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  443 CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
Str_Copy_N:
        CODE
//  444                        const  CPU_CHAR    *pstr_src,
//  445                               CPU_SIZE_T   len_max)
//  446 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xa
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 10
        ; Auto size: 0
//  447            CPU_CHAR    *pstr_copy_dest;
//  448     const  CPU_CHAR    *pstr_copy_src;
//  449            CPU_SIZE_T   len_copy;
//  450 
//  451                                                                 /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
//  452     if (pstr_dest == (CPU_CHAR *)0) {
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Copy_N_0
//  453         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Copy_N_1
//  454     }
//  455     if (pstr_src  == (const CPU_CHAR *)0) {
??Str_Copy_N_0:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Copy_N_2
//  456         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Copy_N_1
//  457     }
//  458 
//  459 
//  460     pstr_copy_dest = pstr_dest;
??Str_Copy_N_2:
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
//  461     pstr_copy_src  = pstr_src;
//  462     len_copy       = 0u;
        MOV     R6,#0x0
        MOV     R7,#0x0
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        SJMP    ??Str_Copy_N_3
//  463 
//  464     while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
//  465            ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
//  466            (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
//  467            ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
//  468        *pstr_copy_dest = *pstr_copy_src;
??Str_Copy_N_4:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        MOVX    @DPTR,A
//  469         pstr_copy_dest++;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  470         pstr_copy_src++;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  471         len_copy++;
        INC     R6
        MOV     A,R6
        JNZ     ??Str_Copy_N_3
        INC     R7
//  472     }
??Str_Copy_N_3:
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Copy_N_5
        MOV     A,R4
        ORL     A,R5
        JZ      ??Str_Copy_N_5
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        JZ      ??Str_Copy_N_5
        CLR     C
        MOV     A,R6
        SUBB    A,?V0
        MOV     A,R7
        SUBB    A,?V1
        JC      ??Str_Copy_N_4
//  473                                                                 /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
//  474     if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
//  475         (pstr_copy_src  == (const CPU_CHAR *)0)) {
??Str_Copy_N_5:
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Copy_N_6
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Copy_N_7
//  476          return ((CPU_CHAR *)0);
??Str_Copy_N_6:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Copy_N_1
//  477     }
//  478 
//  479     if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
??Str_Copy_N_7:
        CLR     C
        MOV     A,R6
        SUBB    A,?V0
        MOV     A,R7
        SUBB    A,?V1
        JNC     ??Str_Copy_N_1
//  480        *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,#0x0
        MOVX    @DPTR,A
//  481     }
//  482 
//  483 
//  484     return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
??Str_Copy_N_1:
        MOV     R7,#0x3
        LJMP    ?FUNC_LEAVE_XDATA
//  485 }
//  486 
//  487 
//  488 /*$PAGE*/
//  489 /*
//  490 *********************************************************************************************************
//  491 *                                              Str_Cat()
//  492 *
//  493 * Description : Append concatenation string to destination string.
//  494 *
//  495 * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
//  496 *
//  497 *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
//  498 *
//  499 * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
//  500 *
//  501 *               Pointer to NULL,               otherwise      (see Note #2b2A).
//  502 *
//  503 * Caller(s)   : Application.
//  504 *
//  505 * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
//  506 *
//  507 *                       (1) Destination buffer size MUST be large enough to accommodate the entire 
//  508 *                           concatenated string size including the terminating NULL character.
//  509 *
//  510 *                   (b) Concatenation string buffer NOT modified.
//  511 *
//  512 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
//  513 *
//  514 *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2' 
//  515 *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
//  516 *
//  517 *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
//  518 *                                end of 's1' ('pstr_dest')."
//  519 *                           (B)  A "terminating null byte" is appended at the end of the concatenated 
//  520 *                                destination strings.
//  521 *
//  522 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
//  523 *
//  524 *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
//  525 *                       (2) "no return value shall be reserved to indicate an error."
//  526 *                           (A) #### This requirement is intentionally NOT implemented in order to return 
//  527 *                               NULL for any error(s).
//  528 *
//  529 *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
//  530 *                       copying takes place between objects that overlap, the behavior is undefined."
//  531 *
//  532 *               (3) String concatenation terminates when :
//  533 *
//  534 *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
//  535 *                       (1) No string concatenation performed; NULL pointer returned.
//  536 *
//  537 *                   (b) Destination/Concatenation string pointer(s) point to NULL.
//  538 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
//  539 *
//  540 *                   (c) Concatenation string's terminating NULL character found.
//  541 *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
//  542 *********************************************************************************************************
//  543 */
//  544 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  545 CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
Str_Cat:
        CODE
//  546                     const  CPU_CHAR  *pstr_cat)
//  547 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  548     CPU_CHAR  *pstr_rtn;
//  549 
//  550 
//  551     pstr_rtn = Str_Cat_N(pstr_dest,
//  552                          pstr_cat,
//  553                          DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Cat_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Str_Cat_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
//  554 
//  555     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  556 }
//  557 
//  558 
//  559 /*$PAGE*/
//  560 /*
//  561 *********************************************************************************************************
//  562 *                                             Str_Cat_N()
//  563 *
//  564 * Description : Append concatenation string to destination string, up to a maximum number of characters.
//  565 *
//  566 * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
//  567 *
//  568 *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
//  569 *
//  570 *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
//  571 *
//  572 * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
//  573 *
//  574 *               Pointer to NULL,               otherwise      (see Note #2b2A).
//  575 *
//  576 * Caller(s)   : Application.
//  577 *
//  578 * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
//  579 *
//  580 *                       (1) Destination buffer size MUST be large enough to accommodate the entire 
//  581 *                           concatenated string size including the terminating NULL character.
//  582 *
//  583 *                   (b) Concatenation string buffer NOT modified.
//  584 *
//  585 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
//  586 *
//  587 *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2' 
//  588 *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
//  589 *                           (B)  but "not more than 'n' ('len_max') bytes".
//  590 *
//  591 *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the 
//  592 *                                end of 's1' ('pstr_dest')."
//  593 *                           (B) "(a null byte and bytes that follow it are not appended)."
//  594 *                           (C) "A terminating null byte is always appended to the result."
//  595 *
//  596 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
//  597 *
//  598 *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
//  599 *                       (2) "no return value shall be reserved to indicate an error."
//  600 *                           (A) #### This requirement is intentionally NOT implemented in order to return 
//  601 *                               NULL for any error(s).
//  602 *
//  603 *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
//  604 *                       copying takes place between objects that overlap, the behavior is undefined."
//  605 *
//  606 *               (3) String concatenation terminates when :
//  607 *
//  608 *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
//  609 *                       (1) No string concatenation performed; NULL pointer returned.
//  610 *
//  611 *                   (b) Destination/Concatenation string pointer(s) point to NULL.
//  612 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
//  613 *
//  614 *                   (c) Concatenation string's terminating NULL character found.
//  615 *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
//  616 *
//  617 *                   (d) 'len_max' number of characters concatenated.
//  618 *
//  619 *                       (1) 'len_max' number of characters does NOT include the terminating NULL character 
//  620 *                           (see Note #2a2).
//  621 *
//  622 *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
//  623 *                           (A) No string concatenation performed; destination string returned 
//  624 *                               (see Note #2b1).
//  625 *********************************************************************************************************
//  626 */
//  627 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  628 CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
Str_Cat_N:
        CODE
//  629                       const  CPU_CHAR    *pstr_cat,
//  630                              CPU_SIZE_T   len_max)
//  631 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xa
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 10
        ; Auto size: 0
//  632            CPU_CHAR    *pstr_cat_dest;
//  633     const  CPU_CHAR    *pstr_cat_src;
//  634            CPU_SIZE_T   len_cat;
//  635 
//  636                                                                 /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
//  637     if (pstr_dest == (CPU_CHAR *)0) {
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Cat_N_0
//  638         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Cat_N_1
//  639     }
//  640     if (pstr_cat  == (const CPU_CHAR *)0) {
??Str_Cat_N_0:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Cat_N_2
//  641         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Cat_N_1
//  642     }
??Str_Cat_N_2:
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  643 
//  644     if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
        MOV     A,R6
        ORL     A,R7
        JNZ     $+5
        LJMP    ??Str_Cat_N_1
//  645         return ((CPU_CHAR *)pstr_dest);
//  646     }
//  647 
//  648 
//  649     pstr_cat_dest = pstr_dest;
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        SJMP    ??Str_Cat_N_3
//  650     while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
//  651            (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
//  652         pstr_cat_dest++;
??Str_Cat_N_4:
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  653     }
??Str_Cat_N_3:
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Cat_N_5
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        JNZ     ??Str_Cat_N_4
//  654     if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
??Str_Cat_N_5:
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Cat_N_6
//  655         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Cat_N_1
//  656     }
//  657 
//  658     pstr_cat_src = pstr_cat;
//  659     len_cat      = 0u;
??Str_Cat_N_6:
        MOV     ?V0,#0x0
        MOV     ?V1,#0x0
        SJMP    ??Str_Cat_N_7
//  660 
//  661     while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
//  662            ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
//  663            (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
//  664            ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
//  665        *pstr_cat_dest = *pstr_cat_src;
??Str_Cat_N_8:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        MOVX    @DPTR,A
//  666         pstr_cat_dest++;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  667         pstr_cat_src++;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  668         len_cat++;
        INC     ?V0
        MOV     A,?V0
        JNZ     ??Str_Cat_N_7
        INC     ?V1
//  669     }
??Str_Cat_N_7:
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Cat_N_9
        MOV     A,R4
        ORL     A,R5
        JZ      ??Str_Cat_N_9
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        JZ      ??Str_Cat_N_9
        CLR     C
        MOV     A,?V0
        SUBB    A,R6
        MOV     A,?V1
        SUBB    A,R7
        JC      ??Str_Cat_N_8
//  670                                                                 /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
//  671     if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
//  672         (pstr_cat_src  == (const CPU_CHAR *)0)) {
??Str_Cat_N_9:
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Cat_N_10
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Cat_N_11
//  673          return ((CPU_CHAR *)0);
??Str_Cat_N_10:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Cat_N_1
//  674     }
//  675 
//  676    *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
??Str_Cat_N_11:
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,#0x0
        MOVX    @DPTR,A
//  677 
//  678 
//  679     return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
??Str_Cat_N_1:
        MOV     R7,#0x3
        LJMP    ?FUNC_LEAVE_XDATA
//  680 }
//  681 
//  682 
//  683 /*$PAGE*/
//  684 /*
//  685 *********************************************************************************************************
//  686 *                                              Str_Cmp()
//  687 *
//  688 * Description : Determine if two strings are identical.
//  689 *
//  690 * Argument(s) : p1_str      Pointer to first  string (see Note #1).
//  691 *
//  692 *               p2_str      Pointer to second string (see Note #1).
//  693 *
//  694 * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
//  695 *
//  696 *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
//  697 *
//  698 *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
//  699 *
//  700 *               See also Note #2b.
//  701 *
//  702 * Caller(s)   : Application.
//  703 *
//  704 * Note(s)     : (1) String buffers NOT modified.
//  705 *
//  706 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
//  707 *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the 
//  708 *                       string pointed to by 's2' ('p2_str)".
//  709 *
//  710 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
//  711 *                          "upon successful completion, strcmp() shall return an integer greater than,
//  712 *                           equal to, or less than 0".
//  713 *
//  714 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
//  715 *                           sign of a non-zero return value shall be determined by the sign of the difference
//  716 *                           between the values of the first pair of bytes ... that differ in the strings
//  717 *                           being compared".
//  718 *
//  719 *               (3) String comparison terminates when :
//  720 *
//  721 *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
//  722 *                               (1) NULL strings identical; 0 returned.
//  723 *
//  724 *                           (B) (1) 'p1_str' passed a NULL pointer.
//  725 *                                   (a) Return negative value of character pointed to by 'p2_str'.
//  726 *
//  727 *                               (2) 'p2_str' passed a NULL pointer.
//  728 *                                   (a) Return positive value of character pointed to by 'p1_str'.
//  729 *
//  730 *                       (2) (A) BOTH strings point to NULL.
//  731 *                               (1) Strings overlap with NULL address.
//  732 *                               (2) Strings identical up to but NOT beyond or including the NULL address;
//  733 *                                   0 returned.
//  734 *
//  735 *                           (B) (1) 'p1_str_cmp_next' points to NULL.
//  736 *                                   (a) 'p1_str' overlaps with NULL address.
//  737 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
//  738 *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
//  739 *
//  740 *                               (2) 'p2_str_cmp_next' points to NULL.
//  741 *                                   (a) 'p2_str' overlaps with NULL address.
//  742 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
//  743 *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
//  744 *
//  745 *                   (b) Terminating NULL character found in both strings.
//  746 *                       (1) Strings identical; 0 returned.
//  747 *                       (2) Only one NULL character test required in conditional since previous condition
//  748 *                           tested character equality.
//  749 *
//  750 *                   (c) Non-matching characters found.
//  751 *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
//  752 *                           from the character pointed to by 'p1_str'.
//  753 *
//  754 *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
//  755 *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
//  756 *********************************************************************************************************
//  757 */
//  758 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  759 CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
Str_Cmp:
        CODE
//  760                      const  CPU_CHAR  *p2_str)
//  761 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  762     CPU_INT16S  cmp_val;
//  763 
//  764 
//  765     cmp_val = Str_Cmp_N(p1_str,
//  766                         p2_str,
//  767                         DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Cmp_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Str_Cmp_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
//  768 
//  769     return (cmp_val);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  770 }
//  771 
//  772 
//  773 /*$PAGE*/
//  774 /*
//  775 *********************************************************************************************************
//  776 *                                             Str_Cmp_N()
//  777 *
//  778 * Description : Determine if two strings are identical for up to a maximum number of characters.
//  779 *
//  780 * Argument(s) : p1_str      Pointer to first  string (see Note #1).
//  781 *
//  782 *               p2_str      Pointer to second string (see Note #1).
//  783 *
//  784 *               len_max     Maximum number of characters to compare  (see Note  #3d).
//  785 *
//  786 * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
//  787 *
//  788 *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
//  789 *
//  790 *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
//  791 *
//  792 *               See also Note #2b.
//  793 *
//  794 * Caller(s)   : Application.
//  795 *
//  796 * Note(s)     : (1) String buffers NOT modified.
//  797 *
//  798 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
//  799 *
//  800 *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str') 
//  801 *                            to the array pointed to by 's2' ('p2_str)" ...
//  802 *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
//  803 *
//  804 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
//  805 *                          "upon successful completion, strncmp() shall return an integer greater than,
//  806 *                           equal to, or less than 0".
//  807 *
//  808 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
//  809 *                          "the sign of a non-zero return value is determined by the sign of the difference
//  810 *                           between the values of the first pair of bytes ... that differ in the strings
//  811 *                           being compared".
//  812 *
//  813 *               (3) String comparison terminates when :
//  814 *
//  815 *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
//  816 *                               (1) NULL strings identical; 0 returned.
//  817 *
//  818 *                           (B) (1) 'p1_str' passed a NULL pointer.
//  819 *                                   (a) Return negative value of character pointed to by 'p2_str'.
//  820 *
//  821 *                               (2) 'p2_str' passed a NULL pointer.
//  822 *                                   (a) Return positive value of character pointed to by 'p1_str'.
//  823 *
//  824 *                       (2) (A) BOTH strings point to NULL.
//  825 *                               (1) Strings overlap with NULL address.
//  826 *                               (2) Strings identical up to but NOT beyond or including the NULL address;
//  827 *                                   0 returned.
//  828 *
//  829 *                           (B) (1) 'p1_str_cmp_next' points to NULL.
//  830 *                                   (a) 'p1_str' overlaps with NULL address.
//  831 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
//  832 *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
//  833 *
//  834 *                               (2) 'p2_str_cmp_next' points to NULL.
//  835 *                                   (a) 'p2_str' overlaps with NULL address.
//  836 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
//  837 *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
//  838 *
//  839 *                   (b) Terminating NULL character found in both strings.
//  840 *                       (1) Strings identical; 0 returned.
//  841 *                       (2) Only one NULL character test required in conditional since previous condition
//  842 *                           tested character equality.
//  843 *
//  844 *                   (c) Non-matching characters found.
//  845 *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
//  846 *                           from the character pointed to by 'p1_str'.
//  847 *
//  848 *                   (d) (1) 'len_max' passed a zero length.
//  849 *                           (A) Zero-length strings identical; 0 returned.
//  850 *
//  851 *                       (2) First 'len_max' number of characters identical.
//  852 *                           (A) Strings identical; 0 returned.
//  853 *
//  854 *                       See also Note #2a2.
//  855 *
//  856 *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
//  857 *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
//  858 *********************************************************************************************************
//  859 */
//  860 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  861 CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
Str_Cmp_N:
        CODE
//  862                        const  CPU_CHAR    *p2_str,
//  863                               CPU_SIZE_T   len_max)
//  864 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
//  865     const  CPU_CHAR    *p1_str_cmp;
//  866     const  CPU_CHAR    *p2_str_cmp;
//  867     const  CPU_CHAR    *p1_str_cmp_next;
//  868     const  CPU_CHAR    *p2_str_cmp_next;
//  869            CPU_INT16S   cmp_val;
//  870            CPU_SIZE_T   cmp_len;
//  871 
//  872 
//  873     if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Str_Cmp_N_0
//  874         return (0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Cmp_N_1
//  875     }
//  876 
//  877     if (p1_str == (const CPU_CHAR *)0) {
??Str_Cmp_N_0:
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Cmp_N_2
//  878         if (p2_str == (const CPU_CHAR *)0) {
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Str_Cmp_N_3
//  879             return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Cmp_N_1
//  880         }
//  881         cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
??Str_Cmp_N_3:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     C
        CLR     A
        SUBB    A,R0
        MOV     R2,A
        CLR     A
        SUBB    A,R1
        MOV     R3,A
//  882         return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
        LJMP    ??Str_Cmp_N_1
//  883     }
//  884     if (p2_str == (const CPU_CHAR *)0) {
??Str_Cmp_N_2:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Str_Cmp_N_4
//  885         cmp_val = (CPU_INT16S)(*p1_str);
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
//  886         return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
        LJMP    ??Str_Cmp_N_1
//  887     }
//  888 
//  889 
//  890     p1_str_cmp      = p1_str;
??Str_Cmp_N_4:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
//  891     p2_str_cmp      = p2_str;
//  892     p1_str_cmp_next = p1_str_cmp;
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
//  893     p2_str_cmp_next = p2_str_cmp;
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
//  894     p1_str_cmp_next++;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  895     p2_str_cmp_next++;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  896     cmp_len         = 0u;
        MOV     ?V2,#0x0
        MOV     ?V3,#0x0
        SJMP    ??Str_Cmp_N_5
//  897 
//  898     while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
//  899            (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
//  900            ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
//  901            ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
//  902            ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
//  903         p1_str_cmp++;
??Str_Cmp_N_6:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  904         p2_str_cmp++;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
//  905         p1_str_cmp_next++;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  906         p2_str_cmp_next++;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  907         cmp_len++;
        INC     ?V2
        MOV     A,?V2
        JNZ     ??Str_Cmp_N_5
        INC     ?V3
//  908     }
??Str_Cmp_N_5:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     ?V4,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,?V4
        JNZ     ??Str_Cmp_N_7
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        JZ      ??Str_Cmp_N_7
        MOV     A,R0
        ORL     A,R1
        JZ      ??Str_Cmp_N_7
        MOV     A,R2
        ORL     A,R3
        JZ      ??Str_Cmp_N_7
        CLR     C
        MOV     A,?V2
        SUBB    A,?V0
        MOV     A,?V3
        SUBB    A,?V1
        JC      ??Str_Cmp_N_6
//  909 
//  910 
//  911     if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
??Str_Cmp_N_7:
        MOV     A,?V0
        XRL     A,?V2
        JNZ     ??Str_Cmp_N_8
        MOV     A,?V1
        XRL     A,?V3
??Str_Cmp_N_8:
        JNZ     ??Str_Cmp_N_9
//  912         return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Cmp_N_1
//  913     }
//  914 
//  915     if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
??Str_Cmp_N_9:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,?V0
        JZ      ??Str_Cmp_N_10
//  916                                                                 /* ... calc & rtn char diff  (see Note #3c1).           */
//  917          cmp_val = (CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp);
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     R2,A
        MOV     A,R3
        SUBB    A,R1
        MOV     R3,A
        SJMP    ??Str_Cmp_N_1
//  918 
//  919     } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
??Str_Cmp_N_10:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        JNZ     ??Str_Cmp_N_11
//  920          cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Cmp_N_1
//  921 
//  922     } else {
//  923         if (p1_str_cmp_next == (const CPU_CHAR *)0) {
??Str_Cmp_N_11:
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Cmp_N_12
//  924             if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Cmp_N_13
//  925                 cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Cmp_N_1
//  926             } else {                                            /* If p1_str_cmp_next NULL, ...                         */
//  927                                                                 /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
//  928                 cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
??Str_Cmp_N_13:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     C
        CLR     A
        SUBB    A,R0
        MOV     R2,A
        CLR     A
        SUBB    A,R1
        MOV     R3,A
        SJMP    ??Str_Cmp_N_1
//  929             }
//  930         } else {                                                /* If p2_str_cmp_next NULL, ...                         */
//  931             cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
??Str_Cmp_N_12:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
//  932         }
//  933     }
//  934 
//  935 
//  936     return (cmp_val);
??Str_Cmp_N_1:
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
//  937 }
//  938 
//  939 
//  940 /*$PAGE*/
//  941 /*
//  942 *********************************************************************************************************
//  943 *                                         Str_CmpIgnoreCase()
//  944 *
//  945 * Description : Determine if two strings are identical, ignoring case.
//  946 *
//  947 * Argument(s) : p1_str      Pointer to first  string (see Note #1).
//  948 *
//  949 *               p2_str      Pointer to second string (see Note #1).
//  950 *
//  951 * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
//  952 *
//  953 *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
//  954 *
//  955 *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
//  956 *
//  957 *               See also Note #2b.
//  958 *
//  959 * Caller(s)   : Application.
//  960 *
//  961 * Note(s)     : (1) String buffers NOT modified.
//  962 *
//  963 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
//  964 *
//  965 *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1' 
//  966 *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
//  967 *                           (B) "ignoring differences in case".
//  968 *
//  969 *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
//  970 *                            and then a byte comparison performed."
//  971 *
//  972 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
//  973 *                          "upon successful completion, strcasecmp() shall return an integer greater than,
//  974 *                           equal to, or less than 0".
//  975 *
//  976 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
//  977 *                           sign of a non-zero return value shall be determined by the sign of the difference
//  978 *                           between the values of the first pair of bytes ... that differ in the strings
//  979 *                           being compared".
//  980 *
//  981 *               (3) String comparison terminates when :
//  982 *
//  983 *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
//  984 *                               (1) NULL strings identical; 0 returned.
//  985 *
//  986 *                           (B) (1) 'p1_str' passed a NULL pointer.
//  987 *                                   (a) Return negative value of character pointed to by 'p2_str', converted
//  988 *                                       to lower case (see Note #2a2).
//  989 *
//  990 *                               (2) 'p2_str' passed a NULL pointer.
//  991 *                                   (a) Return positive value of character pointed to by 'p1_str', converted
//  992 *                                       to lower case (see Note #2a2).
//  993 *
//  994 *                       (2) (A) BOTH strings point to NULL.
//  995 *                               (1) Strings overlap with NULL address.
//  996 *                               (2) Strings identical up to but NOT beyond or including the NULL address;
//  997 *                                   0 returned.
//  998 *
//  999 *                           (B) (1) 'p1_str_cmp_next' points to NULL.
// 1000 *                                   (a) 'p1_str' overlaps with NULL address.
// 1001 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
// 1002 *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
// 1003 *                                       converted to lower case (see Note #2a2).
// 1004 *
// 1005 *                               (2) 'p2_str_cmp_next' points to NULL.
// 1006 *                                   (a) 'p2_str' overlaps with NULL address.
// 1007 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
// 1008 *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
// 1009 *                                       converted to lower case (see Note #2a2).
// 1010 *
// 1011 *                   (b) Terminating NULL character found in both strings.
// 1012 *                       (1) Strings identical; 0 returned.
// 1013 *                       (2) Only one NULL character test required in conditional since previous condition
// 1014 *                           tested character equality.
// 1015 *
// 1016 *                   (c) Non-matching characters found.
// 1017 *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
// 1018 *                           converted to lower case, from the character pointed to by 'p1_str', converted
// 1019 *                           to lower case.
// 1020 *
// 1021 *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
// 1022 *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
// 1023 *********************************************************************************************************
// 1024 */
// 1025 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1026 CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
Str_CmpIgnoreCase:
        CODE
// 1027                                const  CPU_CHAR  *p2_str)
// 1028 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1029     CPU_INT16S  cmp_val;
// 1030 
// 1031 
// 1032     cmp_val = Str_CmpIgnoreCase_N(p1_str,
// 1033                                   p2_str,
// 1034                                   DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_CmpIgnoreCase_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Str_CmpIgnoreCase_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 1035 
// 1036     return (cmp_val);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1037 }
// 1038 
// 1039 
// 1040 /*$PAGE*/
// 1041 /*
// 1042 *********************************************************************************************************
// 1043 *                                        Str_CmpIgnoreCase_N()
// 1044 *
// 1045 * Description : Determine if two strings are identical for up to a maximum number of characters,
// 1046 *                   ignoring case.
// 1047 *
// 1048 * Argument(s) : p1_str      Pointer to first  string (see Note #1).
// 1049 *
// 1050 *               p2_str      Pointer to second string (see Note #1).
// 1051 *
// 1052 *               len_max     Maximum number of characters to compare  (see Note  #3d).
// 1053 *
// 1054 * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
// 1055 *
// 1056 *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
// 1057 *
// 1058 *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
// 1059 *
// 1060 *               See also Note #2b.
// 1061 *
// 1062 * Caller(s)   : Application.
// 1063 *
// 1064 * Note(s)     : (1) String buffers NOT modified.
// 1065 *
// 1066 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
// 1067 *
// 1068 *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1' 
// 1069 *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
// 1070 *                           (B) "ignoring differences in case"                           ...
// 1071 *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
// 1072 *
// 1073 *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
// 1074 *                            and then a byte comparison performed."
// 1075 *
// 1076 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
// 1077 *                          "upon successful completion, strncasecmp() shall return an integer greater than,
// 1078 *                           equal to, or less than 0".
// 1079 *
// 1080 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
// 1081 *                           sign of a non-zero return value shall be determined by the sign of the difference
// 1082 *                           between the values of the first pair of bytes ... that differ in the strings
// 1083 *                           being compared".
// 1084 *
// 1085 *               (3) String comparison terminates when :
// 1086 *
// 1087 *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
// 1088 *                               (1) NULL strings identical; 0 returned.
// 1089 *
// 1090 *                           (B) (1) 'p1_str' passed a NULL pointer.
// 1091 *                                   (a) Return negative value of character pointed to by 'p2_str', converted
// 1092 *                                       to lower case (see Note #2a2).
// 1093 *
// 1094 *                               (2) 'p2_str' passed a NULL pointer.
// 1095 *                                   (a) Return positive value of character pointed to by 'p1_str', converted
// 1096 *                                       to lower case (see Note #2a2).
// 1097 *
// 1098 *                       (2) (A) BOTH strings point to NULL.
// 1099 *                               (1) Strings overlap with NULL address.
// 1100 *                               (2) Strings identical up to but NOT beyond or including the NULL address;
// 1101 *                                   0 returned.
// 1102 *
// 1103 *                           (B) (1) 'p1_str_cmp_next' points to NULL.
// 1104 *                                   (a) 'p1_str' overlaps with NULL address.
// 1105 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
// 1106 *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
// 1107 *                                       converted to lower case (see Note #2a2).
// 1108 *
// 1109 *                               (2) 'p2_str_cmp_next' points to NULL.
// 1110 *                                   (a) 'p2_str' overlaps with NULL address.
// 1111 *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
// 1112 *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
// 1113 *                                       converted to lower case (see Note #2a2).
// 1114 *
// 1115 *                   (b) Terminating NULL character found in both strings.
// 1116 *                       (1) Strings identical; 0 returned.
// 1117 *                       (2) Only one NULL character test required in conditional since previous condition
// 1118 *                           tested character equality.
// 1119 *
// 1120 *                   (c) Non-matching characters found.
// 1121 *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
// 1122 *                           converted to lower case, from the character pointed to by 'p1_str', converted
// 1123 *                           to lower case.
// 1124 *
// 1125 *                   (d) (1) 'len_max' passed a zero length.
// 1126 *                           (A) Zero-length strings identical; 0 returned.
// 1127 *
// 1128 *                       (2) First 'len_max' number of characters identical.
// 1129 *                           (A) Strings identical; 0 returned.
// 1130 *
// 1131 *                       See also Note #2a1C.
// 1132 *$PAGE*
// 1133 *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
// 1134 *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
// 1135 *********************************************************************************************************
// 1136 */
// 1137 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1138 CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
Str_CmpIgnoreCase_N:
        CODE
// 1139                                  const  CPU_CHAR    *p2_str,
// 1140                                         CPU_SIZE_T   len_max)
// 1141 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        MOV     A,#-0xe
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 14
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
// 1142     const  CPU_CHAR    *p1_str_cmp;
// 1143     const  CPU_CHAR    *p2_str_cmp;
// 1144     const  CPU_CHAR    *p1_str_cmp_next;
// 1145     const  CPU_CHAR    *p2_str_cmp_next;
// 1146            CPU_CHAR     char_1;
// 1147            CPU_CHAR     char_2;
// 1148            CPU_INT16S   cmp_val;
// 1149            CPU_SIZE_T   cmp_len;
// 1150 
// 1151 
// 1152     if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_CmpIgnoreCase_N_0
// 1153         return (0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_CmpIgnoreCase_N_1
// 1154     }
// 1155 
// 1156     if (p1_str == (const CPU_CHAR *)0) {
??Str_CmpIgnoreCase_N_0:
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_CmpIgnoreCase_N_2
// 1157         if (p2_str == (const CPU_CHAR *)0) {
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_CmpIgnoreCase_N_3
// 1158             return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_CmpIgnoreCase_N_1
// 1159         }
// 1160         char_2  =  ASCII_ToLower(*p2_str);
??Str_CmpIgnoreCase_N_3:
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     R0,A
// 1161         cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
        MOV     R1,#0x0
        CLR     C
        CLR     A
        SUBB    A,R0
        MOV     R2,A
        CLR     A
        SUBB    A,R1
        MOV     R3,A
// 1162         return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
        LJMP    ??Str_CmpIgnoreCase_N_1
// 1163     }
// 1164     if (p2_str == (const CPU_CHAR *)0) {
??Str_CmpIgnoreCase_N_2:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_CmpIgnoreCase_N_4
// 1165         char_1  =  ASCII_ToLower(*p1_str);
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     ?V6,A
// 1166         cmp_val = (CPU_INT16S)char_1;
        MOV     R2,?V6
        MOV     R3,#0x0
// 1167         return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
        LJMP    ??Str_CmpIgnoreCase_N_1
// 1168     }
// 1169 
// 1170 
// 1171     p1_str_cmp      = p1_str;
??Str_CmpIgnoreCase_N_4:
        MOV     ?V2,R2
        MOV     ?V3,R3
// 1172     p2_str_cmp      = p2_str;
        MOV     ?V4,R4
        MOV     ?V5,R5
// 1173     p1_str_cmp_next = p1_str_cmp;
        MOV     ?V0,?V2
        MOV     ?V1,?V3
// 1174     p2_str_cmp_next = p2_str_cmp;
        MOV     R6,?V4
        MOV     R7,?V5
// 1175     p1_str_cmp_next++;
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        MOV     ?V0,DPL
        MOV     ?V1,DPH
// 1176     p2_str_cmp_next++;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1177     char_1          = ASCII_ToLower(*p1_str_cmp);
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     ?V6,A
// 1178     char_2          = ASCII_ToLower(*p2_str_cmp);
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     R0,A
// 1179     cmp_len         = 0u;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??Str_CmpIgnoreCase_N_5
// 1180 
// 1181     while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
// 1182            (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
// 1183            ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
// 1184            ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
// 1185            ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
// 1186         p1_str_cmp++;
??Str_CmpIgnoreCase_N_6:
        MOV     DPL,?V2
        MOV     DPH,?V3
        INC     DPTR
        MOV     ?V2,DPL
        MOV     ?V3,DPH
// 1187         p2_str_cmp++;
        MOV     DPL,?V4
        MOV     DPH,?V5
        INC     DPTR
        MOV     ?V4,DPL
        MOV     ?V5,DPH
// 1188         p1_str_cmp_next++;
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        MOV     ?V0,DPL
        MOV     ?V1,DPH
// 1189         p2_str_cmp_next++;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1190         cmp_len++;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1191         char_1 = ASCII_ToLower(*p1_str_cmp);
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     ?V6,A
// 1192         char_2 = ASCII_ToLower(*p2_str_cmp);
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     R0,A
// 1193     }
??Str_CmpIgnoreCase_N_5:
        MOV     A,R0
        XRL     A,?V6
        JNZ     ??Str_CmpIgnoreCase_N_7
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOVX    A,@DPTR
        JZ      ??Str_CmpIgnoreCase_N_7
        MOV     A,?V0
        ORL     A,?V1
        JZ      ??Str_CmpIgnoreCase_N_7
        MOV     A,R6
        ORL     A,R7
        JZ      ??Str_CmpIgnoreCase_N_7
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        PUSH    DPL
        PUSH    DPH
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JNC     $+5
        LJMP    ??Str_CmpIgnoreCase_N_6
// 1194 
// 1195 
// 1196     if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
??Str_CmpIgnoreCase_N_7:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R2
        JNZ     ??Str_CmpIgnoreCase_N_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R3
??Str_CmpIgnoreCase_N_8:
        JNZ     ??Str_CmpIgnoreCase_N_9
// 1197         return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_CmpIgnoreCase_N_1
// 1198     }
// 1199 
// 1200     if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
??Str_CmpIgnoreCase_N_9:
        MOV     A,R0
        XRL     A,?V6
        JZ      ??Str_CmpIgnoreCase_N_10
// 1201          cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */
        MOV     R2,?V6
        MOV     R3,#0x0
        MOV     R1,#0x0
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     R2,A
        MOV     A,R3
        SUBB    A,R1
        MOV     R3,A
        SJMP    ??Str_CmpIgnoreCase_N_1
// 1202 
// 1203     } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
??Str_CmpIgnoreCase_N_10:
        MOV     A,?V6
        JNZ     ??Str_CmpIgnoreCase_N_11
// 1204          cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_CmpIgnoreCase_N_1
// 1205 
// 1206     } else {
// 1207         if (p1_str_cmp_next == (const CPU_CHAR *)0) {
??Str_CmpIgnoreCase_N_11:
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Str_CmpIgnoreCase_N_12
// 1208             if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Str_CmpIgnoreCase_N_13
// 1209                 cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_CmpIgnoreCase_N_1
// 1210             } else {                                            /* If p1_str_cmp_next NULL, ...                         */
// 1211                 char_2  =  ASCII_ToLower(*p2_str_cmp_next);
??Str_CmpIgnoreCase_N_13:
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     R0,A
// 1212                 cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
        MOV     R1,#0x0
        CLR     C
        CLR     A
        SUBB    A,R0
        MOV     R2,A
        CLR     A
        SUBB    A,R1
        MOV     R3,A
        SJMP    ??Str_CmpIgnoreCase_N_1
// 1213             }
// 1214         } else {                                                /* If p2_str_cmp_next NULL, ...                         */
// 1215             char_1  =  ASCII_ToLower(*p1_str_cmp_next);
??Str_CmpIgnoreCase_N_12:
        ; Setup parameters for call to function ASCII_ToLower
        MOV     DPL,?V0
        MOV     DPH,?V1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_ToLower
        MOV     A,R1
        MOV     ?V6,A
// 1216             cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
        MOV     R2,?V6
        MOV     R3,#0x0
// 1217         }
// 1218     }
// 1219 
// 1220 
// 1221     return (cmp_val);
??Str_CmpIgnoreCase_N_1:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x7
        LJMP    ?FUNC_LEAVE_XDATA
// 1222 }
// 1223 
// 1224 
// 1225 /*$PAGE*/
// 1226 /*
// 1227 *********************************************************************************************************
// 1228 *                                             Str_Char()
// 1229 *
// 1230 * Description : Search string for first occurrence of specific character.
// 1231 *
// 1232 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1233 *
// 1234 *               srch_char       Search character.
// 1235 *
// 1236 * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
// 1237 *
// 1238 *               Pointer to NULL,                                           otherwise (see Note #2b2).
// 1239 *
// 1240 * Caller(s)   : Application.
// 1241 *
// 1242 * Note(s)     : (1) String buffer NOT modified.
// 1243 *
// 1244 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
// 1245 *
// 1246 *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
// 1247 *                            ... in the string pointed to by 's' ('pstr')."
// 1248 *                       (2) "The terminating null byte is considered to be part of the string."
// 1249 *
// 1250 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
// 1251 *                       "upon completion, strchr() shall return" :
// 1252 *
// 1253 *                       (1) "a pointer to the byte," ...
// 1254 *                       (2) "or a null pointer if the byte was not found."
// 1255 *                           (A) #### Although NO strchr() specification states to return NULL for 
// 1256 *                               any other reason(s), NULL is also returned for any error(s).
// 1257 *
// 1258 *               (3) String search terminates when :
// 1259 *
// 1260 *                   (a) String pointer passed a NULL pointer.
// 1261 *                       (1) No string search performed; NULL pointer returned.
// 1262 *
// 1263 *                   (b) String pointer points to NULL.
// 1264 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1265 *
// 1266 *                   (c) String's terminating NULL character found.
// 1267 *                       (1) Search character NOT found in search string; NULL pointer returned 
// 1268 *                           (see Note #2b2).
// 1269 *                       (2) Applicable even if search character is the terminating NULL character 
// 1270 *                           (see Note #2a2).
// 1271 *
// 1272 *                   (d) Search character found.
// 1273 *                       (1) Return pointer to first occurrence of search character in search string
// 1274 *                           (see Note #2a1).
// 1275 *********************************************************************************************************
// 1276 */
// 1277 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1278 CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
Str_Char:
        CODE
// 1279                             CPU_CHAR   srch_char)
// 1280 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 1281     CPU_CHAR  *pstr_rtn;
// 1282 
// 1283 
// 1284     pstr_rtn = Str_Char_N(pstr,
// 1285                           DEF_INT_CPU_U_MAX_VAL,
// 1286                           srch_char);
        ; Setup parameters for call to function Str_Char_N
        MOV     A,R6
        MOV     R1,A
        MOV     R4,#-0x1
        MOV     R5,#-0x1
        LCALL   Str_Char_N
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 1287 
// 1288     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1289 }
// 1290 
// 1291 
// 1292 /*$PAGE*/
// 1293 /*
// 1294 *********************************************************************************************************
// 1295 *                                            Str_Char_N()
// 1296 *
// 1297 * Description : Search string for first occurrence of specific character, up to a maximum number 
// 1298 *                   of characters.
// 1299 *
// 1300 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1301 *
// 1302 *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
// 1303 *
// 1304 *               srch_char       Search character.
// 1305 *
// 1306 * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
// 1307 *
// 1308 *               Pointer to NULL,                                           otherwise (see Note #2b2).
// 1309 *
// 1310 * Caller(s)   : Application.
// 1311 *
// 1312 * Note(s)     : (1) String buffer NOT modified.
// 1313 *
// 1314 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
// 1315 *
// 1316 *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char') 
// 1317 *                            ... in the string pointed to by 's' ('pstr')."
// 1318 *                       (2) "The terminating null byte is considered to be part of the string."
// 1319 *
// 1320 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that 
// 1321 *                       "upon completion, strchr() shall return" :
// 1322 *
// 1323 *                       (1) "a pointer to the byte," ...
// 1324 *                       (2) "or a null pointer if the byte was not found."
// 1325 *                           (A) #### Although NO strchr() specification states to return NULL for 
// 1326 *                               any other reason(s), NULL is also returned for any error(s).
// 1327 *
// 1328 *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
// 1329 *                       argument list for consistency with all other custom string library functions.
// 1330 *                       However, the 'len_max' argument is sequentially ordered as the second argument 
// 1331 *                       to comply with most standard library's strnchr() argument list.
// 1332 *
// 1333 *               (3) String search terminates when :
// 1334 *
// 1335 *                   (a) String pointer passed a NULL pointer.
// 1336 *                       (1) No string search performed; NULL pointer returned.
// 1337 *
// 1338 *                   (b) String pointer points to NULL.
// 1339 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1340 *
// 1341 *                   (c) String's terminating NULL character found.
// 1342 *                       (1) Search character NOT found in search string; NULL pointer returned 
// 1343 *                           (see Note #2b2).
// 1344 *                       (2) Applicable even if search character is the terminating NULL character 
// 1345 *                           (see Note #2a2).
// 1346 *
// 1347 *                   (d) Search character found.
// 1348 *                       (1) Return pointer to first occurrence of search character in search string
// 1349 *                           (see Note #2a1).
// 1350 *
// 1351 *                   (e) 'len_max' number of characters searched.
// 1352 *                       (1) Search character NOT found in search string within first 'len_max' number 
// 1353 *                           of characters; NULL pointer returned.
// 1354 *                       (2) 'len_max' number of characters MAY include terminating NULL character 
// 1355 *                           (see Note #2a2).
// 1356 *********************************************************************************************************
// 1357 */
// 1358 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1359 CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
Str_Char_N:
        CODE
// 1360                               CPU_SIZE_T   len_max,
// 1361                               CPU_CHAR     srch_char)
// 1362 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
// 1363     const  CPU_CHAR    *pstr_char;
// 1364            CPU_SIZE_T   len_srch;
// 1365 
// 1366 
// 1367     if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
        MOV     A,DPL
        ORL     A,DPH
        JNZ     ??Str_Char_N_0
// 1368         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_1
// 1369     }
// 1370 
// 1371     if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
??Str_Char_N_0:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Char_N_2
// 1372         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_1
// 1373     }
// 1374 
// 1375 
// 1376     pstr_char = pstr;
// 1377     len_srch  = 0u;
??Str_Char_N_2:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_3
// 1378 
// 1379     while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
// 1380            (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
// 1381            (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
// 1382            ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
// 1383         pstr_char++;
??Str_Char_N_4:
        INC     DPTR
// 1384         len_srch++;
        INC     R2
        MOV     A,R2
        JNZ     ??Str_Char_N_3
        INC     R3
// 1385     }
??Str_Char_N_3:
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??Str_Char_N_5
        MOVX    A,@DPTR
        JZ      ??Str_Char_N_5
        MOVX    A,@DPTR
        XRL     A,R1
        JZ      ??Str_Char_N_5
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JC      ??Str_Char_N_4
// 1386 
// 1387 
// 1388     if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
??Str_Char_N_5:
        MOV     A,DPL
        ORL     A,DPH
        JNZ     ??Str_Char_N_6
// 1389         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_1
// 1390     }
// 1391 
// 1392     if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
??Str_Char_N_6:
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JC      ??Str_Char_N_7
// 1393         return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_1
// 1394     }
// 1395 
// 1396     if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
??Str_Char_N_7:
        MOVX    A,@DPTR
        XRL     A,R1
        JZ      ??Str_Char_N_8
// 1397          return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_N_1
// 1398     }
// 1399 
// 1400 
// 1401     return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
??Str_Char_N_8:
        MOV     R2,DPL
        MOV     R3,DPH
??Str_Char_N_1:
        POP     DPH
        POP     DPL
        RET
// 1402 }
// 1403 
// 1404 
// 1405 /*$PAGE*/
// 1406 /*
// 1407 *********************************************************************************************************
// 1408 *                                           Str_Char_Last()
// 1409 *
// 1410 * Description : Search string for last occurrence of specific character.
// 1411 *
// 1412 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1413 *
// 1414 *               srch_char       Search character.
// 1415 *
// 1416 * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
// 1417 *
// 1418 *               Pointer to NULL,                                          otherwise (see Note #2b2).
// 1419 *
// 1420 * Caller(s)   : Application.
// 1421 *
// 1422 * Note(s)     : (1) String buffer NOT modified.
// 1423 *
// 1424 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
// 1425 *
// 1426 *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
// 1427 *                            ... in the string pointed to by 's' ('pstr')."
// 1428 *                       (2) "The terminating null byte is considered to be part of the string."
// 1429 *
// 1430 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
// 1431 *                       "upon successful completion, strrchr() shall return" :
// 1432 *
// 1433 *                       (1) "a pointer to the byte" ...
// 1434 *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
// 1435 *                           (A) #### Although NO strrchr() specification states to return NULL for 
// 1436 *                               any other reason(s), NULL is also returned for any error(s).
// 1437 *
// 1438 *               (3) String search terminates when :
// 1439 *
// 1440 *                   (a) String pointer passed a NULL pointer.
// 1441 *                       (1) No string search performed; NULL pointer returned.
// 1442 *
// 1443 *                   (b) String pointer points to NULL.
// 1444 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1445 *
// 1446 *                   (c) String searched from end to beginning.
// 1447 *                       (1) Search character NOT found in search string; NULL pointer returned.
// 1448 *                       (2) Applicable even if search character is the terminating NULL character 
// 1449 *                           (see Note #2a2).
// 1450 *
// 1451 *                   (d) Search character found.
// 1452 *                       (1) Return pointer to last occurrence of search character in search string 
// 1453 *                           (see Note #2a1).
// 1454 *********************************************************************************************************
// 1455 */
// 1456 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1457 CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
Str_Char_Last:
        CODE
// 1458                                  CPU_CHAR   srch_char)
// 1459 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 1460     CPU_CHAR  *pstr_rtn;
// 1461 
// 1462 
// 1463     pstr_rtn = Str_Char_Last_N(pstr,
// 1464                                DEF_INT_CPU_U_MAX_VAL,
// 1465                                srch_char);
        ; Setup parameters for call to function Str_Char_Last_N
        MOV     A,R6
        MOV     R1,A
        MOV     R4,#-0x1
        MOV     R5,#-0x1
        LCALL   Str_Char_Last_N
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 1466 
// 1467     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1468 }
// 1469 
// 1470 
// 1471 /*$PAGE*/
// 1472 /*
// 1473 *********************************************************************************************************
// 1474 *                                          Str_Char_Last_N()
// 1475 *
// 1476 * Description : Search string for last occurrence of specific character, up to a maximum number 
// 1477 *                   of characters.
// 1478 *
// 1479 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1480 *
// 1481 *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
// 1482 *
// 1483 *               srch_char       Search character.
// 1484 *
// 1485 * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
// 1486 *
// 1487 *               Pointer to NULL,                                          otherwise (see Note #2b2).
// 1488 *
// 1489 * Caller(s)   : Application.
// 1490 *
// 1491 * Note(s)     : (1) String buffer NOT modified.
// 1492 *
// 1493 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
// 1494 *
// 1495 *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char') 
// 1496 *                            ... in the string pointed to by 's' ('pstr')."
// 1497 *                       (2) "The terminating null byte is considered to be part of the string."
// 1498 *
// 1499 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that 
// 1500 *                       "upon successful completion, strrchr() shall return" :
// 1501 *
// 1502 *                       (1) "a pointer to the byte" ...
// 1503 *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
// 1504 *                           (A) #### Although NO strrchr() specification states to return NULL for 
// 1505 *                               any other reason(s), NULL is also returned for any error(s).
// 1506 *
// 1507 *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
// 1508 *                       argument list for consistency with all other custom string library functions.
// 1509 *                       However, the 'len_max' argument is sequentially ordered as the second argument 
// 1510 *                       to comply with most standard library's strnrchr() argument list.
// 1511 *
// 1512 *                       See also 'Str_Char_N()  Note #2c'.
// 1513 *
// 1514 *               (3) String search terminates when :
// 1515 *
// 1516 *                   (a) String pointer passed a NULL pointer.
// 1517 *                       (1) No string search performed; NULL pointer returned.
// 1518 *
// 1519 *                   (b) String pointer points to NULL.
// 1520 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1521 *
// 1522 *                   (c) String searched from end to beginning.
// 1523 *                       (1) Search character NOT found in search string; NULL pointer returned 
// 1524 *                           (see Note #2b2).
// 1525 *                       (2) Applicable even if search character is the terminating NULL character 
// 1526 *                           (see Note #2a2).
// 1527 *
// 1528 *                   (d) Search character found.
// 1529 *                       (1) Return pointer to last occurrence of search character in search string 
// 1530 *                           (see Note #2a1).
// 1531 *
// 1532 *                   (e) 'len_max' number of characters searched.
// 1533 *                       (1) Search character NOT found in search string within last 'len_max' number 
// 1534 *                           of characters; NULL pointer returned.
// 1535 *                       (2) 'len_max' number of characters MAY include terminating NULL character 
// 1536 *                           (see Note #2a2).
// 1537 *********************************************************************************************************
// 1538 */
// 1539 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1540 CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
Str_Char_Last_N:
        CODE
// 1541                                    CPU_SIZE_T   len_max,
// 1542                                    CPU_CHAR     srch_char)
// 1543 {
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0,R1
// 1544     const  CPU_CHAR    *pstr_char;
// 1545            CPU_SIZE_T   str_len_max;
// 1546            CPU_SIZE_T   str_len;
// 1547 
// 1548 
// 1549     if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
        MOV     A,R6
        ORL     A,R7
        JNZ     ??Str_Char_Last_N_0
// 1550         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Last_N_1
// 1551     }
// 1552 
// 1553     if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
??Str_Char_Last_N_0:
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Char_Last_N_2
// 1554         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Last_N_1
// 1555     }
// 1556 
// 1557 
// 1558     pstr_char    = pstr;
??Str_Char_Last_N_2:
        MOV     DPL,R6
        MOV     DPH,R7
// 1559      str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
// 1560      str_len     = Str_Len_N(pstr_char, str_len_max);
        ; Setup parameters for call to function Str_Len_N
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   Str_Len_N
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
// 1561     pstr_char   += str_len;
        MOV     A,DPL
        ADD     A,R0
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,R1
        MOV     DPH,A
// 1562 
// 1563     if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
        MOV     A,DPL
        ORL     A,DPH
        JNZ     ??Str_Char_Last_N_3
// 1564         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Last_N_1
// 1565     }
// 1566 
// 1567     while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
// 1568            (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
// 1569         pstr_char--;
??Str_Char_Last_N_4:
        MOV     A,DPL
        ADD     A,#-0x1
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,#-0x1
        MOV     DPH,A
// 1570     }
??Str_Char_Last_N_3:
        MOV     A,R6
        XRL     A,DPL
        JNZ     ??Str_Char_Last_N_5
        MOV     A,R7
        XRL     A,DPH
??Str_Char_Last_N_5:
        JZ      ??Str_Char_Last_N_6
        MOVX    A,@DPTR
        XRL     A,?V0
        JNZ     ??Str_Char_Last_N_4
// 1571 
// 1572 
// 1573     if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
??Str_Char_Last_N_6:
        MOVX    A,@DPTR
        XRL     A,?V0
        JZ      ??Str_Char_Last_N_7
// 1574          return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Last_N_1
// 1575     }
// 1576 
// 1577 
// 1578     return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
??Str_Char_Last_N_7:
        MOV     R2,DPL
        MOV     R3,DPH
??Str_Char_Last_N_1:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
// 1579 }
// 1580 
// 1581 
// 1582 /*$PAGE*/
// 1583 /*
// 1584 *********************************************************************************************************
// 1585 *                                         Str_Char_Replace()
// 1586 *
// 1587 * Description : Search string for specific character and replace it by another specific character.
// 1588 *
// 1589 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1590 *
// 1591 *               char_srch       Search character.
// 1592 *
// 1593 *               char_replace    Replace character.
// 1594 *
// 1595 * Return(s)   : Pointer to string, if NO error(s).
// 1596 *
// 1597 *               Pointer to NULL,   otherwise.
// 1598 *
// 1599 * Caller(s)   : Application.
// 1600 *
// 1601 * Note(s)     : (1) String buffer modified.
// 1602 *
// 1603 *               (2) String search terminates when :
// 1604 *
// 1605 *                   (a) String pointer passed a NULL pointer.
// 1606 *                       (1) No string search performed; NULL pointer returned.
// 1607 *
// 1608 *                   (b) String pointer points to NULL.
// 1609 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1610 *
// 1611 *                   (c) String's terminating NULL character found.
// 1612 *                       (1) Search character NOT found in search string; NULL pointer returned
// 1613 *                       (2) Applicable even if search character is the terminating NULL character
// 1614 *
// 1615 *                   (d) Search character found.
// 1616 *                       (1) Replace character found by the specified character.
// 1617 *********************************************************************************************************
// 1618 */
// 1619 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1620 CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
Str_Char_Replace:
        CODE
// 1621                              CPU_CHAR   char_srch,
// 1622                              CPU_CHAR   char_replace)
// 1623 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R7,A
        MOV     A,R4
        MOV     R6,A
// 1624     CPU_CHAR  *pstr_rtn;
// 1625 
// 1626 
// 1627     pstr_rtn = Str_Char_Replace_N(pstr,
// 1628                                   char_srch,
// 1629                                   char_replace,
// 1630                                   DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Char_Replace_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R1,A
        LCALL   Str_Char_Replace_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 1631 
// 1632     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1633 }
// 1634 
// 1635 
// 1636 /*$PAGE*/
// 1637 /*
// 1638 *********************************************************************************************************
// 1639 *                                        Str_Char_Replace_N()
// 1640 *
// 1641 * Description : Search string for specific character and replace it by another specific character, up to
// 1642 *               a maximum number of characters.
// 1643 *
// 1644 * Argument(s) : pstr            Pointer to string (see Note #1).
// 1645 *
// 1646 *               char_srch       Search character.
// 1647 *
// 1648 *               char_replace    Replace character.
// 1649 *
// 1650 *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
// 1651 *
// 1652 * Return(s)   : Pointer to string, if NO error(s).
// 1653 *
// 1654 *               Pointer to NULL,   otherwise.
// 1655 *
// 1656 * Caller(s)   : Application.
// 1657 *
// 1658 * Note(s)     : (1) String buffer modified.
// 1659 *
// 1660 *               (2) String search terminates when :
// 1661 *
// 1662 *                   (a) String pointer passed a NULL pointer.
// 1663 *                       (1) No string search performed; NULL pointer returned.
// 1664 *
// 1665 *                   (b) String pointer points to NULL.
// 1666 *                       (1) String overlaps with NULL address; NULL pointer returned.
// 1667 *
// 1668 *                   (c) String's terminating NULL character found.
// 1669 *                       (1) Search character NOT found in search string; NULL pointer returned
// 1670 *                       (2) Applicable even if search character is the terminating NULL character
// 1671 *
// 1672 *                   (d) Search character found.
// 1673 *                       (1) Replace character found by the specified character.
// 1674 *
// 1675 *                   (e) 'len_max' number of characters searched.
// 1676 *                       (1) Search character NOT found in search string within first 'len_max' number
// 1677 *                           of characters; NULL pointer returned.
// 1678 *                       (2) 'len_max' number of characters MAY include terminating NULL character
// 1679 *                           (see Note #2a2).
// 1680 *********************************************************************************************************
// 1681 */
// 1682 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1683 CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
Str_Char_Replace_N:
        CODE
// 1684                                CPU_CHAR     char_srch,
// 1685                                CPU_CHAR     char_replace,
// 1686                                CPU_SIZE_T   len_max)
// 1687 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
        MOV     A,R4
        MOV     R7,A
// 1688     CPU_CHAR    *pstr_char;
// 1689     CPU_SIZE_T   len;
// 1690 
// 1691 
// 1692     if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Char_Replace_N_0
// 1693         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Replace_N_1
// 1694     }
??Str_Char_Replace_N_0:
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1695 
// 1696     if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Char_Replace_N_2
// 1697         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Char_Replace_N_1
// 1698     }
// 1699 
// 1700     pstr_char = pstr;
??Str_Char_Replace_N_2:
        MOV     DPL,R2
        MOV     DPH,R3
// 1701     len       = len_max;
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        SJMP    ??Str_Char_Replace_N_3
// 1702 
// 1703     while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
// 1704            (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
// 1705            ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
// 1706 
// 1707         if (*pstr_char == char_srch) {
??Str_Char_Replace_N_4:
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??Str_Char_Replace_N_5
// 1708             *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
        MOV     A,R7
        PUSH    A
        POP     A
        MOVX    @DPTR,A
// 1709         }
// 1710 
// 1711         pstr_char++;
??Str_Char_Replace_N_5:
        INC     DPTR
// 1712         len--;
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
// 1713     }
??Str_Char_Replace_N_3:
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??Str_Char_Replace_N_1
        MOVX    A,@DPTR
        JZ      ??Str_Char_Replace_N_1
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Char_Replace_N_4
// 1714 
// 1715     return (pstr);
??Str_Char_Replace_N_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1716 }
// 1717 
// 1718 
// 1719 /*$PAGE*/
// 1720 /*
// 1721 *********************************************************************************************************
// 1722 *                                              Str_Str()
// 1723 *
// 1724 * Description : Search string for first occurence of a specific search string.
// 1725 *
// 1726 * Argument(s) : pstr            Pointer to        string (see Note #1).
// 1727 *
// 1728 *               pstr_srch       Pointer to search string (see Note #1).
// 1729 *
// 1730 * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
// 1731 *
// 1732 *               Pointer to string,                                      if NULL search string (see Note #2b2).
// 1733 *
// 1734 *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
// 1735 *
// 1736 * Caller(s)   : Application.
// 1737 *
// 1738 * Note(s)     : (1) String buffers NOT modified.
// 1739 *
// 1740 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
// 1741 *
// 1742 *                       (1) "The strstr() function shall locate the first occurrence  in the string 
// 1743 *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
// 1744 *                            pointed to by 's2' ('pstr_srch')" ...
// 1745 *                       (2) "(excluding the terminating null byte)."
// 1746 *
// 1747 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
// 1748 *
// 1749 *                       (1) "Upon successful completion, strstr() shall return" :
// 1750 *                           (A) "a pointer to the located string" ...
// 1751 *                           (B) "or a null pointer if the string is not found."
// 1752 *                               (1) #### Although NO strstr() specification states to return NULL for 
// 1753 *                                   any other reason(s), NULL is also returned for any error(s).
// 1754 *
// 1755 *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
// 1756 *                            shall return 's1' ('pstr')."
// 1757 *
// 1758 *               (3) String search terminates when :
// 1759 *
// 1760 *                   (a) String pointer(s) are passed NULL pointers.
// 1761 *                       (1) No string search performed; NULL pointer returned.
// 1762 *
// 1763 *                   (b) String pointer(s) point to NULL.
// 1764 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
// 1765 *
// 1766 *                   (c) Search string length equal to zero.
// 1767 *                       (1) No string search performed; string pointer returned (see Note #2b2).
// 1768 *
// 1769 *                   (d) Search string length greater than string length.
// 1770 *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
// 1771 *
// 1772 *                   (e) Entire string has been searched.
// 1773 *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
// 1774 *
// 1775 *                   (f) Search string found.
// 1776 *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
// 1777 *********************************************************************************************************
// 1778 */
// 1779 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1780 CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
Str_Str:
        CODE
// 1781                     const  CPU_CHAR  *pstr_srch)
// 1782 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 1783     CPU_CHAR  *pstr_rtn;
// 1784 
// 1785 
// 1786     pstr_rtn = Str_Str_N(pstr,
// 1787                          pstr_srch,
// 1788                          DEF_INT_CPU_U_MAX_VAL);
        ; Setup parameters for call to function Str_Str_N
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   Str_Str_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 1789 
// 1790     return (pstr_rtn);
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 1791 }
// 1792 
// 1793 
// 1794 /*$PAGE*/
// 1795 /*
// 1796 *********************************************************************************************************
// 1797 *                                             Str_Str_N()
// 1798 *
// 1799 * Description : Search string for first occurence of a specific search string, up to a maximum number 
// 1800 *                   of characters.
// 1801 *
// 1802 * Argument(s) : pstr            Pointer to        string (see Note #1).
// 1803 *
// 1804 *               pstr_srch       Pointer to search string (see Note #1).
// 1805 *
// 1806 *               len_max         Maximum number of characters to search (see Note #3g).
// 1807 *
// 1808 * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
// 1809 *
// 1810 *               Pointer to string,                                      if NULL search string (see Note #2b2).
// 1811 *
// 1812 *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
// 1813 *
// 1814 * Caller(s)   : Application.
// 1815 *
// 1816 * Note(s)     : (1) String buffers NOT modified.
// 1817 *
// 1818 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
// 1819 *
// 1820 *                       (1) "The strstr() function shall locate the first occurrence  in the string 
// 1821 *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string 
// 1822 *                            pointed to by 's2' ('pstr_srch')" ...
// 1823 *                       (2) "(excluding the terminating null byte)."
// 1824 *
// 1825 *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
// 1826 *
// 1827 *                       (1) "Upon successful completion, strstr() shall return" :
// 1828 *                           (A) "a pointer to the located string" ...
// 1829 *                           (B) "or a null pointer if the string is not found."
// 1830 *                               (1) #### Although NO strstr() specification states to return NULL for 
// 1831 *                                   any other reason(s), NULL is also returned for any error(s).
// 1832 *
// 1833 *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function 
// 1834 *                            shall return 's1' ('pstr')."
// 1835 *
// 1836 *               (3) String search terminates when :
// 1837 *
// 1838 *                   (a) String pointer(s) are passed NULL pointers.
// 1839 *                       (1) No string search performed; NULL pointer returned.
// 1840 *
// 1841 *                   (b) String pointer(s) point to NULL.
// 1842 *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
// 1843 *
// 1844 *                   (c) Search string length equal to zero.
// 1845 *                       (1) No string search performed; string pointer returned (see Note #2b2).
// 1846 *
// 1847 *                   (d) Search string length greater than string length.
// 1848 *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
// 1849 *
// 1850 *                   (e) Entire string has been searched.
// 1851 *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
// 1852 *                       (2) Maximum size of the search is defined as the subtraction of the
// 1853 *                           search string length from the string length.
// 1854 *
// 1855 *                   (f) Search string found.
// 1856 *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
// 1857 *                       (2) Search string found via Str_Cmp_N().
// 1858 *
// 1859 *                   (g) 'len_max' number of characters searched.
// 1860 *                       (1) 'len_max' number of characters does NOT include terminating NULL character
// 1861 *                           (see Note #2a2).
// 1862 *********************************************************************************************************
// 1863 */
// 1864 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1865 CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
Str_Str_N:
        CODE
// 1866                       const  CPU_CHAR    *pstr_srch,
// 1867                              CPU_SIZE_T   len_max)
// 1868 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V6,R2
        MOV     ?V7,R3
// 1869            CPU_SIZE_T    str_len;
// 1870            CPU_SIZE_T    str_len_srch;
// 1871            CPU_SIZE_T    len_max_srch;
// 1872            CPU_SIZE_T    srch_len;
// 1873            CPU_SIZE_T    srch_ix;
// 1874            CPU_BOOLEAN   srch_done;
// 1875            CPU_INT16S    srch_cmp;
// 1876     const  CPU_CHAR     *pstr_str;
// 1877     const  CPU_CHAR     *pstr_srch_ix;
// 1878 
// 1879                                                                 /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
// 1880     if (pstr == (const CPU_CHAR *)0) {
        MOV     A,?V6
        ORL     A,?V7
        JNZ     ??Str_Str_N_0
// 1881         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1882     }
// 1883     if (pstr_srch == (const CPU_CHAR *)0) {
??Str_Str_N_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Str_N_2
// 1884         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1885     }
??Str_Str_N_2:
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1886 
// 1887     if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
        MOV     A,R4
        ORL     A,R5
        JNZ     ??Str_Str_N_3
// 1888         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1889     }
// 1890 
// 1891                                                                 /* Lim max srch str len (to chk > str len).             */
// 1892     len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
// 1893                  ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
??Str_Str_N_3:
        MOV     A,#-0x1
        XRL     A,R4
        JNZ     ??Str_Str_N_4
        MOV     A,#-0x1
        XRL     A,R5
??Str_Str_N_4:
        JZ      ??Str_Str_N_5
        MOV     A,R4
        ADD     A,#0x1
        MOV     R6,A
        CLR     A
        ADDC    A,R5
        MOV     R7,A
        SJMP    ??Str_Str_N_6
??Str_Str_N_5:
        MOV     R6,#-0x1
        MOV     R7,#-0x1
// 1894 
// 1895     str_len      = Str_Len_N(pstr,      len_max);
??Str_Str_N_6:
        ; Setup parameters for call to function Str_Len_N
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   Str_Len_N
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,?V0
        MOV     ?V3,?V1
// 1896     str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
        ; Setup parameters for call to function Str_Len_N
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Str_Len_N
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     ?V0,?V4
        MOV     ?V1,?V5
// 1897     if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
        MOV     A,?V0
        ORL     A,?V1
        JNZ     ??Str_Str_N_7
// 1898         return ((CPU_CHAR *)pstr);
        MOV     R2,?V6
        MOV     R3,?V7
        LJMP    ??Str_Str_N_1
// 1899     }
// 1900     if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
??Str_Str_N_7:
        CLR     C
        MOV     A,?V2
        SUBB    A,?V0
        MOV     A,?V3
        SUBB    A,?V1
        JNC     ??Str_Str_N_8
// 1901         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1902     }
// 1903                                                                 /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
// 1904     pstr_str = pstr      + str_len;
??Str_Str_N_8:
        MOV     A,?V6
        ADD     A,?V2
        MOV     R0,A
        MOV     A,?V7
        ADDC    A,?V3
        MOV     R1,A
// 1905     if (pstr_str == (const CPU_CHAR *)0) {
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Str_N_9
// 1906         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1907     }
// 1908     pstr_str = pstr_srch + str_len_srch;
??Str_Str_N_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V1
        MOV     R1,A
// 1909     if (pstr_str == (const CPU_CHAR *)0) {
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_Str_N_10
// 1910         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_Str_N_1
// 1911     }
// 1912 
// 1913 
// 1914     srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
??Str_Str_N_10:
        MOV     A,?V2
        CLR     C
        SUBB    A,?V0
        MOV     R6,A
        MOV     A,?V3
        SUBB    A,?V1
        MOV     R7,A
// 1915     srch_ix   = 0u;
        MOV     ?V2,#0x0
        MOV     ?V3,#0x0
// 1916     srch_done = DEF_NO;
        MOV     R0,#0x0
// 1917 
// 1918     do {
// 1919         pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
??Str_Str_N_11:
        MOV     A,?V6
        ADD     A,?V2
        MOV     R0,A
        MOV     A,?V7
        ADDC    A,?V3
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1920         srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
        ; Setup parameters for call to function Str_Cmp_N
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   Str_Cmp_N
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     R2,?V4
        MOV     R3,?V5
// 1921         srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
        MOV     A,R2
        ORL     A,R3
        JNZ     ??Str_Str_N_12
        MOV     R0,#0x1
        SJMP    ??Str_Str_N_13
??Str_Str_N_12:
        MOV     R0,#0x0
// 1922         srch_ix++;
??Str_Str_N_13:
        INC     ?V2
        MOV     A,?V2
        JNZ     ??Str_Str_N_14
        INC     ?V3
// 1923     } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
??Str_Str_N_14:
        MOV     A,R0
        JNZ     ??Str_Str_N_15
        CLR     C
        MOV     A,R6
        SUBB    A,?V2
        MOV     A,R7
        SUBB    A,?V3
        JNC     ??Str_Str_N_11
// 1924 
// 1925 
// 1926     if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
??Str_Str_N_15:
        MOV     A,R2
        ORL     A,R3
        JZ      ??Str_Str_N_16
// 1927         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_Str_N_1
// 1928     }
// 1929 
// 1930     return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
??Str_Str_N_16:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
??Str_Str_N_1:
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 1931 }
// 1932 
// 1933 
// 1934 /*$PAGE*/
// 1935 /*
// 1936 *********************************************************************************************************
// 1937 *                                         Str_FmtNbr_Int32U()
// 1938 *
// 1939 * Description : Format 32-bit unsigned integer into a multi-digit character string.
// 1940 *
// 1941 * Argument(s) : nbr             Number           to format.
// 1942 *
// 1943 *               nbr_dig         Number of digits to format (see Note #1).
// 1944 *
// 1945 *                               The following may be used to specify the number of digits to format :
// 1946 *
// 1947 *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
// 1948 *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
// 1949 *
// 1950 *               nbr_base        Base   of number to format (see Note #2).
// 1951 *
// 1952 *                               The following may be used to specify the number base :
// 1953 *
// 1954 *                                   DEF_NBR_BASE_BIN            Base  2
// 1955 *                                   DEF_NBR_BASE_OCT            Base  8
// 1956 *                                   DEF_NBR_BASE_DEC            Base 10
// 1957 *                                   DEF_NBR_BASE_HEX            Base 16
// 1958 *
// 1959 *               lead_char       Prepend leading character  (see Note #3) :
// 1960 *
// 1961 *                                   '\0'                    Do NOT prepend leading character to string.
// 1962 *                                     Printable character          Prepend leading character to string.
// 1963 *                                   Unprintable character   Format invalid string (see Note #6).
// 1964 *
// 1965 *               lower_case      Format alphabetic characters (if any) in lower case :
// 1966 *
// 1967 *                                   DEF_NO          Format alphabetic characters in upper case.
// 1968 *                                   DEF_YES         Format alphabetic characters in lower case.
// 1969 *
// 1970 *               nul             Append terminating NULL-character (see Note #4) :
// 1971 *
// 1972 *                                   DEF_NO          Do NOT append terminating NULL-character to string.
// 1973 *                                   DEF_YES                Append terminating NULL-character to string.
// 1974 *
// 1975 *               pstr            Pointer to character array to return formatted number string (see Note #5).
// 1976 *
// 1977 * Return(s)   : Pointer to formatted string, if NO error(s).
// 1978 *
// 1979 *               Pointer to NULL,             otherwise.
// 1980 *
// 1981 * Caller(s)   : Application.
// 1982 *
// 1983 * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
// 1984 *                       is performed except possible NULL-termination of the string (see Note #4).
// 1985 *
// 1986 *                           Example :
// 1987 *
// 1988 *                               nbr      = 23456
// 1989 *                               nbr_dig  = 0
// 1990 *                               nbr_base = 10
// 1991 *
// 1992 *                               pstr     = ""                   See Note #6a
// 1993 *
// 1994 *                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
// 1995 *                       significant integer digits of the number to format ('nbr'); then an invalid 
// 1996 *                       string is formatted instead of truncating any significant integer digits.
// 1997 *
// 1998 *                           Example :
// 1999 *
// 2000 *                               nbr      = 23456
// 2001 *                               nbr_dig  = 3
// 2002 *                               nbr_base = 10
// 2003 *
// 2004 *                               pstr     = "???"                See Note #6b
// 2005 *
// 2006 *               (2) The number's base MUST be between 2 & 36, inclusive.
// 2007 *$PAGE*
// 2008 *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
// 2009 *
// 2010 *                   (a) (1) Leading character MUST be a printable ASCII character.
// 2011 *
// 2012 *                       (2) (A) Leading character MUST NOT be a number base digit, ...
// 2013 *                           (B) with the exception of '0'.
// 2014 *
// 2015 *                   (b) The number of leading characters is such that the total number of significant 
// 2016 *                       integer digits plus the number of leading characters is equal to the requested 
// 2017 *                       number of integer digits to format ('nbr_dig').
// 2018 *
// 2019 *                           Example :
// 2020 *
// 2021 *                               nbr       = 23456
// 2022 *                               nbr_dig   = 7
// 2023 *                               nbr_base  = 10
// 2024 *                               lead_char = ' '
// 2025 *
// 2026 *                               pstr      = "  23456"
// 2027 *
// 2028 *                   (c) (1) If the value of the number to format is     zero  ...
// 2029 *                       (2) ... & the number of digits to format is non-zero, ...
// 2030 *                       (3) ... but NO leading character available;           ...
// 2031 *                       (4) ... then one digit of '0' value is formatted.
// 2032 *
// 2033 *                           This is NOT a leading character; but a single integer digit of '0' value.
// 2034 *
// 2035 *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
// 2036 *                       array formatting.
// 2037 *
// 2038 *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
// 2039 *                       terminate option DISABLED will cause character string run-on.
// 2040 *
// 2041 *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
// 2042 *
// 2043 *                   (b) To prevent character buffer overrun :
// 2044 *
// 2045 *                           Character array size MUST be  >=  ('nbr_dig'          +
// 2046 *                                                               1 'NUL' terminator)  characters
// 2047 *
// 2048 *               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
// 2049 *                   ('?') will be formatted, where the number of question marks is determined by the 
// 2050 *                   number of digits to format ('nbr_dig') :
// 2051 *
// 2052 *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
// 2053 *                          number of     =  {
// 2054 *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
// 2055 *
// 2056 *********************************************************************************************************
// 2057 */
// 2058 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2059 CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
Str_FmtNbr_Int32U:
        CODE
// 2060                               CPU_INT08U    nbr_dig,
// 2061                               CPU_INT08U    nbr_base,
// 2062                               CPU_CHAR      lead_char,
// 2063                               CPU_BOOLEAN   lower_case,
// 2064                               CPU_BOOLEAN   nul,
// 2065                               CPU_CHAR     *pstr)
// 2066 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        MOV     A,#-0xc
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,R4
        MOV     ?V3,R5
        MOV     A,R1
        MOV     R6,A
// 2067     CPU_CHAR  *pstr_fmt;
// 2068 
// 2069 
// 2070     pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
// 2071                                 nbr_dig,
// 2072                                 nbr_base,
// 2073                                 DEF_NO,
// 2074                                 lead_char,
// 2075                                 lower_case,
// 2076                                 nul,
// 2077                                 pstr);
        ; Setup parameters for call to function Str_FmtNbr_Int32
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     ?V4,#0x0
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        MOV     R1,A
        MOV     R2,?V0
        MOV     R3,?V1
        MOV     R4,?V2
        MOV     R5,?V3
        LCALL   Str_FmtNbr_Int32
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 2078 
// 2079     return (pstr_fmt);
        MOV     R7,#0x5
        LJMP    ?FUNC_LEAVE_XDATA
// 2080 }
// 2081 
// 2082 
// 2083 /*$PAGE*/
// 2084 /*
// 2085 *********************************************************************************************************
// 2086 *                                         Str_FmtNbr_Int32S()
// 2087 *
// 2088 * Description : Format 32-bit signed integer into a multi-digit character string.
// 2089 *
// 2090 * Argument(s) : nbr             Number           to format.
// 2091 *
// 2092 *               nbr_dig         Number of digits to format (see Note #1).
// 2093 *
// 2094 *                               The following may be used to specify the number of digits to format :
// 2095 *
// 2096 *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
// 2097 *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
// 2098 *                                                                   (plus 1 digit for possible negative sign)
// 2099 *
// 2100 *               nbr_base        Base   of number to format (see Note #2).
// 2101 *
// 2102 *                               The following may be used to specify the number base :
// 2103 *
// 2104 *                                   DEF_NBR_BASE_BIN            Base  2
// 2105 *                                   DEF_NBR_BASE_OCT            Base  8
// 2106 *                                   DEF_NBR_BASE_DEC            Base 10
// 2107 *                                   DEF_NBR_BASE_HEX            Base 16
// 2108 *
// 2109 *               lead_char       Prepend leading character  (see Note #3) :
// 2110 *
// 2111 *                                   '\0'                    Do NOT prepend leading character to string.
// 2112 *                                     Printable character          Prepend leading character to string.
// 2113 *                                   Unprintable character   Format invalid string (see Note #6).
// 2114 *
// 2115 *               lower_case      Format alphabetic characters (if any) in lower case :
// 2116 *
// 2117 *                                   DEF_NO          Format alphabetic characters in upper case.
// 2118 *                                   DEF_YES         Format alphabetic characters in lower case.
// 2119 *
// 2120 *               nul             Append terminating NULL-character (see Note #4) :
// 2121 *
// 2122 *                                   DEF_NO          Do NOT append terminating NULL-character to string.
// 2123 *                                   DEF_YES                Append terminating NULL-character to string.
// 2124 *
// 2125 *               pstr            Pointer to character array to return formatted number string (see Note #5).
// 2126 *
// 2127 * Return(s)   : Pointer to formatted string, if NO error(s).
// 2128 *
// 2129 *               Pointer to NULL,             otherwise.
// 2130 *
// 2131 * Caller(s)   : Application.
// 2132 *
// 2133 * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
// 2134 *                       is performed except possible NULL-termination of the string (see Note #4).
// 2135 *
// 2136 *                           Example :
// 2137 *
// 2138 *                               nbr      = -23456
// 2139 *                               nbr_dig  =  0
// 2140 *                               nbr_base = 10
// 2141 *
// 2142 *                               pstr     = ""                   See Note #6a
// 2143 *
// 2144 *                   (b) If the number of digits to format ('nbr_dig') is less than the number of 
// 2145 *                       significant integer digits of the number to format ('nbr'); then an invalid 
// 2146 *                       string is formatted instead of truncating any significant integer digits.
// 2147 *
// 2148 *                           Example :
// 2149 *
// 2150 *                               nbr      = 23456
// 2151 *                               nbr_dig  = 3
// 2152 *                               nbr_base = 10
// 2153 *
// 2154 *                               pstr     = "???"                See Note #6b
// 2155 *
// 2156 *                   (c) If the number to format ('nbr') is negative but the number of digits to format 
// 2157 *                       ('nbr_dig') is equal to the number of significant integer digits of the number 
// 2158 *                       to format ('nbr'); then an invalid string is formatted instead of truncating 
// 2159 *                       the negative sign.
// 2160 *
// 2161 *                           Example :
// 2162 *
// 2163 *                               nbr      = -23456
// 2164 *                               nbr_dig  =  5
// 2165 *                               nbr_base = 10
// 2166 *
// 2167 *                               pstr     = "?????"              See Note #6b
// 2168 *
// 2169 *               (2) The number's base MUST be between 2 & 36, inclusive.
// 2170 *$PAGE*
// 2171 *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
// 2172 *
// 2173 *                   (a) (1) Leading character MUST be a printable ASCII character.
// 2174 *
// 2175 *                       (2) (A) Leading character MUST NOT be a number base digit, ...
// 2176 *                           (B) with the exception of '0'.
// 2177 *
// 2178 *                   (b) (1) The number of leading characters is such that the total number of significant 
// 2179 *                           integer digits plus the number of leading characters plus possible negative 
// 2180 *                           sign character is equal to the requested number of integer digits to format 
// 2181 *                           ('nbr_dig').
// 2182 *
// 2183 *                               Examples :
// 2184 *
// 2185 *                                   nbr       = 23456
// 2186 *                                   nbr_dig   = 7
// 2187 *                                   nbr_base  = 10
// 2188 *                                   lead_char = ' '
// 2189 *
// 2190 *                                   pstr      = "  23456"
// 2191 *
// 2192 *
// 2193 *                                   nbr       = -23456
// 2194 *                                   nbr_dig   =  7
// 2195 *                                   nbr_base  = 10
// 2196 *                                   lead_char = ' '
// 2197 *
// 2198 *                                   pstr      = " -23456"
// 2199 *
// 2200 *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
// 2201 *                               ('lead_char') is     a '0' digit; then the negative sign character 
// 2202 *                               prefixes all leading characters prior to the formatted number.
// 2203 *
// 2204 *                                   Examples :
// 2205 *
// 2206 *                                       nbr        = -23456
// 2207 *                                       nbr_dig    =  8
// 2208 *                                       nbr_base   = 10
// 2209 *                                       lead_char  = '0'
// 2210 *
// 2211 *                                       pstr       = "-0023456"
// 2212 *
// 2213 *
// 2214 *                                       nbr        = -43981
// 2215 *                                       nbr_dig    =  8
// 2216 *                                       nbr_base   = 16
// 2217 *                                       lead_char  = '0'
// 2218 *                                       lower_case = DEF_NO
// 2219 *
// 2220 *                                       pstr       = "-000ABCD"
// 2221 *
// 2222 *                           (B) If the number to format ('nbr') is negative AND the leading character 
// 2223 *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
// 2224 *                               immediately prefixes the most significant digit of the formatted number.
// 2225 *
// 2226 *                                   Examples :
// 2227 *
// 2228 *                                       nbr        = -23456
// 2229 *                                       nbr_dig    =  8
// 2230 *                                       nbr_base   = 10
// 2231 *                                       lead_char  = '#'
// 2232 *
// 2233 *                                       pstr       = "##-23456"
// 2234 *
// 2235 *
// 2236 *                                       nbr        = -43981
// 2237 *                                       nbr_dig    =  8
// 2238 *                                       nbr_base   = 16
// 2239 *                                       lead_char  = '#'
// 2240 *                                       lower_case = DEF_YES
// 2241 *
// 2242 *                                       pstr       = "###-abcd"
// 2243 *
// 2244 *                   (c) (1) If the value of the number to format is     zero  ...
// 2245 *                       (2) ... & the number of digits to format is non-zero, ...
// 2246 *                       (3) ... but NO leading character available;           ...
// 2247 *                       (4) ... then one digit of '0' value is formatted.
// 2248 *
// 2249 *                           This is NOT a leading character; but a single integer digit of '0' value.
// 2250 *$PAGE*
// 2251 *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
// 2252 *                       array formatting.
// 2253 *
// 2254 *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
// 2255 *                       terminate option DISABLED will cause character string run-on.
// 2256 *
// 2257 *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
// 2258 *
// 2259 *                   (b) To prevent character buffer overrun :
// 2260 *
// 2261 *                           Character array size MUST be  >=  ('nbr_dig'          +
// 2262 *                                                               1 negative sign   +
// 2263 *                                                               1 'NUL' terminator)  characters
// 2264 *
// 2265 *               (6) For any unsuccessful string format or error(s), an invalid string of question marks 
// 2266 *                   ('?') will be formatted, where the number of question marks is determined by the 
// 2267 *                   number of digits to format ('nbr_dig') :
// 2268 *
// 2269 *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
// 2270 *                          number of     =  {
// 2271 *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
// 2272 *
// 2273 *********************************************************************************************************
// 2274 */
// 2275 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2276 CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
Str_FmtNbr_Int32S:
        CODE
// 2277                               CPU_INT08U    nbr_dig,
// 2278                               CPU_INT08U    nbr_base,
// 2279                               CPU_CHAR      lead_char,
// 2280                               CPU_BOOLEAN   lower_case,
// 2281                               CPU_BOOLEAN   nul,
// 2282                               CPU_CHAR     *pstr)
// 2283 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,R4
        MOV     ?V3,R5
        MOV     A,R1
        MOV     R6,A
// 2284     CPU_CHAR     *pstr_fmt;
// 2285     CPU_INT32S    nbr_fmt;
// 2286     CPU_BOOLEAN   nbr_neg;
// 2287 
// 2288 
// 2289     if (nbr < 0) {                                              /* If nbr neg, ...                                      */
        MOV     DPTR,#__Constant_0
        MOV     R0,#?V0
        LCALL   ?SL_GE_X
        JC      ??Str_FmtNbr_Int32S_0
// 2290         nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
        MOV     R0,#?V0
        LCALL   ?L_NEG
        MOV     ?V4,?V0
        MOV     ?V5,?V1
        MOV     ?V6,?V2
        MOV     ?V7,?V3
// 2291         nbr_neg =  DEF_YES;
        MOV     R1,#0x1
        SJMP    ??Str_FmtNbr_Int32S_1
// 2292     } else {
// 2293         nbr_fmt =  nbr;
??Str_FmtNbr_Int32S_0:
        MOV     ?V4,?V0
        MOV     ?V5,?V1
        MOV     ?V6,?V2
        MOV     ?V7,?V3
// 2294         nbr_neg =  DEF_NO;
        MOV     R1,#0x0
// 2295     }
// 2296 
// 2297     pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
// 2298                                             nbr_dig,
// 2299                                             nbr_base,
// 2300                                             nbr_neg,
// 2301                                             lead_char,
// 2302                                             lower_case,
// 2303                                             nul,
// 2304                                             pstr);
??Str_FmtNbr_Int32S_1:
        ; Setup parameters for call to function Str_FmtNbr_Int32
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R1
        MOV     ?V0,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        MOV     R1,A
        MOV     R2,?V4
        MOV     R3,?V5
        MOV     R4,?V6
        MOV     R5,?V7
        LCALL   Str_FmtNbr_Int32
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R2,?V0
        MOV     R3,?V1
// 2305 
// 2306     return (pstr_fmt);
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 2307 }
// 2308 
// 2309 
// 2310 /*$PAGE*/
// 2311 /*
// 2312 *********************************************************************************************************
// 2313 *                                           Str_FmtNbr_32()
// 2314 *
// 2315 * Description : Format number into a multi-digit character string.
// 2316 *
// 2317 * Argument(s) : nbr             Number                         to format (see Note #1).
// 2318 *
// 2319 *               nbr_dig         Number of decimal       digits to format (see Note #2).
// 2320 *
// 2321 *               nbr_dp          Number of decimal point digits to format.
// 2322 *
// 2323 *               lead_char       Prepend leading character (see Note #3) :
// 2324 *
// 2325 *                                   '\0'                    Do NOT prepend leading character to string.
// 2326 *                                     Printable character          Prepend leading character to string.
// 2327 *                                   Unprintable character   Format invalid string (see Note #6d).
// 2328 *
// 2329 *               nul             Append terminating NULL-character (see Note #4) :
// 2330 *
// 2331 *                                   DEF_NO          Do NOT append terminating NULL-character to string.
// 2332 *                                   DEF_YES                Append terminating NULL-character to string.
// 2333 *
// 2334 *               pstr            Pointer to character array to return formatted number string (see Note #5).
// 2335 *
// 2336 * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
// 2337 *
// 2338 *               Pointer to NULL,             otherwise.
// 2339 *
// 2340 * Caller(s)   : Application.
// 2341 *
// 2342 * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
// 2343 *
// 2344 *
// 2345 *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
// 2346 *                           32-bit Floating-point Number  =  -----------------------------------------------------
// 2347 *                                                                             log [External-Base]
// 2348 *
// 2349 *                                                             log [2 ^ 24]
// 2350 *                                                         =  --------------
// 2351 *                                                               log [10]
// 2352 *
// 2353 *                                                         <  7.225  Base-10 Digits
// 2354 *
// 2355 *                               where
// 2356 *                                       Internal-Base                   Internal number base of floating-
// 2357 *                                                                           point numbers (i.e.  2)
// 2358 *                                       External-Base                   External number base of floating-
// 2359 *                                                                           point numbers (i.e. 10)
// 2360 *                                       Number-Internal-Base-Digits     Number of internal number base
// 2361 *                                                                           significant digits (i.e. 24)
// 2362 *
// 2363 *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the 
// 2364 *                       maximum accuracy.
// 2365 *$PAGE*
// 2366 *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO 
// 2367 *                       formatting is performed except possible NULL-termination of the string (see Note #4).
// 2368 *
// 2369 *                           Example :
// 2370 *
// 2371 *                               nbr     = -23456.789
// 2372 *                               nbr_dig =  0
// 2373 *                               nbr_dp  =  0
// 2374 *
// 2375 *                               pstr    = ""                        See Note #7a
// 2376 *
// 2377 *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of 
// 2378 *                           significant integer digits of the number to format ('nbr'); then an invalid 
// 2379 *                           string is formatted instead of truncating any significant integer digits.
// 2380 *
// 2381 *                               Example :
// 2382 *
// 2383 *                                   nbr     = 23456.789
// 2384 *                                   nbr_dig = 3
// 2385 *                                   nbr_dp  = 2
// 2386 *
// 2387 *                                   pstr    = "??????"              See Note #7d
// 2388 *
// 2389 *                       (2) If the number to format ('nbr') is negative but the number of digits to format 
// 2390 *                           ('nbr_dig') is equal to the number of significant integer digits of the number 
// 2391 *                           to format ('nbr'); then an invalid string is formatted instead of truncating 
// 2392 *                           the negative sign.
// 2393 *
// 2394 *                               Example :
// 2395 *
// 2396 *                                   nbr     = -23456.789
// 2397 *                                   nbr_dig =  5
// 2398 *                                   nbr_dp  =  2
// 2399 *
// 2400 *                                   pstr    = "????????"            See Note #7d
// 2401 *
// 2402 *                       (3) If the number to format ('nbr') is negative but the number of significant 
// 2403 *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one 
// 2404 *                           but the number of decimal point digits to format ('nbr_dp') is zero; then 
// 2405 *                           an invalid string is formatted instead of truncating the negative sign.
// 2406 *
// 2407 *                               Example :
// 2408 *
// 2409 *                                   nbr     = -0.7895
// 2410 *                                   nbr_dig =  1
// 2411 *                                   nbr_dp  =  0
// 2412 *
// 2413 *                                   pstr    = "?"                   See Note #7d
// 2414 *
// 2415 *                       (4) (A) If the number to format ('nbr') is negative but the number of significant 
// 2416 *                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
// 2417 *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
// 2418 *                               zero; then the negative sign immediately prefixes the decimal point -- 
// 2419 *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
// 2420 *
// 2421 *                                   Example :
// 2422 *
// 2423 *                                       nbr     = -0.7895
// 2424 *                                       nbr_dig =  0
// 2425 *                                       nbr_dp  =  2
// 2426 *
// 2427 *                                       pstr    = "-.78"
// 2428 *
// 2429 *                           (B) If the number to format ('nbr') is positive but the number of significant 
// 2430 *                               integer digits is zero, & the number of digits to format ('nbr_dig') is 
// 2431 *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
// 2432 *                               zero; then a single decimal digit of '0' prefixes the decimal point.
// 2433 *
// 2434 *                               This '0' digit is used whenever a negative sign is not formatted (see 
// 2435 *                               Note #2b4A) so that the formatted string's decimal point is not floating, 
// 2436 *                               but fixed in the string as the 2nd character.
// 2437 *
// 2438 *                                   Example :
// 2439 *
// 2440 *                                       nbr     =  0.7895
// 2441 *                                       nbr_dig =  0
// 2442 *                                       nbr_dp  =  2
// 2443 *
// 2444 *                                       pstr    = "0.78"
// 2445 *$PAGE*
// 2446 *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
// 2447 *
// 2448 *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point 
// 2449 *                               numbers, digits following all significantly-accurate digits of the number to 
// 2450 *                               format ('nbr') will be inaccurate; ...
// 2451 *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all 
// 2452 *                               digits or decimal places following all significantly-accurate digits of the 
// 2453 *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
// 2454 *
// 2455 *                                   Example :
// 2456 *
// 2457 *                                       nbr                            = 123456789.012345
// 2458 *                                       nbr_dig                        = 9
// 2459 *                                       nbr_dp                         = 6
// 2460 *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
// 2461 *
// 2462 *                                       pstr                           = "123456700.000000"
// 2463 *
// 2464 *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr') 
// 2465 *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's 
// 2466 *                           &/or compiler's floating-point implementation.
// 2467 *
// 2468 *                       See also Note #1.
// 2469 *
// 2470 *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
// 2471 *
// 2472 *                   (a) (1) Leading character MUST be a printable ASCII character.
// 2473 *
// 2474 *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
// 2475 *                           (B) with the exception of '0'.
// 2476 *
// 2477 *                   (b) (1) The number of leading characters is such that the total number of significant 
// 2478 *                           integer digits plus the number of leading characters plus possible negative 
// 2479 *                           sign character is equal to the requested number of integer digits to format 
// 2480 *                           ('nbr_dig').
// 2481 *
// 2482 *                               Examples :
// 2483 *
// 2484 *                                   nbr       = 23456.789
// 2485 *                                   nbr_dig   = 7
// 2486 *                                   nbr_dp    = 2
// 2487 *                                   lead_char = ' '
// 2488 *
// 2489 *                                   pstr      = "  23456.78"
// 2490 *
// 2491 *
// 2492 *                                   nbr       = -23456.789
// 2493 *                                   nbr_dig   =  7
// 2494 *                                   nbr_dp    =  2
// 2495 *                                   lead_char = ' '
// 2496 *
// 2497 *                                   pstr      = " -23456.78"
// 2498 *
// 2499 *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
// 2500 *                               ('lead_char') is     a '0' digit; then the negative sign character 
// 2501 *                               prefixes all leading characters prior to the formatted number.
// 2502 *
// 2503 *                                   Example :
// 2504 *
// 2505 *                                       nbr       = -23456.789
// 2506 *                                       nbr_dig   =  8
// 2507 *                                       nbr_dp    =  2
// 2508 *                                       lead_char = '0'
// 2509 *
// 2510 *                                       pstr      = "-0023456.78"
// 2511 *
// 2512 *                           (B) If the number to format ('nbr') is negative AND the leading character 
// 2513 *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
// 2514 *                               immediately prefixes the most significant digit of the formatted number.
// 2515 *
// 2516 *                                   Examples :
// 2517 *
// 2518 *                                       nbr       = -23456.789
// 2519 *                                       nbr_dig   =  8
// 2520 *                                       nbr_dp    =  2
// 2521 *                                       lead_char = '#'
// 2522 *
// 2523 *                                       pstr      = "##-23456.78"
// 2524 *
// 2525 *                   (c) (1) If the integer value of the number to format is zero & ...
// 2526 *                       (2) ... the number of digits to format is greater than one ...
// 2527 *                       (3) ... OR  the number is NOT negative,                    ...
// 2528 *                       (4) ... but NO leading character available;                ...
// 2529 *                       (5) ... then one digit of '0' value is formatted.
// 2530 *
// 2531 *                           This is NOT a leading character; but a single integer digit of '0' value.
// 2532 *
// 2533 *                       See also Note #2b4B.
// 2534 *$PAGE*
// 2535 *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
// 2536 *                       array formatting.
// 2537 *
// 2538 *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
// 2539 *                       terminate option DISABLED will cause character string run-on.
// 2540 *
// 2541 *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
// 2542 *
// 2543 *                   (b) To prevent character buffer overrun :
// 2544 *
// 2545 *                           Character array size MUST be  >=  ('nbr_dig'          +
// 2546 *                                                              'nbr_dp'           +
// 2547 *                                                               1 negative sign   +
// 2548 *                                                               1 decimal point   +
// 2549 *                                                               1 'NUL' terminator)  characters
// 2550 *
// 2551 *               (6) String format terminates when :
// 2552 *
// 2553 *                   (a) Format string pointer is passed a NULL pointer.
// 2554 *                       (1) No      string formatted;                NULL pointer returned.
// 2555 *
// 2556 *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
// 2557 *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
// 2558 *
// 2559 *                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
// 2560 *                           integer digits of the number to format ('nbr'), including possible 
// 2561 *                           negative sign.
// 2562 *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
// 2563 *
// 2564 *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
// 2565 *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
// 2566 *
// 2567 *                   (e) Number successfully formatted into character string array.
// 2568 *
// 2569 *               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
// 2570 *                   ('?') will be formatted, where the number of question marks is determined by the 
// 2571 *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
// 2572 *
// 2573 *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
// 2574 *                                           {                                        'nbr_dp'  = 0
// 2575 *                                           {
// 2576 *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
// 2577 *                                           {                                        'nbr_dp'  = 0
// 2578 *                      Invalid string's     {
// 2579 *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
// 2580 *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
// 2581 *                                           {         1 (for negative sign) ]
// 2582 *                                           {
// 2583 *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
// 2584 *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
// 2585 *                                           {         1 (for decimal point) ]
// 2586 *
// 2587 *********************************************************************************************************
// 2588 */
// 2589 
// 2590 #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
// 2591 CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
// 2592                           CPU_INT08U    nbr_dig,
// 2593                           CPU_INT08U    nbr_dp,
// 2594                           CPU_CHAR      lead_char,
// 2595                           CPU_BOOLEAN   nul,
// 2596                           CPU_CHAR     *pstr)
// 2597 {
// 2598     CPU_CHAR     *pstr_fmt;
// 2599     CPU_DATA      i;
// 2600     CPU_FP32      nbr_fmt;
// 2601     CPU_FP32      nbr_log;
// 2602     CPU_INT32U    nbr_shiftd;
// 2603     CPU_INT16U    nbr_dig_max;
// 2604     CPU_INT16U    nbr_dig_sig;
// 2605     CPU_INT08U    nbr_neg_sign;
// 2606     CPU_INT08U    dig_val;
// 2607     CPU_FP32      dig_exp;
// 2608     CPU_FP32      dp_exp;
// 2609     CPU_BOOLEAN   lead_char_dig;
// 2610     CPU_BOOLEAN   lead_char_fmtd;
// 2611     CPU_BOOLEAN   lead_char_0;
// 2612     CPU_BOOLEAN   fmt_invalid;
// 2613     CPU_BOOLEAN   print_char;
// 2614     CPU_BOOLEAN   nbr_neg;
// 2615     CPU_BOOLEAN   nbr_neg_fmtd;
// 2616 
// 2617 
// 2618 /*$PAGE*/
// 2619                                                                 /* ---------------- VALIDATE FMT ARGS ----------------- */
// 2620     if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
// 2621         return ((CPU_CHAR *)0);
// 2622     }
// 2623 
// 2624     fmt_invalid = DEF_NO;
// 2625 
// 2626     if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
// 2627         fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
// 2628     }
// 2629 
// 2630     if (lead_char != (CPU_CHAR)'\0') {
// 2631         print_char =  ASCII_IsPrint(lead_char);
// 2632         if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
// 2633             fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
// 2634 
// 2635         } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
// 2636             lead_char_dig = ASCII_IsDig(lead_char);
// 2637             if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
// 2638                 fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
// 2639             }
// 2640         }
// 2641     }
// 2642 
// 2643 
// 2644                                                                 /* ----------------- PREPARE NBR FMT ------------------ */
// 2645     pstr_fmt = pstr;
// 2646 
// 2647     if (fmt_invalid == DEF_NO) {
// 2648         if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
// 2649             nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
// 2650             nbr_neg_sign =  1u;
// 2651             nbr_neg      =  DEF_YES;
// 2652         } else {
// 2653             nbr_fmt      =  nbr;
// 2654             nbr_neg_sign =  0u;
// 2655             nbr_neg      =  DEF_NO;
// 2656         }
// 2657 
// 2658         nbr_log     = nbr_fmt;
// 2659         nbr_dig_max = 0u;
// 2660         while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
// 2661             nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
// 2662             nbr_log /= 10.0f;
// 2663         }
// 2664 
// 2665         if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
// 2666              (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
// 2667             ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
// 2668              (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
// 2669              (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
// 2670                                                                 /* .. prepare nbr digs to fmt.                          */
// 2671             dig_exp = 1.0f;
// 2672             for (i = 1u; i < nbr_dig; i++) {
// 2673                 dig_exp *= 10.0f;
// 2674             }
// 2675 
// 2676             nbr_neg_fmtd   =  DEF_NO;
// 2677             nbr_dig_sig    =  0u;
// 2678             lead_char_fmtd =  DEF_NO;
// 2679             lead_char_0    = (lead_char == '0')                 /* Chk if lead char a '0' dig (see Note #3b2).          */
// 2680                            ?  DEF_YES : DEF_NO;
// 2681 
// 2682         } else {                                                /* Else if nbr trunc'd, ...                             */
// 2683             fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
// 2684         }
// 2685     }
// 2686 
// 2687 
// 2688 /*$PAGE*/
// 2689                                                                 /* ------------------- FMT NBR STR -------------------- */
// 2690     for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
// 2691         if (fmt_invalid == DEF_NO) {
// 2692             if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
// 2693                 nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
// 2694                 if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
// 2695                     (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
// 2696                                                                 /* ... calc & fmt dig val;                     ...      */
// 2697                     if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
// 2698                         (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
// 2699 
// 2700                         if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
// 2701                             pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
// 2702                         }
// 2703                        *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
// 2704                         nbr_neg_fmtd = DEF_YES;
// 2705                     }
// 2706 
// 2707                     if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
// 2708                         dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
// 2709                        *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
// 2710 
// 2711                         nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
// 2712 
// 2713                     } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
// 2714                                (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
// 2715                        *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
// 2716                     }
// 2717 
// 2718                 } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
// 2719                            (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
// 2720                            (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
// 2721 
// 2722                    *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
// 2723                     nbr_neg_fmtd = DEF_YES;
// 2724 
// 2725                 } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
// 2726                    *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
// 2727                     lead_char_fmtd = DEF_YES;
// 2728                 }
// 2729 
// 2730                 dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
// 2731 
// 2732             } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
// 2733                *pstr_fmt++ = '0';
// 2734             }
// 2735 
// 2736         } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
// 2737            *pstr_fmt++ = '?';
// 2738         }
// 2739     }
// 2740 
// 2741 
// 2742 /*$PAGE*/
// 2743     if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
// 2744         if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
// 2745             if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
// 2746                 if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
// 2747                     (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
// 2748                     *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
// 2749                 } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
// 2750                     *pstr_fmt++ = '0';
// 2751                 }
// 2752             } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
// 2753                 *pstr_fmt++ = '?';
// 2754             }
// 2755         }
// 2756 
// 2757         if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
// 2758            *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
// 2759         } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
// 2760            *pstr_fmt++ = '?';
// 2761         }
// 2762 
// 2763         dp_exp = 10.0f;
// 2764         for (i = 0u; i < nbr_dp; i++) {
// 2765             if (fmt_invalid == DEF_NO) {
// 2766                                                                 /* If nbr sig digs < max, fmt str dps;    ...           */
// 2767                 if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
// 2768                     nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
// 2769                     dig_val     = (CPU_INT32U)(nbr_shiftd % 10u);
// 2770                    *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
// 2771                     dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
// 2772 
// 2773                     if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
// 2774                         (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
// 2775                          nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
// 2776                     }
// 2777 
// 2778                 } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
// 2779                    *pstr_fmt++ = '0';
// 2780                 }
// 2781 
// 2782             } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
// 2783                *pstr_fmt++ = '?';
// 2784             }
// 2785         }
// 2786     }
// 2787 
// 2788 
// 2789     if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
// 2790        *pstr_fmt = (CPU_CHAR)'\0';
// 2791     }
// 2792 
// 2793 
// 2794     if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
// 2795         return ((CPU_CHAR *)0);
// 2796     }
// 2797 
// 2798 
// 2799     return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
// 2800 }
// 2801 #endif
// 2802 
// 2803 
// 2804 /*$PAGE*/
// 2805 /*
// 2806 *********************************************************************************************************
// 2807 *                                        Str_ParseNbr_Int32U()
// 2808 *
// 2809 * Description : Parse 32-bit unsigned integer from string.
// 2810 *
// 2811 * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
// 2812 *
// 2813 *               pstr_next   Optional pointer to a variable to ... :
// 2814 *
// 2815 *                               (a) Return a pointer to first character following the integer string,
// 2816 *                                       if NO error(s) [see Note #2a2B2];
// 2817 *                               (b) Return a pointer to 'pstr',
// 2818 *                                       otherwise      (see Note #2a2A2).
// 2819 *
// 2820 *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
// 2821 *
// 2822 * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
// 2823 *
// 2824 *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
// 2825 *
// 2826 *               0,                   otherwise                            (see Note #2a3B).
// 2827 *
// 2828 * Caller(s)   : Application.
// 2829 *
// 2830 * Note(s)     : (1) String buffer NOT modified.
// 2831 *
// 2832 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
// 2833 *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
// 2834 *                       to a type unsigned long ... representation" :
// 2835 *
// 2836 *                       (1) "First, they decompose the input string into three parts" :
// 2837 *
// 2838 *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
// 2839 *                                by isspace()]."
// 2840 *
// 2841 *                               (1) "The subject sequence is defined as the longest initial subsequence of the
// 2842 *                                    input string, starting with the first non-white-space character that is of
// 2843 *                                    the expected form.  The subject sequence shall contain no characters if the
// 2844 *                                    input string is empty or consists entirely of white-space characters."
// 2845 *
// 2846 *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
// 2847 *                                    determined by the value of 'base' ('nbr_base')" :
// 2848 *
// 2849 *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
// 2850 *                                        subject sequence is that of a decimal constant, octal constant, or 
// 2851 *                                        hexadecimal constant" :
// 2852 *
// 2853 *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
// 2854 *                                            sequence of decimal digits."
// 2855 *
// 2856 *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
// 2857 *                                            a sequence of the digits '0' to '7' only."
// 2858 *
// 2859 *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
// 2860 *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
// 2861 *                                            (or 'F') with values 10 to 15 respectively."
// 2862 *
// 2863 *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
// 2864 *                                        of the subject sequence is a sequence of letters and digits representing 
// 2865 *                                        an integer with the radix specified by 'base' ('nbr_base')" :
// 2866 *
// 2867 *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
// 2868 *                                                ascribed the values 10 to 35"; ...
// 2869 *                                           (B) "only letters whose ascribed values are less than that of base
// 2870 *                                                are permitted."
// 2871 *
// 2872 *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
// 2873 *                                                '0X' may optionally precede the sequence of letters and digits."
// 2874 *
// 2875 *                                           (B) Although NO specification states that "if the value of 'base' 
// 2876 *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
// 2877 *                                               the sequence of letters and digits"; it seems reasonable to 
// 2878 *                                               allow the '0' character to be optionally parsed.
// 2879 *
// 2880 *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
// 2881 *
// 2882 *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
// 2883 *                                       integer string into an unsigned integer.
// 2884 *
// 2885 *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
// 2886 *                                   (b) "including the terminating null byte of the input string" ...
// 2887 *                               (2) "other than a sign or a permissible letter or digit."
// 2888 *$PAGE*
// 2889 *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
// 2890 *
// 2891 *                           (A) "If the subject sequence is empty or does not have the expected form" :
// 2892 *
// 2893 *                               (1) "no conversion [is] performed"; ...
// 2894 *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr' 
// 2895 *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
// 2896 *
// 2897 *                           (B) "If the subject sequence has the expected form" :
// 2898 *
// 2899 *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
// 2900 *                                        starting with the first digit shall be interpreted as an integer constant."
// 2901 *
// 2902 *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
// 2903 *                                        used as the base for conversion, ascribing to each letter its value as 
// 2904 *                                        given above" (see Note #2a1B1b1A).
// 2905 *
// 2906 *                               (2) "A pointer to the final string shall be stored in the object pointed to by
// 2907 *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
// 2908 *                                   pointer."
// 2909 *
// 2910 *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
// 2911 *
// 2912 *                           (A) "Upon successful completion, these functions shall return the converted value."
// 2913 *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
// 2914 *                                    ... shall be returned."
// 2915 *
// 2916 *                           (B) "If no conversion could be performed, 0 shall be returned."
// 2917 *
// 2918 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 2919 *                           shall fail if" :
// 2920 *
// 2921 *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
// 2922 *
// 2923 *                           (B) "[ERANGE] - The value to be returned is not representable."
// 2924 *
// 2925 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 2926 *                           may fail if" :
// 2927 *
// 2928 *                           (A) "[EINVAL] - No conversion could be performed."
// 2929 *
// 2930 *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
// 2931 *
// 2932 *                   (a) Valid parse string integer :
// 2933 *
// 2934 *                           pstr      = "     ABCDE xyz"
// 2935 *                           nbr_base  = 16
// 2936 *
// 2937 *                           nbr       = 703710
// 2938 *                           pstr_next = " xyz"
// 2939 *
// 2940 *
// 2941 *                   (b) Invalid parse string integer :
// 2942 *
// 2943 *                           pstr      = "     ABCDE"
// 2944 *                           nbr_base  = 10
// 2945 *
// 2946 *                           nbr       =  0
// 2947 *                           pstr_next = pstr = "     ABCDE"
// 2948 *
// 2949 *
// 2950 *                   (c) Valid hexadecimal parse string integer :
// 2951 *
// 2952 *                           pstr      = "     0xGABCDE"
// 2953 *                           nbr_base  = 16
// 2954 *
// 2955 *                           nbr       =  0
// 2956 *                           pstr_next = "xGABCDE"
// 2957 *
// 2958 *
// 2959 *                   (d) Valid decimal parse string integer ('0x' prefix ignored
// 2960 *                               following invalid hexadecimal characters) :
// 2961 *
// 2962 *                           pstr      = "     0xGABCDE"
// 2963 *                           nbr_base  =  0
// 2964 *
// 2965 *                           nbr       =  0
// 2966 *                           pstr_next = "xGABCDE"
// 2967 *
// 2968 *
// 2969 *                   (e) Valid decimal parse string integer ('0'  prefix ignored
// 2970 *                               following invalid octal       characters) :
// 2971 *
// 2972 *                           pstr      = "     0GABCDE"
// 2973 *                           nbr_base  =  0
// 2974 *
// 2975 *                           nbr       =  0
// 2976 *                           pstr_next = "GABCDE"
// 2977 *
// 2978 *$PAGE*
// 2979 *                   (f) Parse string integer overflow :
// 2980 *
// 2981 *                           pstr      = "   12345678901234567890*123456"
// 2982 *                           nbr_base  = 10
// 2983 *
// 2984 *                           nbr       = DEF_INT_32U_MAX_VAL
// 2985 *                           pstr_next = "*123456"
// 2986 *
// 2987 *
// 2988 *                   (g) Invalid negative unsigned parse string :
// 2989 *
// 2990 *                           pstr      = "  -12345678901234567890*123456"
// 2991 *                           nbr_base  = 10
// 2992 *
// 2993 *                           nbr       = 0
// 2994 *                           pstr_next = pstr = "  -12345678901234567890*123456"
// 2995 *
// 2996 *********************************************************************************************************
// 2997 */
// 2998 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2999 CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
Str_ParseNbr_Int32U:
        CODE
// 3000                                         CPU_CHAR    **pstr_next,
// 3001                                         CPU_INT08U    nbr_base)
// 3002 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 3003     CPU_INT32U  nbr;
// 3004 
// 3005 
// 3006     nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
// 3007                                             pstr_next,
// 3008                                             nbr_base,
// 3009                                             DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
// 3010                              (CPU_BOOLEAN *)0);
        ; Setup parameters for call to function Str_ParseNbr_Int32
        CLR     A
        MOV     ?V0,A
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        MOV     R1,A
        LCALL   Str_ParseNbr_Int32
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,R4
        MOV     ?V3,R5
// 3011 
// 3012     return (nbr);
        MOV     R2,?V0
        MOV     R3,?V1
        MOV     R4,?V2
        MOV     R5,?V3
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
// 3013 }
// 3014 
// 3015 
// 3016 /*$PAGE*/
// 3017 /*
// 3018 *********************************************************************************************************
// 3019 *                                        Str_ParseNbr_Int32S()
// 3020 *
// 3021 * Description : Parse 32-bit signed integer from string.
// 3022 *
// 3023 * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
// 3024 *
// 3025 *               pstr_next   Optional pointer to a variable to ... :
// 3026 *
// 3027 *                               (a) Return a pointer to first character following the integer string,
// 3028 *                                       if NO error(s) [see Note #2a2B2];
// 3029 *                               (b) Return a pointer to 'pstr',
// 3030 *                                       otherwise      (see Note #2a2A2).
// 3031 *
// 3032 *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
// 3033 *
// 3034 * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
// 3035 *
// 3036 *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
// 3037 *
// 3038 *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
// 3039 *
// 3040 *               0,                   otherwise                                    (see Note #2a3B).
// 3041 *
// 3042 * Caller(s)   : Application.
// 3043 *
// 3044 * Note(s)     : (1) String buffer NOT modified.
// 3045 *
// 3046 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
// 3047 *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
// 3048 *                       to a type long ... representation" :
// 3049 *
// 3050 *                       (1) "First, they decompose the input string into three parts" :
// 3051 *
// 3052 *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
// 3053 *                                by isspace()]."
// 3054 *
// 3055 *                               (1) "The subject sequence is defined as the longest initial subsequence of the
// 3056 *                                    input string, starting with the first non-white-space character that is of
// 3057 *                                    the expected form.  The subject sequence shall contain no characters if the
// 3058 *                                    input string is empty or consists entirely of white-space characters."
// 3059 *
// 3060 *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
// 3061 *                                    determined by the value of 'base' ('nbr_base')" :
// 3062 *
// 3063 *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
// 3064 *                                        subject sequence is that of a decimal constant, octal constant, or 
// 3065 *                                        hexadecimal constant" :
// 3066 *
// 3067 *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
// 3068 *                                            sequence of decimal digits."
// 3069 *
// 3070 *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
// 3071 *                                            a sequence of the digits '0' to '7' only."
// 3072 *
// 3073 *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
// 3074 *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
// 3075 *                                            (or 'F') with values 10 to 15 respectively."
// 3076 *
// 3077 *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
// 3078 *                                        of the subject sequence is a sequence of letters and digits representing 
// 3079 *                                        an integer with the radix specified by 'base' ('nbr_base')" :
// 3080 *
// 3081 *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
// 3082 *                                                ascribed the values 10 to 35"; ...
// 3083 *                                           (B) "only letters whose ascribed values are less than that of base
// 3084 *                                                are permitted."
// 3085 *
// 3086 *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
// 3087 *                                                '0X' may optionally precede the sequence of letters and digits."
// 3088 *
// 3089 *                                           (B) Although NO specification states that "if the value of 'base' 
// 3090 *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
// 3091 *                                               the sequence of letters and digits"; it seems reasonable to 
// 3092 *                                               allow the '0' character to be optionally parsed.
// 3093 *
// 3094 *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
// 3095 *
// 3096 *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
// 3097 *                                       integer string into an unsigned integer.
// 3098 *
// 3099 *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
// 3100 *                                   (b) "including the terminating null byte of the input string" ...
// 3101 *                               (2) "other than a sign or a permissible letter or digit."
// 3102 *$PAGE*
// 3103 *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
// 3104 *
// 3105 *                           (A) "If the subject sequence is empty or does not have the expected form" :
// 3106 *
// 3107 *                               (1) "no conversion is performed"; ...
// 3108 *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
// 3109 *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
// 3110 *
// 3111 *                           (B) "If the subject sequence has the expected form" :
// 3112 *
// 3113 *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
// 3114 *                                        starting with the first digit shall be interpreted as an integer constant."
// 3115 *
// 3116 *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
// 3117 *                                        used as the base for conversion, ascribing to each letter its value as 
// 3118 *                                        given above" (see Note #2a1B1b1A).
// 3119 *
// 3120 *                               (2) "A pointer to the final string shall be stored in the object pointed to by
// 3121 *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
// 3122 *                                   pointer."
// 3123 *
// 3124 *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
// 3125 *
// 3126 *                           (A) "Upon successful completion, these functions shall return the converted value."
// 3127 *
// 3128 *                               (1) "If the correct value is outside the range of representable values", either
// 3129 *                                    of the following "shall be returned" :
// 3130 *                                   (a) "{LONG_MIN}" or ...
// 3131 *                                   (b) "{LONG_MAX}"
// 3132 *
// 3133 *                           (B) "If no conversion could be performed, 0 shall be returned."
// 3134 *
// 3135 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 3136 *                           shall fail if" :
// 3137 *
// 3138 *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
// 3139 *
// 3140 *                           (B) "[ERANGE] - The value to be returned is not representable."
// 3141 *
// 3142 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 3143 *                           may fail if" :
// 3144 *
// 3145 *                           (A) "[EINVAL] - No conversion could be performed."
// 3146 *
// 3147 *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
// 3148 *
// 3149 *                   (a) Valid parse string integer :
// 3150 *
// 3151 *                           pstr      = "     ABCDE xyz"
// 3152 *                           nbr_base  = 16
// 3153 *
// 3154 *                           nbr       = 703710
// 3155 *                           pstr_next = " xyz"
// 3156 *
// 3157 *
// 3158 *                   (b) Invalid parse string integer :
// 3159 *
// 3160 *                           pstr      = "     ABCDE"
// 3161 *                           nbr_base  = 10
// 3162 *
// 3163 *                           nbr       =  0
// 3164 *                           pstr_next = pstr = "     ABCDE"
// 3165 *
// 3166 *
// 3167 *                   (c) Valid hexadecimal parse string integer :
// 3168 *
// 3169 *                           pstr      = "     0xGABCDE"
// 3170 *                           nbr_base  = 16
// 3171 *
// 3172 *                           nbr       =  0
// 3173 *                           pstr_next = "xGABCDE"
// 3174 *
// 3175 *
// 3176 *                   (d) Valid decimal parse string integer ('0x' prefix ignored
// 3177 *                               following invalid hexadecimal characters) :
// 3178 *
// 3179 *                           pstr      = "     0xGABCDE"
// 3180 *                           nbr_base  =  0
// 3181 *
// 3182 *                           nbr       =  0
// 3183 *                           pstr_next = "xGABCDE"
// 3184 *
// 3185 *
// 3186 *                   (e) Valid decimal parse string integer ('0'  prefix ignored
// 3187 *                               following invalid octal       characters) :
// 3188 *
// 3189 *                           pstr      = "     0GABCDE"
// 3190 *                           nbr_base  =  0
// 3191 *
// 3192 *                           nbr       =  0
// 3193 *                           pstr_next = "GABCDE"
// 3194 *
// 3195 *$PAGE*
// 3196 *                   (f) Parse string integer overflow :
// 3197 *
// 3198 *                           pstr      = "   12345678901234567890*123456"
// 3199 *                           nbr_base  = 10
// 3200 *
// 3201 *                           nbr       = DEF_INT_32S_MAX_VAL
// 3202 *                           pstr_next = "*123456"
// 3203 *
// 3204 *
// 3205 *                   (g) Parse string integer underflow :
// 3206 *
// 3207 *                           pstr      = "  -12345678901234567890*123456"
// 3208 *                           nbr_base  = 10
// 3209 *
// 3210 *                           nbr       = DEF_INT_32S_MIN_VAL
// 3211 *                           pstr_next = "*123456"
// 3212 *
// 3213 *********************************************************************************************************
// 3214 */
// 3215 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 3216 CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
Str_ParseNbr_Int32S:
        CODE
// 3217                                         CPU_CHAR    **pstr_next,
// 3218                                         CPU_INT08U    nbr_base)
// 3219 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
        MOV     R6,A
// 3220     CPU_INT32S   nbr;
// 3221     CPU_INT32U   nbr_abs;
// 3222     CPU_BOOLEAN  nbr_neg;
// 3223 
// 3224 
// 3225     nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
// 3226                                  pstr_next,
// 3227                                  nbr_base,
// 3228                                  DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
// 3229                                 &nbr_neg);
        ; Setup parameters for call to function Str_ParseNbr_Int32
        MOV     R0,?XSP + 0
        MOV     R1,?XSP + 1
        MOV     ?V0,R0
        MOV     ?V1,R1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0,#0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_ONE
        MOV     A,R6
        MOV     R1,A
        LCALL   Str_ParseNbr_Int32
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,R4
        MOV     ?V3,R5
// 3230 
// 3231     if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JNZ     ??Str_ParseNbr_Int32S_0
// 3232         nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
// 3233                                                                     :  (CPU_INT32S)nbr_abs;
        MOV     DPTR,#__Constant_80000000
        MOV     R0,#?V0
        LCALL   ?UL_GE_X
        JNC     ??Str_ParseNbr_Int32S_1
        MOV     ?V4,#-0x1
        MOV     ?V5,#-0x1
        MOV     ?V6,#-0x1
        MOV     ?V7,#0x7f
        SJMP    ??Str_ParseNbr_Int32S_2
??Str_ParseNbr_Int32S_1:
        MOV     ?V4,?V0
        MOV     ?V5,?V1
        MOV     ?V6,?V2
        MOV     ?V7,?V3
        SJMP    ??Str_ParseNbr_Int32S_2
// 3234     } else {
// 3235         nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
// 3236                                                                     : -(CPU_INT32S)nbr_abs;
??Str_ParseNbr_Int32S_0:
        MOV     DPTR,#__Constant_80000000
        MOV     R0,#?V0
        LCALL   ?UL_GE_X
        JNC     ??Str_ParseNbr_Int32S_3
        MOV     ?V4,#0x0
        MOV     ?V5,#0x0
        MOV     ?V6,#0x0
        MOV     ?V7,#-0x80
        SJMP    ??Str_ParseNbr_Int32S_2
??Str_ParseNbr_Int32S_3:
        MOV     ?V4,?V0
        MOV     ?V5,?V1
        MOV     ?V6,?V2
        MOV     ?V7,?V3
        MOV     R0,#?V4
        LCALL   ?L_NEG
// 3237     }
// 3238 
// 3239     return (nbr);
??Str_ParseNbr_Int32S_2:
        MOV     R2,?V4
        MOV     R3,?V5
        MOV     R4,?V6
        MOV     R5,?V7
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 3240 }
// 3241 
// 3242 
// 3243 /*$PAGE*/
// 3244 /*
// 3245 *********************************************************************************************************
// 3246 *********************************************************************************************************
// 3247 *                                           LOCAL FUNCTIONS
// 3248 *********************************************************************************************************
// 3249 *********************************************************************************************************
// 3250 */
// 3251 
// 3252 /*
// 3253 *********************************************************************************************************
// 3254 *                                         Str_FmtNbr_Int32()
// 3255 *
// 3256 * Description : Format 32-bit integer into a multi-digit character string.
// 3257 *
// 3258 * Argument(s) : nbr             Number           to format.
// 3259 *
// 3260 *               nbr_dig         Number of digits to format (see Note #1).
// 3261 *
// 3262 *               nbr_base        Base   of number to format (see Note #2).
// 3263 *
// 3264 *               nbr_neg         Indicates whether number to format is negative :
// 3265 *               -------
// 3266 *                                   DEF_NO          Number is non-negative.
// 3267 *                                   DEF_YES         Number is     negative.
// 3268 *
// 3269 *                               Argument validated in Str_FmtNbr_Int32U(),
// 3270 *                                                     Str_FmtNbr_Int32S().
// 3271 *
// 3272 *               lead_char       Prepend leading character  (see Note #3) :
// 3273 *
// 3274 *                                   '\0'                    Do NOT prepend leading character to string.
// 3275 *                                     Printable character          Prepend leading character to string.
// 3276 *                                   Unprintable character   Format invalid string (see Note #6e).
// 3277 *
// 3278 *               lower_case      Format alphabetic characters (if any) in lower case :
// 3279 *
// 3280 *                                   DEF_NO          Format alphabetic characters in upper case.
// 3281 *                                   DEF_YES         Format alphabetic characters in lower case.
// 3282 *
// 3283 *               nul             Append terminating NULL-character (see Note #4) :
// 3284 *
// 3285 *                                   DEF_NO          Do NOT append terminating NULL-character to string.
// 3286 *                                   DEF_YES                Append terminating NULL-character to string.
// 3287 *
// 3288 *               pstr            Pointer to character array to return formatted number string (see Note #5).
// 3289 *
// 3290 * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
// 3291 *
// 3292 *               Pointer to NULL,             otherwise.
// 3293 *
// 3294 * Caller(s)   : Str_FmtNbr_Int32U(),
// 3295 *               Str_FmtNbr_Int32S().
// 3296 *$PAGE*
// 3297 * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
// 3298 *
// 3299 *
// 3300 *                               Maximum Number of             [  log (Number)      ]
// 3301 *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
// 3302 *                                   to Format                 [   log (Base)       ]
// 3303 *
// 3304 *                               where
// 3305 *                                       Number                  Number to format
// 3306 *                                       Base            Base of number to format
// 3307 *
// 3308 *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting 
// 3309 *                           is performed except possible NULL-termination of the string (see Note #4).
// 3310 *
// 3311 *                               Example :
// 3312 *
// 3313 *                                   nbr      = -23456
// 3314 *                                   nbr_dig  =  0
// 3315 *                                   nbr_base = 10
// 3316 *
// 3317 *                                   pstr     = ""                   See Note #7a
// 3318 *
// 3319 *                       (2) If the number of digits to format ('nbr_dig') is less than the number of 
// 3320 *                           significant integer digits of the number to format ('nbr'); then an invalid 
// 3321 *                           string is formatted instead of truncating any significant integer digits.
// 3322 *
// 3323 *                               Example :
// 3324 *
// 3325 *                                   nbr      = 23456
// 3326 *                                   nbr_dig  = 3
// 3327 *                                   nbr_base = 10
// 3328 *
// 3329 *                                   pstr     = "???"                See Note #7b
// 3330 *
// 3331 *                       (3) If the number to format ('nbr') is negative but the number of digits to format 
// 3332 *                           ('nbr_dig') is equal to the number of significant integer digits of the number 
// 3333 *                           to format ('nbr'); then an invalid string is formatted instead of truncating 
// 3334 *                           the negative sign.
// 3335 *
// 3336 *                               Example :
// 3337 *
// 3338 *                                   nbr      = -23456
// 3339 *                                   nbr_dig  =  5
// 3340 *                                   nbr_base = 10
// 3341 *
// 3342 *                                   pstr     = "?????"              See Note #7b
// 3343 *
// 3344 *               (2) The number's base MUST be between 2 & 36, inclusive.
// 3345 *$PAGE*
// 3346 *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
// 3347 *
// 3348 *                   (a) (1) Leading character MUST be a printable ASCII character.
// 3349 *
// 3350 *                       (2) (A) Leading character MUST NOT be a number base digit, ...
// 3351 *                           (B) with the exception of '0'.
// 3352 *
// 3353 *                   (b) (1) The number of leading characters is such that the total number of significant 
// 3354 *                           integer digits plus the number of leading characters plus possible negative 
// 3355 *                           sign character is equal to the requested number of integer digits to format 
// 3356 *                           ('nbr_dig').
// 3357 *
// 3358 *                               Examples :
// 3359 *
// 3360 *                                   nbr       = 23456
// 3361 *                                   nbr_dig   = 7
// 3362 *                                   nbr_base  = 10
// 3363 *                                   lead_char = ' '
// 3364 *
// 3365 *                                   pstr      = "  23456"
// 3366 *
// 3367 *
// 3368 *                                   nbr       = -23456
// 3369 *                                   nbr_dig   = 7
// 3370 *                                   nbr_base  = 10
// 3371 *                                   lead_char = ' '
// 3372 *
// 3373 *                                   pstr      = " -23456"
// 3374 *
// 3375 *                       (2) (A) If the number to format ('nbr') is negative AND the leading character 
// 3376 *                               ('lead_char') is     a '0' digit; then the negative sign character 
// 3377 *                               prefixes all leading characters prior to the formatted number.
// 3378 *
// 3379 *                                   Examples :
// 3380 *
// 3381 *                                       nbr        = -23456
// 3382 *                                       nbr_dig    =  8
// 3383 *                                       nbr_base   = 10
// 3384 *                                       lead_char  = '0'
// 3385 *
// 3386 *                                       pstr       = "-0023456"
// 3387 *
// 3388 *
// 3389 *                                       nbr        = -43981
// 3390 *                                       nbr_dig    =  8
// 3391 *                                       nbr_base   = 16
// 3392 *                                       lead_char  = '0'
// 3393 *                                       lower_case = DEF_NO
// 3394 *
// 3395 *                                       pstr       = "-000ABCD"
// 3396 *
// 3397 *                           (B) If the number to format ('nbr') is negative AND the leading character 
// 3398 *                               ('lead_char') is NOT a '0' digit; then the negative sign character 
// 3399 *                               immediately prefixes the most significant digit of the formatted number.
// 3400 *
// 3401 *                                   Examples :
// 3402 *
// 3403 *                                       nbr        = -23456
// 3404 *                                       nbr_dig    =  8
// 3405 *                                       nbr_base   = 10
// 3406 *                                       lead_char  = '#'
// 3407 *
// 3408 *                                       pstr       = "##-23456"
// 3409 *
// 3410 *
// 3411 *                                       nbr        = -43981
// 3412 *                                       nbr_dig    =  8
// 3413 *                                       nbr_base   = 16
// 3414 *                                       lead_char  = '#'
// 3415 *                                       lower_case = DEF_YES
// 3416 *
// 3417 *                                       pstr       = "###-abcd"
// 3418 *
// 3419 *                   (c) (1) If the value of the number to format is     zero  ...
// 3420 *                       (2) ... & the number of digits to format is non-zero, ...
// 3421 *                       (3) ... but NO leading character available;           ...
// 3422 *                       (4) ... then one digit of '0' value is formatted.
// 3423 *
// 3424 *                           This is NOT a leading character; but a single integer digit of '0' value.
// 3425 *$PAGE*
// 3426 *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
// 3427 *                       array formatting.
// 3428 *
// 3429 *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
// 3430 *                       terminate option DISABLED will cause character string run-on.
// 3431 *
// 3432 *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
// 3433 *
// 3434 *                   (b) To prevent character buffer overrun :
// 3435 *
// 3436 *                           Character array size MUST be  >=  ('nbr_dig'          +
// 3437 *                                                               1 negative sign   +
// 3438 *                                                               1 'NUL' terminator)  characters
// 3439 *
// 3440 *               (6) String format terminates when :
// 3441 *
// 3442 *                   (a) Format string pointer is passed a NULL pointer.
// 3443 *                       (1) No      string formatted;                NULL pointer returned.
// 3444 *
// 3445 *                   (b) Number of digits to format ('nbr_dig') is zero.
// 3446 *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
// 3447 *
// 3448 *                   (c) Number of digits to format ('nbr_dig') is less than number of significant 
// 3449 *                           integer digits of the number to format ('nbr'), including possible 
// 3450 *                           negative sign.
// 3451 *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
// 3452 *
// 3453 *                   (d) Base is passed an invalid base (see Note #2).
// 3454 *                       (1) Invalid string format performed; NULL pointer returned.
// 3455 *
// 3456 *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
// 3457 *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
// 3458 *
// 3459 *                   (f) Number successfully formatted into character string array.
// 3460 *
// 3461 *               (7) For any unsuccessful string format or error(s), an invalid string of question marks 
// 3462 *                   ('?') will be formatted, where the number of question marks is determined by the 
// 3463 *                   number of digits to format ('nbr_dig') :
// 3464 *
// 3465 *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
// 3466 *                          number of     =  {
// 3467 *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
// 3468 *
// 3469 *********************************************************************************************************
// 3470 */
// 3471 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 3472 static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
Str_FmtNbr_Int32:
        CODE
// 3473                                      CPU_INT08U    nbr_dig,
// 3474                                      CPU_INT08U    nbr_base,
// 3475                                      CPU_BOOLEAN   nbr_neg,
// 3476                                      CPU_CHAR      lead_char,
// 3477                                      CPU_BOOLEAN   lower_case,
// 3478                                      CPU_BOOLEAN   nul,
// 3479                                      CPU_CHAR     *pstr)
// 3480 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
        PUSH    A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     ?V6,R4
        MOV     ?V7,R5
// 3481     CPU_CHAR     *pstr_fmt;
// 3482     CPU_DATA      i;
// 3483     CPU_INT32U    nbr_fmt;
// 3484     CPU_INT32U    nbr_log;
// 3485     CPU_INT08U    nbr_dig_max;
// 3486     CPU_INT08U    nbr_dig_min;
// 3487     CPU_INT08U    nbr_dig_fmtd;
// 3488     CPU_INT08U    nbr_neg_sign;
// 3489     CPU_INT08U    nbr_lead_char;
// 3490     CPU_INT08U    dig_val;
// 3491     CPU_INT08U    lead_char_delta_0;
// 3492     CPU_INT08U    lead_char_delta_a;
// 3493     CPU_BOOLEAN   lead_char_dig;
// 3494     CPU_BOOLEAN   lead_char_0;
// 3495     CPU_BOOLEAN   fmt_invalid;
// 3496     CPU_BOOLEAN   print_char;
// 3497     CPU_BOOLEAN   nbr_neg_fmtd;
// 3498 
// 3499 
// 3500 /*$PAGE*/
// 3501                                                                 /* ---------------- VALIDATE FMT ARGS ----------------- */
// 3502     if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_FmtNbr_Int32_0
// 3503         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??Str_FmtNbr_Int32_1
// 3504     }
// 3505 
// 3506     fmt_invalid = DEF_NO;
??Str_FmtNbr_Int32_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3507 
// 3508     if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??Str_FmtNbr_Int32_2
// 3509         fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3510     }
// 3511                                                                 /* If invalid base, ...                                 */
// 3512     if ((nbr_base <  2u) ||
// 3513         (nbr_base > 36u)) {
??Str_FmtNbr_Int32_2:
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x2
        CLR     C
        SUBB    A,#0x23
        JC      ??Str_FmtNbr_Int32_3
// 3514         fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3515     }
// 3516 
// 3517     if (lead_char != (CPU_CHAR)'\0') {
??Str_FmtNbr_Int32_3:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     $+5
        LJMP    ??Str_FmtNbr_Int32_4
// 3518         print_char =  ASCII_IsPrint(lead_char);
        ; Setup parameters for call to function ASCII_IsPrint
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_IsPrint
        MOV     A,R1
        MOV     R0,A
// 3519         if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
        MOV     A,#0x1
        XRL     A,R0
        JZ      ??Str_FmtNbr_Int32_5
// 3520             fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
        LJMP    ??Str_FmtNbr_Int32_4
// 3521 
// 3522         } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
??Str_FmtNbr_Int32_5:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x30
        JZ      ??Str_FmtNbr_Int32_4
// 3523             lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#-0x30
        MOV     R1,A
// 3524             if (lower_case != DEF_YES) {
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??Str_FmtNbr_Int32_6
// 3525                 lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#-0x41
        MOV     R0,A
        SJMP    ??Str_FmtNbr_Int32_7
// 3526             } else {
// 3527                 lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
??Str_FmtNbr_Int32_6:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#-0x61
        MOV     R0,A
// 3528             }
// 3529 
// 3530             lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
// 3531                              ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
// 3532                                                     (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
??Str_FmtNbr_Int32_7:
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xb
        JNC     ??Str_FmtNbr_Int32_8
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        CLR     C
        SUBB    A,R2
        JC      ??Str_FmtNbr_Int32_9
??Str_FmtNbr_Int32_8:
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xb
        JC      ??Str_FmtNbr_Int32_10
        MOV     A,R1
        CLR     C
        SUBB    A,#0xa
        JC      ??Str_FmtNbr_Int32_9
        MOV     R1,#0x0
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R2
        ADD     A,#-0xa
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        JNC     ??Str_FmtNbr_Int32_10
??Str_FmtNbr_Int32_9:
        MOV     R0,#0x1
        SJMP    ??Str_FmtNbr_Int32_11
??Str_FmtNbr_Int32_10:
        MOV     R0,#0x0
// 3533 
// 3534             if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
??Str_FmtNbr_Int32_11:
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_FmtNbr_Int32_4
// 3535                 fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3536             }
// 3537         }
// 3538     }
// 3539 
// 3540 
// 3541                                                                 /* ----------------- PREPARE NBR FMT ------------------ */
// 3542     pstr_fmt = pstr;
??Str_FmtNbr_Int32_4:
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 3543 
// 3544     if (fmt_invalid == DEF_NO) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??Str_FmtNbr_Int32_12
// 3545         nbr_fmt     = nbr;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V4
        LCALL   ?L_MOV_TO_X
// 3546         nbr_log     = nbr;
        MOV     ?V0,?V4
        MOV     ?V1,?V5
        MOV     ?V2,?V6
        MOV     ?V3,?V7
// 3547         nbr_dig_max = 1u;
        MOV     R4,#0x1
        SJMP    ??Str_FmtNbr_Int32_13
// 3548         while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
// 3549             nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
??Str_FmtNbr_Int32_14:
        INC     R4
// 3550             nbr_log /= nbr_base;
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        CLR     A
        MOV     ?V5,A
        MOV     ?V6,A
        MOV     ?V7,A
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?UL_DIV_MOD
// 3551         }
??Str_FmtNbr_Int32_13:
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        CLR     A
        MOV     ?V5,A
        MOV     ?V6,A
        MOV     ?V7,A
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_GT
        JNC     ??Str_FmtNbr_Int32_14
// 3552 
// 3553         nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??Str_FmtNbr_Int32_15
        MOV     R5,#0x1
        SJMP    ??Str_FmtNbr_Int32_16
??Str_FmtNbr_Int32_15:
        MOV     R5,#0x0
// 3554         if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
??Str_FmtNbr_Int32_16:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,R4
        MOV     R6,A
        MOV     R7,#0x0
        MOV     A,R5
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R6
        ADD     A,R0
        MOV     R0,A
        MOV     A,R7
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,?V0
        SUBB    A,R0
        MOV     A,?V1
        SUBB    A,R1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     $+5
        LJMP    ??Str_FmtNbr_Int32_17
// 3555             nbr_neg_fmtd = DEF_NO;
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3556             nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R4
        CLR     C
        SUBB    A,R0
        JNC     ??Str_FmtNbr_Int32_18
        MOV     A,R4
        PUSH    A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
        SJMP    ??Str_FmtNbr_Int32_19
??Str_FmtNbr_Int32_18:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 3557                                                                 /* ... calc nbr digs to fmt & nbr lead chars.           */
// 3558             if (lead_char != (CPU_CHAR)'\0') {
??Str_FmtNbr_Int32_19:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_20
// 3559                 nbr_dig_fmtd  = nbr_dig;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 3560                 nbr_lead_char = nbr_dig     -
// 3561                                 nbr_dig_min - nbr_neg_sign;
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        CLR     C
        SUBB    A,R5
        SJMP    ??Str_FmtNbr_Int32_21
// 3562             } else {
// 3563                 nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
??Str_FmtNbr_Int32_20:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R5
        PUSH    A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 3564                 nbr_lead_char = 0u;
        MOV     A,#0x0
// 3565             }
// 3566 
// 3567             if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
??Str_FmtNbr_Int32_21:
        JZ      ??Str_FmtNbr_Int32_22
// 3568                 lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
// 3569                             ?  DEF_YES : DEF_NO;
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x30
        JNZ     ??Str_FmtNbr_Int32_23
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
        SJMP    ??Str_FmtNbr_Int32_12
??Str_FmtNbr_Int32_23:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??Str_FmtNbr_Int32_12
// 3570             } else {
// 3571                 lead_char_0 =  DEF_NO;
??Str_FmtNbr_Int32_22:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??Str_FmtNbr_Int32_12
// 3572             }
// 3573 
// 3574         } else {                                                /* Else if nbr trunc'd, ...                             */
// 3575             fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
??Str_FmtNbr_Int32_17:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3576         }
// 3577     }
// 3578 
// 3579     if (fmt_invalid != DEF_NO) {
??Str_FmtNbr_Int32_12:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_24
// 3580         nbr_dig_fmtd = nbr_dig;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        MOVX    @DPTR,A
// 3581     }
// 3582 
// 3583 
// 3584 /*$PAGE*/
// 3585                                                                 /* ------------------- FMT NBR STR -------------------- */
// 3586     pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
??Str_FmtNbr_Int32_24:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
// 3587 
// 3588     if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_25
// 3589        *pstr_fmt = (CPU_CHAR)'\0';
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3590     }
// 3591     pstr_fmt--;
??Str_FmtNbr_Int32_25:
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
// 3592 
// 3593 
// 3594     for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??Str_FmtNbr_Int32_26
// 3595         if (fmt_invalid == DEF_NO) {
// 3596             if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
// 3597                 (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
// 3598                                                                 /* ... calc & fmt dig val;                      ...     */
// 3599                 dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
// 3600                 if (dig_val < 10u) {
// 3601                    *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
// 3602                 } else {
// 3603                     if (lower_case !=  DEF_YES) {
// 3604                        *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
// 3605                     } else {
// 3606                        *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
// 3607                     }
// 3608                 }
// 3609 
// 3610                 nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
// 3611 
// 3612             } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
// 3613                      (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
// 3614                        (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
// 3615                       ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
// 3616                        (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
// 3617 
// 3618                *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
// 3619                 nbr_neg_fmtd = DEF_YES;
// 3620 
// 3621             } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
// 3622                *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
// 3623             }
// 3624 
// 3625         } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
// 3626            *pstr_fmt-- = '?';
??Str_FmtNbr_Int32_27:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x3f
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
// 3627         }
??Str_FmtNbr_Int32_28:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
??Str_FmtNbr_Int32_26:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        PUSH    DPH
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        POP     DPH
        POP     DPL
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JC      $+5
        LJMP    ??Str_FmtNbr_Int32_29
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JNZ     ??Str_FmtNbr_Int32_27
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XLOAD_R4567
        MOV     A,R4
        ORL     A,R5
        ORL     A,R6
        ORL     A,R7
        JNZ     ??Str_FmtNbr_Int32_30
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??Str_FmtNbr_Int32_31
??Str_FmtNbr_Int32_30:
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        CLR     A
        MOV     ?V1,A
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_DIV_MOD
        MOV     A,?V0
        MOV     R0,A
        MOV     A,R0
        CLR     C
        SUBB    A,#0xa
        JNC     ??Str_FmtNbr_Int32_32
        MOV     A,#0x30
        ADD     A,R0
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
        SJMP    ??Str_FmtNbr_Int32_33
??Str_FmtNbr_Int32_32:
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??Str_FmtNbr_Int32_34
        MOV     A,#0x37
        ADD     A,R0
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
        SJMP    ??Str_FmtNbr_Int32_33
??Str_FmtNbr_Int32_34:
        MOV     A,#0x57
        ADD     A,R0
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
??Str_FmtNbr_Int32_33:
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0,A
        CLR     A
        MOV     ?V1,A
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_DIV_MOD
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V4
        LCALL   ?L_MOV_TO_X
        LJMP    ??Str_FmtNbr_Int32_28
??Str_FmtNbr_Int32_31:
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??Str_FmtNbr_Int32_35
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??Str_FmtNbr_Int32_36
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_37
??Str_FmtNbr_Int32_36:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_35
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        PUSH    DPH
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
        POP     DPH
        POP     DPL
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??Str_FmtNbr_Int32_38
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??Str_FmtNbr_Int32_38:
        JNZ     ??Str_FmtNbr_Int32_35
??Str_FmtNbr_Int32_37:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x2d
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
        LJMP    ??Str_FmtNbr_Int32_28
??Str_FmtNbr_Int32_35:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     $+5
        LJMP    ??Str_FmtNbr_Int32_28
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        MOV     DPL,R2
        MOV     DPH,R3
        POP     A
        MOVX    @DPTR,A
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
        LJMP    ??Str_FmtNbr_Int32_28
// 3628     }
// 3629 
// 3630 
// 3631     if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
??Str_FmtNbr_Int32_29:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??Str_FmtNbr_Int32_39
// 3632         return ((CPU_CHAR *)0);
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??Str_FmtNbr_Int32_1
// 3633     }
// 3634 
// 3635 
// 3636     return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
??Str_FmtNbr_Int32_39:
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
??Str_FmtNbr_Int32_1:
        MOV     A,#0xc
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 3637 }
// 3638 
// 3639 
// 3640 /*$PAGE*/
// 3641 /*
// 3642 *********************************************************************************************************
// 3643 *                                        Str_ParseNbr_Int32()
// 3644 *
// 3645 * Description : Parse 32-bit integer from string.
// 3646 *
// 3647 * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
// 3648 *
// 3649 *               pstr_next       Optional pointer to a variable to ... :
// 3650 *
// 3651 *                                   (a) Return a pointer to first character following the integer string,
// 3652 *                                           if NO error(s) [see Note #2a2B2];
// 3653 *                                   (b) Return a pointer to 'pstr',
// 3654 *                                           otherwise      (see Note #2a2A2).
// 3655 *
// 3656 *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
// 3657 *
// 3658 *               nbr_signed      Indicates whether number to parse is signed :
// 3659 *
// 3660 *                                   DEF_NO                  Number is unsigned.
// 3661 *                                   DEF_YES                 Number is   signed.
// 3662 *
// 3663 *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
// 3664 *
// 3665 *                                   DEF_NO                  Number is non-negative.
// 3666 *                                   DEF_YES                 Number is     negative.
// 3667 *
// 3668 * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
// 3669 *
// 3670 *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
// 3671 *
// 3672 *               0,                   otherwise                            (see Note #2a3B).
// 3673 *
// 3674 * Caller(s)   : Str_ParseNbr_Int32U(),
// 3675 *               Str_ParseNbr_Int32S().
// 3676 *
// 3677 * Note(s)     : (1) String buffer NOT modified.
// 3678 *
// 3679 *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
// 3680 *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr') 
// 3681 *                       to a type long ... representation" :
// 3682 *
// 3683 *                       (1) "First, they decompose the input string into three parts" :
// 3684 *
// 3685 *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
// 3686 *                                by isspace()]."
// 3687 *
// 3688 *                               (1) "The subject sequence is defined as the longest initial subsequence of the
// 3689 *                                    input string, starting with the first non-white-space character that is of
// 3690 *                                    the expected form.  The subject sequence shall contain no characters if the
// 3691 *                                    input string is empty or consists entirely of white-space characters."
// 3692 *
// 3693 *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
// 3694 *                                    determined by the value of 'base' ('nbr_base')" :
// 3695 *
// 3696 *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the 
// 3697 *                                        subject sequence is that of a decimal constant, octal constant, or 
// 3698 *                                        hexadecimal constant" :
// 3699 *
// 3700 *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
// 3701 *                                            sequence of decimal digits."
// 3702 *
// 3703 *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
// 3704 *                                            a sequence of the digits '0' to '7' only."
// 3705 *
// 3706 *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
// 3707 *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
// 3708 *                                            (or 'F') with values 10 to 15 respectively."
// 3709 *
// 3710 *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form 
// 3711 *                                        of the subject sequence is a sequence of letters and digits representing 
// 3712 *                                        an integer with the radix specified by 'base' ('nbr_base')" :
// 3713 *
// 3714 *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
// 3715 *                                                ascribed the values 10 to 35"; ...
// 3716 *                                           (B) "only letters whose ascribed values are less than that of base
// 3717 *                                                are permitted."
// 3718 *
// 3719 *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or 
// 3720 *                                               '0X' may optionally precede the sequence of letters and digits."
// 3721 *
// 3722 *                                           (B) Although NO specification states that "if the value of 'base' 
// 3723 *                                               ('nbr_base') is" 8, the '0' character "may optionally precede 
// 3724 *                                               the sequence of letters and digits"; it seems reasonable to 
// 3725 *                                               allow the '0' character to be optionally parsed.
// 3726 *$PAGE*
// 3727 *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
// 3728 *
// 3729 *                                   (a) It does NOT seem reasonable to parse & convert a negative number
// 3730 *                                       integer string into an unsigned integer.  However, a negative sign
// 3731 *                                       for an unsigned integer will automatically be parsed as an invalid
// 3732 *                                       character (see Note #2aC1).
// 3733 *
// 3734 *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
// 3735 *                                   (b) "including the terminating null byte of the input string" ...
// 3736 *                               (2) "other than a sign or a permissible letter or digit."
// 3737 *
// 3738 *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
// 3739 *
// 3740 *                           (A) "If the subject sequence is empty or does not have the expected form" :
// 3741 *
// 3742 *                               (1) "no conversion is performed"; ...
// 3743 *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr' 
// 3744 *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
// 3745 *
// 3746 *                           (B) "If the subject sequence has the expected form" :
// 3747 *
// 3748 *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters 
// 3749 *                                        starting with the first digit shall be interpreted as an integer constant."
// 3750 *
// 3751 *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be 
// 3752 *                                        used as the base for conversion, ascribing to each letter its value as 
// 3753 *                                        given above" (see Note #2a1B1b1A).
// 3754 *
// 3755 *                               (2) "A pointer to the final string shall be stored in the object pointed to by
// 3756 *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null 
// 3757 *                                   pointer."
// 3758 *
// 3759 *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
// 3760 *
// 3761 *                           (A) "Upon successful completion, these functions shall return the converted value."
// 3762 *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
// 3763 *                                    [or] {LONG_MAX} ... shall be returned."
// 3764 *
// 3765 *                           (B) "If no conversion could be performed, 0 shall be returned."
// 3766 *
// 3767 *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 3768 *                           shall fail if" :
// 3769 *
// 3770 *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
// 3771 *
// 3772 *                           (B) "[ERANGE] - The value to be returned is not representable."
// 3773 *
// 3774 *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
// 3775 *                           may fail if" :
// 3776 *
// 3777 *                           (A) "[EINVAL] - No conversion could be performed."
// 3778 *$PAGE*
// 3779 *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
// 3780 *
// 3781 *                   (a) Valid parse string integer :
// 3782 *
// 3783 *                           pstr      = "     ABCDE xyz"
// 3784 *                           nbr_base  = 16
// 3785 *
// 3786 *                           nbr       = 703710
// 3787 *                           pstr_next = " xyz"
// 3788 *
// 3789 *
// 3790 *                   (b) Invalid parse string integer :
// 3791 *
// 3792 *                           pstr      = "     ABCDE"
// 3793 *                           nbr_base  = 10
// 3794 *
// 3795 *                           nbr       =  0
// 3796 *                           pstr_next = pstr = "     ABCDE"
// 3797 *
// 3798 *
// 3799 *                   (c) Valid hexadecimal parse string integer :
// 3800 *
// 3801 *                           pstr      = "     0xGABCDE"
// 3802 *                           nbr_base  = 16
// 3803 *
// 3804 *                           nbr       =  0
// 3805 *                           pstr_next = "xGABCDE"
// 3806 *
// 3807 *
// 3808 *                   (d) Valid decimal parse string integer ('0x' prefix ignored
// 3809 *                               following invalid hexadecimal characters) :
// 3810 *
// 3811 *                           pstr      = "     0xGABCDE"
// 3812 *                           nbr_base  =  0
// 3813 *
// 3814 *                           nbr       =  0
// 3815 *                           pstr_next = "xGABCDE"
// 3816 *
// 3817 *
// 3818 *                   (e) Valid decimal parse string integer ('0'  prefix ignored
// 3819 *                               following invalid octal       characters) :
// 3820 *
// 3821 *                           pstr      = "     0GABCDE"
// 3822 *                           nbr_base  =  0
// 3823 *
// 3824 *                           nbr       =  0
// 3825 *                           pstr_next = "GABCDE"
// 3826 *
// 3827 *
// 3828 *                   (f) Parse string integer overflow :
// 3829 *
// 3830 *                           pstr      = "   12345678901234567890*123456"
// 3831 *                           nbr_base  = 10
// 3832 *
// 3833 *                           nbr       = DEF_INT_32U_MAX_VAL
// 3834 *                           pstr_next = "*123456"
// 3835 *
// 3836 *
// 3837 *                   (g) Parse string integer underflow :
// 3838 *
// 3839 *                           pstr      = "  -12345678901234567890*123456"
// 3840 *                           nbr_base  = 10
// 3841 *
// 3842 *                           nbr       = DEF_INT_32S_MIN_VAL
// 3843 *                           pstr_next = "*123456"
// 3844 *
// 3845 *
// 3846 *               (4) String parse terminates when :
// 3847 *
// 3848 *                   (a) Base passed an invalid base (see Note #2a1B1b).
// 3849 *                       (1) No conversion performed; 0 returned.
// 3850 *
// 3851 *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
// 3852 *                           (A) No conversion performed; 0 returned.
// 3853 *
// 3854 *                       (2) Invalid parse string character found (see Note #2a1C).
// 3855 *                           (A) Parsed integer returned.
// 3856 *                           (B) 'pstr_next' points to invalid character.
// 3857 *
// 3858 *                       (3) Entire  parse string converted (see Note #2a2B).
// 3859 *                           (A) Parsed integer returned.
// 3860 *                           (B) 'pstr_next' points to terminating NULL character.
// 3861 *
// 3862 *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
// 3863 *                   validation or function handling in case of any error(s).
// 3864 *********************************************************************************************************
// 3865 */
// 3866 /*$PAGE*/

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 3867 static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
Str_ParseNbr_Int32:
        CODE
// 3868                                                CPU_CHAR     **pstr_next,
// 3869                                                CPU_INT08U     nbr_base,
// 3870                                                CPU_BOOLEAN    nbr_signed,
// 3871                                                CPU_BOOLEAN   *pnbr_neg)
// 3872 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 13
        MOV     A,#-0xd
        LCALL   ?ALLOC_XSTACK8
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     A,R1
        PUSH    A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        POP     A
        MOVX    @DPTR,A
// 3873     const  CPU_CHAR     *pstr_parse;
// 3874     const  CPU_CHAR     *pstr_parse_nbr;
// 3875            CPU_CHAR     *pstr_parse_unused;
// 3876            CPU_CHAR      parse_char;
// 3877            CPU_INT08U    parse_dig;
// 3878            CPU_INT32U    nbr;
// 3879            CPU_BOOLEAN   nbr_neg_unused;
// 3880            CPU_BOOLEAN   nbr_dig;
// 3881            CPU_BOOLEAN   nbr_alpha;
// 3882            CPU_BOOLEAN   nbr_hex;
// 3883            CPU_BOOLEAN   nbr_hex_lower;
// 3884            CPU_BOOLEAN   whitespace;
// 3885            CPU_BOOLEAN   neg;
// 3886            CPU_BOOLEAN   ovf;
// 3887            CPU_BOOLEAN   done;
// 3888 
// 3889                                                                 /* --------------- VALIDATE PARSE ARGS ---------------- */
// 3890     if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_ParseNbr_Int32_0
// 3891         pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP100_8
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3892        (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP100_8
// 3893     }
// 3894    *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
??Str_ParseNbr_Int32_0:
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3895 
// 3896     if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_ParseNbr_Int32_1
// 3897         pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP100_8
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3898        (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP100_8
// 3899     }
// 3900    *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
??Str_ParseNbr_Int32_1:
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3901 
// 3902 
// 3903     if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??Str_ParseNbr_Int32_2
// 3904         return (0u);
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R4,#0x0
        MOV     R5,#0x0
        LJMP    ??Str_ParseNbr_Int32_3
// 3905     }
// 3906                                                                 /* Rtn zero if invalid base (see Note #4a).             */
// 3907     if ((nbr_base == 1u) ||
// 3908         (nbr_base > 36u)) {
??Str_ParseNbr_Int32_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??Str_ParseNbr_Int32_4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x25
        JC      ??Str_ParseNbr_Int32_5
// 3909         return (0u);
??Str_ParseNbr_Int32_4:
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R4,#0x0
        MOV     R5,#0x0
        LJMP    ??Str_ParseNbr_Int32_3
// 3910     }
// 3911 
// 3912 
// 3913                                                                 /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
// 3914     pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
??Str_ParseNbr_Int32_5:
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 3915 
// 3916     whitespace = ASCII_IsSpace(*pstr_parse);
        ; Setup parameters for call to function ASCII_IsSpace
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_IsSpace
        MOV     A,R1
        MOV     R0,A
        SJMP    ??Str_ParseNbr_Int32_6
// 3917     while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
// 3918         pstr_parse++;
??Str_ParseNbr_Int32_7:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3919         whitespace = ASCII_IsSpace(*pstr_parse);
        ; Setup parameters for call to function ASCII_IsSpace
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ASCII_IsSpace
        MOV     A,R1
        MOV     R0,A
// 3920     }
??Str_ParseNbr_Int32_6:
        MOV     A,#0x1
        XRL     A,R0
        JZ      ??Str_ParseNbr_Int32_7
// 3921 
// 3922     switch (*pstr_parse) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#-0x2b
        JZ      ??Str_ParseNbr_Int32_8
        ADD     A,#-0x2
        JZ      ??Str_ParseNbr_Int32_9
        SJMP    ??Str_ParseNbr_Int32_10
// 3923         case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
// 3924              pstr_parse++;
??Str_ParseNbr_Int32_8:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3925              neg = DEF_NO;
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3926              break;
        SJMP    ??Str_ParseNbr_Int32_11
// 3927 
// 3928 
// 3929         case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
// 3930              if (nbr_signed == DEF_YES) {
??Str_ParseNbr_Int32_9:
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??Str_ParseNbr_Int32_12
// 3931                  pstr_parse++;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3932              }
// 3933              neg = DEF_YES;
??Str_ParseNbr_Int32_12:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3934              break;
        SJMP    ??Str_ParseNbr_Int32_11
// 3935 
// 3936 
// 3937         default:
// 3938              neg = DEF_NO;
??Str_ParseNbr_Int32_10:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3939              break;
// 3940     }
// 3941 
// 3942 
// 3943 /*$PAGE*/
// 3944                                                                 /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
// 3945     pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
??Str_ParseNbr_Int32_11:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 3946 
// 3947     switch (nbr_base) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??Str_ParseNbr_Int32_13
        ADD     A,#-0x8
        JZ      ??Str_ParseNbr_Int32_14
        ADD     A,#-0x8
        JZ      ??Str_ParseNbr_Int32_15
        LJMP    ??Str_ParseNbr_Int32_16
// 3948         case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
// 3949              if (*pstr_parse == '0') {                          /* If avail, ...                                        */
??Str_ParseNbr_Int32_13:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,#0x30
        JNZ     ??Str_ParseNbr_Int32_17
// 3950                   pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3951                   switch (*pstr_parse) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#-0x58
        JZ      ??Str_ParseNbr_Int32_18
        ADD     A,#-0x20
        JNZ     ??Str_ParseNbr_Int32_19
// 3952                       case 'x':                                 /* For '0x' prefix, ...                                 */
// 3953                       case 'X':
// 3954                            nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
??Str_ParseNbr_Int32_18:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x10
        MOVX    @DPTR,A
// 3955                            parse_char = (CPU_CHAR)(*(pstr_parse + 1));
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V4,A
// 3956                            nbr_hex    =  ASCII_IsDigHex(parse_char);
        ; Setup parameters for call to function ASCII_IsDigHex
        MOV     R1,?V4
        LCALL   ASCII_IsDigHex
        MOV     A,R1
        MOV     R0,A
// 3957                            if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_16
// 3958                                pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3959                            }
// 3960                            break;
        SJMP    ??Str_ParseNbr_Int32_16
// 3961 
// 3962 
// 3963                       default:                                  /* For '0'  prefix, ...                                 */
// 3964                            nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
??Str_ParseNbr_Int32_19:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        MOVX    @DPTR,A
// 3965                            break;
        SJMP    ??Str_ParseNbr_Int32_16
// 3966                   }
// 3967 
// 3968              } else {                                           /* For non-'0' prefix, ...                              */
// 3969                  nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
??Str_ParseNbr_Int32_17:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0xa
        MOVX    @DPTR,A
// 3970              }
// 3971              break;
        SJMP    ??Str_ParseNbr_Int32_16
// 3972 
// 3973 
// 3974         case  8u:                                               /* See Note #2a1B1a2.                                   */
// 3975              if (*pstr_parse == '0') {                          /* If avail, ...                                        */
??Str_ParseNbr_Int32_14:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,#0x30
        JNZ     ??Str_ParseNbr_Int32_16
// 3976                   pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3977              }
// 3978              break;
        SJMP    ??Str_ParseNbr_Int32_16
// 3979 
// 3980 
// 3981         case 16u:                                               /* See Note #2a1B1a3.                                   */
// 3982              if (*pstr_parse == '0') {                          /* If avail, ...                                        */
??Str_ParseNbr_Int32_15:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,#0x30
        JNZ     ??Str_ParseNbr_Int32_16
// 3983                   pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3984                   switch (*pstr_parse) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#-0x58
        JZ      ??Str_ParseNbr_Int32_20
        ADD     A,#-0x20
        JNZ     ??Str_ParseNbr_Int32_16
// 3985                       case 'x':
// 3986                       case 'X':
// 3987                            parse_char = (CPU_CHAR)(*(pstr_parse + 1));
??Str_ParseNbr_Int32_20:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V4,A
// 3988                            nbr_hex    =  ASCII_IsDigHex(parse_char);
        ; Setup parameters for call to function ASCII_IsDigHex
        MOV     R1,?V4
        LCALL   ASCII_IsDigHex
        MOV     A,R1
        MOV     R0,A
// 3989                            if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_16
// 3990                                pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3991                            }
// 3992                            break;
// 3993 
// 3994 
// 3995                       default:
// 3996                            break;
// 3997                   }
// 3998              }
// 3999              break;
// 4000 
// 4001 
// 4002         default:                                                /* See Note #2a1B1b.                                    */
// 4003              break;
// 4004     }
// 4005 
// 4006 
// 4007 /*$PAGE*/
// 4008                                                                 /* ------------------ PARSE INT STR ------------------- */
// 4009     nbr  = 0u;
??Str_ParseNbr_Int32_16:
        MOV     ?V0,#0x0
        MOV     ?V1,#0x0
        MOV     ?V2,#0x0
        MOV     ?V3,#0x0
// 4010     ovf  = DEF_NO;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
// 4011     done = DEF_NO;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??Str_ParseNbr_Int32_21
// 4012 
// 4013     while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
// 4014         parse_char = (CPU_CHAR)*pstr_parse;
// 4015         nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
// 4016         if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
// 4017                                                                 /* ... convert parse char into nbr dig.                 */
// 4018             nbr_dig = ASCII_IsDig(parse_char);
// 4019             if (nbr_dig == DEF_YES) {
// 4020                 parse_dig = (CPU_INT08U)(parse_char - '0');
// 4021             } else {
// 4022                 nbr_hex_lower = ASCII_IsLower(parse_char);
// 4023                 if (nbr_hex_lower == DEF_YES) {
// 4024                     parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
// 4025                 } else {
// 4026                     parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
// 4027                 }
// 4028             }
// 4029 
// 4030             if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
// 4031                 if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
// 4032                     if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
// 4033                                                                 /* ... merge parse char dig into nbr.                   */
// 4034                         nbr *= nbr_base;
// 4035                         nbr += parse_dig;
// 4036                         if (nbr < parse_dig) {
// 4037                             ovf = DEF_YES;
// 4038                         }
// 4039                     } else {
// 4040                         ovf = DEF_YES;
// 4041                     }
// 4042                 }
// 4043                 pstr_parse++;
// 4044 
// 4045             } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
// 4046                 done = DEF_YES;
// 4047             }
// 4048 
// 4049         } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
// 4050             done = DEF_YES;
??Str_ParseNbr_Int32_22:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 4051         }
??Str_ParseNbr_Int32_21:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??Str_ParseNbr_Int32_23
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V4,A
        ; Setup parameters for call to function ASCII_IsAlphaNum
        MOV     R1,?V4
        LCALL   ASCII_IsAlphaNum
        MOV     A,R1
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_22
        ; Setup parameters for call to function ASCII_IsDig
        MOV     R1,?V4
        LCALL   ASCII_IsDig
        MOV     A,R1
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_24
        MOV     A,#-0x30
        ADD     A,?V4
        MOV     R2,A
        SJMP    ??Str_ParseNbr_Int32_25
??Str_ParseNbr_Int32_24:
        ; Setup parameters for call to function ASCII_IsLower
        MOV     R1,?V4
        LCALL   ASCII_IsLower
        MOV     A,R1
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_26
        MOV     ?V5,#0x0
        MOV     A,?V4
        ADD     A,#-0x57
        MOV     R2,A
        SJMP    ??Str_ParseNbr_Int32_25
??Str_ParseNbr_Int32_26:
        MOV     ?V5,#0x0
        MOV     A,?V4
        ADD     A,#-0x37
        MOV     R2,A
??Str_ParseNbr_Int32_25:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??Str_ParseNbr_Int32_27
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??Str_ParseNbr_Int32_28
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,#Str_MultOvfThTbl_Int32U & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(Str_MultOvfThTbl_Int32U >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?UL_GT_X
        JC      ??Str_ParseNbr_Int32_29
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?V4,A
        CLR     A
        MOV     ?V5,A
        MOV     ?V6,A
        MOV     ?V7,A
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?L_MUL
        MOV     ?V4,R2
        CLR     A
        MOV     ?V5,A
        MOV     ?V6,A
        MOV     ?V7,A
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?L_ADD
        MOV     ?V4,R2
        CLR     A
        MOV     ?V5,A
        MOV     ?V6,A
        MOV     ?V7,A
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_GT
        JNC     ??Str_ParseNbr_Int32_28
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
        SJMP    ??Str_ParseNbr_Int32_28
??Str_ParseNbr_Int32_29:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
??Str_ParseNbr_Int32_28:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
        LJMP    ??Str_ParseNbr_Int32_21
??Str_ParseNbr_Int32_27:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
        LJMP    ??Str_ParseNbr_Int32_21
// 4052     }
// 4053 
// 4054     if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
??Str_ParseNbr_Int32_23:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??Str_ParseNbr_Int32_30
// 4055         nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
        MOV     ?V0,#-0x1
        MOV     ?V1,#-0x1
        MOV     ?V2,#-0x1
        MOV     ?V3,#-0x1
// 4056     }
// 4057 
// 4058 
// 4059     if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
??Str_ParseNbr_Int32_30:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R6
        XRL     A,R0
        JNZ     ??Str_ParseNbr_Int32_31
        MOV     A,R7
        XRL     A,R1
??Str_ParseNbr_Int32_31:
        JZ      ??Str_ParseNbr_Int32_32
// 4060        *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        SJMP    ??Str_ParseNbr_Int32_33
// 4061     } else {
// 4062        *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
??Str_ParseNbr_Int32_32:
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 4063     }
// 4064 
// 4065    *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
??Str_ParseNbr_Int32_33:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
        MOVX    @DPTR,A
// 4066 
// 4067 
// 4068     return (nbr);
        MOV     R2,?V0
        MOV     R3,?V1
        MOV     R4,?V2
        MOV     R5,?V3
??Str_ParseNbr_Int32_3:
        MOV     A,#0xd
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 4069 }

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for Str_MultOvfThTbl_Int32U>`:
        DATA32
        DD 4294967295
        DD 4294967295
        DD 2147483647
        DD 1431655765
        DD 1073741823
        DD 858993459
        DD 715827882
        DD 613566756
        DD 536870911
        DD 477218588
        DD 429496729
        DD 390451572
        DD 357913941
        DD 330382099
        DD 306783378
        DD 286331153
        DD 268435455
        DD 252645135
        DD 238609294
        DD 226050910
        DD 214748364
        DD 204522252
        DD 195225786
        DD 186737708
        DD 178956970
        DD 171798691
        DD 165191049
        DD 159072862
        DD 153391689
        DD 148102320
        DD 143165576
        DD 138547332
        DD 134217727
        DD 130150524
        DD 126322567
        DD 122713351
        DD 119304647

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_0>`:
        DATA32
        DD 0

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_80000000>`:
        DATA32
        DD 2147483648

        END
// 4070 
// 
// 4 669 bytes in segment NEAR_CODE
//   156 bytes in segment XDATA_I
//   156 bytes in segment XDATA_ID
// 
// 4 817 bytes of CODE  memory (+ 8 bytes shared)
//   148 bytes of XDATA memory (+ 8 bytes shared)
//
//Errors: none
//Warnings: none
