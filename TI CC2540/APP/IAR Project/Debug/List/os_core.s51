///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.20.1.2476 for 8051               09/Apr/2017  15:54:03
// Copyright 2004-2015 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  near
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uCOS-III\Source\os_core.c
//    Command line       =  
//        "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uCOS-III\Source\os_core.c"
//        -lB "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\" -o "H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI
//        CC2540\APP\IAR Project\Debug\Obj\" -e --no_cse --no_unroll
//        --no_inline --no_code_motion --no_tbaa --debug --core=plain
//        --dptr=16,1 --data_model=large --code_model=near
//        --calling_convention=xdata_reentrant --place_constants=data
//        --nr_virtual_regs 8 -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Source\" -I "H:\TI ble环境搭建\工程\13
//        μCOS-iii移植2\uCOS-III\Ports\51-CC2540\Generic\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-CPU\51-CC2540\IAR\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\BSP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\" -I "H:\TI
//        ble环境搭建\工程\13 μCOS-iii移植2\uC-LIB\" -Ol
//    List file          =  
//        H:\TI ble环境搭建\工程\13 μCOS-iii移植2\TI CC2540\APP\IAR
//        Project\Debug\List\os_core.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME os_core

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?L_ADD_TO_X
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?PUSH_XSTACK8_X_FOUR
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_FOUR
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?UL_DIV_MOD
        EXTERN ?US_SWITCH_DENSE
        EXTERN ?XLOAD_R0123
        EXTERN ?XLOAD_R4567
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R0123
        EXTERN ?XSTORE_R4567
        EXTERN __INIT_XDATA_I

        PUBLIC OSInit
        PUBLIC OSIntEnter
        PUBLIC OSIntExit
        PUBLIC OSSched
        PUBLIC OSSchedLock
        PUBLIC OSSchedRoundRobinCfg
        PUBLIC OSSchedRoundRobinYield
        PUBLIC OSSchedUnlock
        PUBLIC OSStart
        PUBLIC OSVersion
        PUBLIC OS_IdleTask
        PUBLIC OS_IdleTaskInit
        PUBLIC OS_Pend
        PUBLIC OS_PendAbort
        PUBLIC OS_PendAbort1
        PUBLIC OS_PendDataInit
        PUBLIC OS_PendDbgNameAdd
        PUBLIC OS_PendDbgNameRemove
        PUBLIC OS_PendListChangePrio
        PUBLIC OS_PendListInit
        PUBLIC OS_PendListInsertHead
        PUBLIC OS_PendListInsertPrio
        PUBLIC OS_PendListRemove
        PUBLIC OS_PendListRemove1
        PUBLIC OS_PendObjDel
        PUBLIC OS_PendObjDel1
        PUBLIC OS_Post
        PUBLIC OS_Post1
        PUBLIC OS_RdyListInit
        PUBLIC OS_RdyListInsert
        PUBLIC OS_RdyListInsertHead
        PUBLIC OS_RdyListInsertTail
        PUBLIC OS_RdyListMoveHeadToTail
        PUBLIC OS_RdyListRemove
        PUBLIC OS_SchedRoundRobin
        PUBLIC OS_TaskBlock
        PUBLIC OS_TaskRdy
        PUBWEAK WDCTL
        PUBWEAK _A_IRCON2
        PUBWEAK _A_P1
        PUBWEAK __Constant_0
        PUBWEAK __Constant_1
        PUBWEAK __Constant_a
        PUBWEAK __Constant_ffffffff

        EXTERN CPU_SR_Restore
        EXTERN CPU_SR_Save
        EXTERN OSCfg_ISRStkBasePtr
        EXTERN OSCfg_ISRStkSize
        EXTERN OSCfg_IdleTaskStkBasePtr
        EXTERN OSCfg_IdleTaskStkLimit
        EXTERN OSCfg_IdleTaskStkSize
        EXTERN OSCfg_Init
        EXTERN OSCfg_TickRate_Hz
        EXTERN OSIdleTaskCtr
        EXTERN OSIdleTaskHook
        EXTERN OSIdleTaskTCB
        EXTERN OSInitHook
        EXTERN OSIntNestingCtr
        EXTERN OSPrioCur
        EXTERN OSPrioHighRdy
        EXTERN OSPrioSaved
        EXTERN OSRdyList
        EXTERN OSRunning
        EXTERN OSSchedLockNestingCtr
        EXTERN OSSchedRoundRobinDfltTimeQuanta
        EXTERN OSSchedRoundRobinEn
        EXTERN OSStartHighRdy
        EXTERN OSTCBCurPtr
        EXTERN OSTCBHighRdyPtr
        EXTERN OSTaskCreate
        EXTERN OSTaskCtxSwCtr
        EXTERN OSTaskRegNextAvailID
        EXTERN OS_AppIdleTaskHookPtr
        EXTERN OS_AppStatTaskHookPtr
        EXTERN OS_AppTaskCreateHookPtr
        EXTERN OS_AppTaskDelHookPtr
        EXTERN OS_AppTaskReturnHookPtr
        EXTERN OS_AppTaskSwHookPtr
        EXTERN OS_AppTimeTickHookPtr
        EXTERN OS_Dbg_Init
        EXTERN OS_FlagInit
        EXTERN OS_MemInit
        EXTERN OS_MsgPoolInit
        EXTERN OS_MutexInit
        EXTERN OS_PrioGetHighest
        EXTERN OS_PrioInit
        EXTERN OS_PrioInsert
        EXTERN OS_PrioRemove
        EXTERN OS_QInit
        EXTERN OS_SemInit
        EXTERN OS_TaskInit
        EXTERN OS_TickListInsert
        EXTERN OS_TickListRemove
        EXTERN OS_TickTaskInit

// H:\TI ble环境搭建\工程\13 μCOS-iii移植2\uCOS-III\Source\os_core.c
//    1 /*
//    2 ************************************************************************************************************************
//    3 *                                                      uC/OS-III
//    4 *                                                 The Real-Time Kernel
//    5 *
//    6 *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
//    7 *                           All rights reserved.  Protected by international copyright laws.
//    8 *
//    9 *                                                    CORE FUNCTIONS
//   10 *
//   11 * File    : OS_CORE.C
//   12 * By      : JJL
//   13 * Version : V3.03.01
//   14 *
//   15 * LICENSING TERMS:
//   16 * ---------------
//   17 *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
//   18 *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
//   19 *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
//   20 *           application/product.   We provide ALL the source code for your convenience and to help you 
//   21 *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
//   22 *           it commercially without paying a licensing fee.
//   23 *
//   24 *           Knowledge of the source code may NOT be used to develop a similar product.
//   25 *
//   26 *           Please help us continue to provide the embedded community with the finest software available.
//   27 *           Your honesty is greatly appreciated.
//   28 *
//   29 *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
//   30 ************************************************************************************************************************
//   31 */
//   32 
//   33 #define  MICRIUM_SOURCE
//   34 #include <os.h>

        ASEGN SFR_AN:DATA:NOROOT,090H
// union <unnamed> volatile __sfr _A_P1
_A_P1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c9H
// unsigned char volatile __sfr WDCTL
WDCTL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e8H
// union <unnamed> volatile __sfr _A_IRCON2
_A_IRCON2:
        DATA8
        DS 1
//   35 
//   36 #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
//   37 const  CPU_CHAR  *os_core__c = "$Id: $";
//   38 #endif
//   39 
//   40 /*
//   41 ************************************************************************************************************************
//   42 *                                                    INITIALIZATION
//   43 *
//   44 * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
//   45 *              creating any uC/OS-III object and, prior to calling OS_Start().
//   46 *
//   47 * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
//   48 *
//   49 *                                OS_ERR_NONE    Initialization was successful
//   50 *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
//   51 * Returns    : none
//   52 ************************************************************************************************************************
//   53 */
//   54 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//   55 void  OSInit (OS_ERR  *p_err)
OSInit:
        CODE
//   56 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//   57     CPU_STK      *p_stk;
//   58     CPU_STK_SIZE  size;
//   59 
//   60 
//   61 
//   62 #ifdef OS_SAFETY_CRITICAL
//   63     if (p_err == (OS_ERR *)0) {
//   64         OS_SAFETY_CRITICAL_EXCEPTION();
//   65         return;
//   66     }
//   67 #endif
//   68 
//   69     OSInitHook();                                           /* Call port specific initialization code                 */
        ; Setup parameters for call to function OSInitHook
        LCALL   OSInitHook
//   70 
//   71     OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
        MOV     DPTR,#OSIntNestingCtr
        MOV     A,#0x0
        MOVX    @DPTR,A
//   72 
//   73     OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
        MOV     DPTR,#OSRunning
        MOV     A,#0x0
        MOVX    @DPTR,A
//   74 
//   75     OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
        MOV     DPTR,#OSSchedLockNestingCtr
        MOV     A,#0x0
        MOVX    @DPTR,A
//   76 
//   77     OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
        MOV     DPTR,#OSTCBCurPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//   78     OSTCBHighRdyPtr                 = (OS_TCB *)0;
        MOV     DPTR,#OSTCBHighRdyPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//   79 
//   80     OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
        MOV     DPTR,#OSPrioCur
        MOV     A,#0x0
        MOVX    @DPTR,A
//   81     OSPrioHighRdy                   = (OS_PRIO)0;
        MOV     DPTR,#OSPrioHighRdy
        MOV     A,#0x0
        MOVX    @DPTR,A
//   82     OSPrioSaved                     = (OS_PRIO)0;
        MOV     DPTR,#OSPrioSaved
        MOV     A,#0x0
        MOVX    @DPTR,A
//   83 
//   84 #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
//   85     OSSchedLockTimeBegin            = (CPU_TS)0;
//   86     OSSchedLockTimeMax              = (CPU_TS)0;
//   87     OSSchedLockTimeMaxCur           = (CPU_TS)0;
//   88 #endif
//   89 
//   90 #ifdef OS_SAFETY_CRITICAL_IEC61508
//   91     OSSafetyCriticalStartFlag       =  DEF_FALSE;
//   92 #endif
//   93 
//   94 #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
//   95     OSSchedRoundRobinEn             = DEF_FALSE;
        MOV     DPTR,#OSSchedRoundRobinEn
        MOV     A,#0x0
        MOVX    @DPTR,A
//   96     OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
        MOV     DPTR,#OSCfg_TickRate_Hz
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_a
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_DIV_MOD
        MOV     DPTR,#OSSchedRoundRobinDfltTimeQuanta
        MOV     R0,#?V4
        LCALL   ?L_MOV_TO_X
//   97 #endif
//   98 
//   99     if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
        MOV     DPTR,#OSCfg_ISRStkSize
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??OSInit_0
//  100         p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
        MOV     DPTR,#OSCfg_ISRStkBasePtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
//  101         if (p_stk != (CPU_STK *)0) {
        MOV     A,R0
        ORL     A,R1
        JZ      ??OSInit_0
//  102             size  = OSCfg_ISRStkSize;
        MOV     DPTR,#OSCfg_ISRStkSize
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        SJMP    ??OSInit_1
//  103             while (size > (CPU_STK_SIZE)0) {
//  104                 size--;
??OSInit_2:
        MOV     A,R2
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R3,A
//  105                *p_stk = (CPU_STK)0;
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,#0x0
        MOVX    @DPTR,A
//  106                 p_stk++;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
//  107             }
??OSInit_1:
        MOV     A,R2
        ORL     A,R3
        JNZ     ??OSInit_2
//  108         }
//  109     }
//  110 
//  111 #if OS_CFG_APP_HOOKS_EN > 0u
//  112     OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
??OSInit_0:
        MOV     DPTR,#OS_AppTaskCreateHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  113     OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
        MOV     DPTR,#OS_AppTaskDelHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  114     OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
        MOV     DPTR,#OS_AppTaskReturnHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  115 
//  116     OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
        MOV     DPTR,#OS_AppIdleTaskHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  117     OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
        MOV     DPTR,#OS_AppStatTaskHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  118     OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
        MOV     DPTR,#OS_AppTaskSwHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  119     OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
        MOV     DPTR,#OS_AppTimeTickHookPtr
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  120 #endif
//  121 
//  122 #if OS_CFG_TASK_REG_TBL_SIZE > 0u
//  123     OSTaskRegNextAvailID    = (OS_REG_ID)0;
        MOV     DPTR,#OSTaskRegNextAvailID
        MOV     A,#0x0
        MOVX    @DPTR,A
//  124 #endif
//  125 
//  126     OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
        ; Setup parameters for call to function OS_PrioInit
        LCALL   OS_PrioInit
//  127 
//  128     OS_RdyListInit();                                       /* Initialize the Ready List                              */
        ; Setup parameters for call to function OS_RdyListInit
        LCALL   OS_RdyListInit
//  129 
//  130     
//  131 #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
//  132     OS_FlagInit(p_err);
        ; Setup parameters for call to function OS_FlagInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_FlagInit
//  133     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??OSInit_3
//  134         return;
//  135     }
//  136 #endif
//  137 
//  138 
//  139 #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
//  140     OS_MemInit(p_err);
        ; Setup parameters for call to function OS_MemInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_MemInit
//  141     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??OSInit_3
//  142         return;
//  143     }
//  144 #endif
//  145 
//  146 
//  147 #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
//  148     OS_MsgPoolInit(p_err);
        ; Setup parameters for call to function OS_MsgPoolInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_MsgPoolInit
//  149     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  150         return;
//  151     }
//  152 #endif
//  153 
//  154 
//  155 #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
//  156     OS_MutexInit(p_err);
        ; Setup parameters for call to function OS_MutexInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_MutexInit
//  157     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  158         return;
//  159     }
//  160 #endif
//  161 
//  162 
//  163 #if OS_CFG_Q_EN > 0u
//  164     OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
        ; Setup parameters for call to function OS_QInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_QInit
//  165     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  166         return;
//  167     }
//  168 #endif
//  169 
//  170 
//  171 #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
//  172     OS_SemInit(p_err);
        ; Setup parameters for call to function OS_SemInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_SemInit
//  173     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  174         return;
//  175     }
//  176 #endif
//  177 
//  178 
//  179 #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
//  180     OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
//  181     if (*p_err != OS_ERR_NONE) {
//  182         return;
//  183     }
//  184 #endif
//  185 
//  186 
//  187     OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
        ; Setup parameters for call to function OS_TaskInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TaskInit
//  188     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  189         return;
//  190     }
//  191 
//  192 
//  193 #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
//  194     OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
//  195     if (*p_err != OS_ERR_NONE) {
//  196         return;
//  197     }
//  198 #endif
//  199 
//  200     
//  201     OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
        ; Setup parameters for call to function OS_IdleTaskInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_IdleTaskInit
//  202     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  203         return;
//  204     }
//  205 
//  206 
//  207     OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
        ; Setup parameters for call to function OS_TickTaskInit
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickTaskInit
//  208     if (*p_err != OS_ERR_NONE) {
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OSInit_3
//  209         return;
//  210     }
//  211 
//  212 
//  213 #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
//  214     OS_StatTaskInit(p_err);
//  215     if (*p_err != OS_ERR_NONE) {
//  216         return;
//  217     }
//  218 #endif
//  219 
//  220 
//  221 #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
//  222     OS_TmrInit(p_err);
//  223     if (*p_err != OS_ERR_NONE) {
//  224         return;
//  225     }
//  226 #endif
//  227 
//  228 
//  229 #if OS_CFG_DBG_EN > 0u
//  230     OS_Dbg_Init();
        ; Setup parameters for call to function OS_Dbg_Init
        LCALL   OS_Dbg_Init
//  231 #endif
//  232 
//  233 
//  234     OSCfg_Init();
        ; Setup parameters for call to function OSCfg_Init
        LCALL   OSCfg_Init
//  235 }
??OSInit_3:
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
//  236 
//  237 /*$PAGE*/
//  238 /*
//  239 ************************************************************************************************************************
//  240 *                                                      ENTER ISR
//  241 *
//  242 * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
//  243 *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
//  244 *              the last nested ISR.
//  245 *
//  246 * Arguments  : none
//  247 *
//  248 * Returns    : none
//  249 *
//  250 * Note(s)    : 1) This function MUST be called with interrupts already disabled
//  251 *
//  252 *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
//  253 *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
//  254 *                 uC/OS-III variables.
//  255 *
//  256 *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
//  257 *
//  258 *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
//  259 *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
//  260 *                 at the end of the ISR.
//  261 *
//  262 *              5) You are allowed to nest interrupts up to 250 levels deep.
//  263 ************************************************************************************************************************
//  264 */
//  265 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  266 void  OSIntEnter (void)
OSIntEnter:
        CODE
//  267 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
//  268     if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
        MOV     DPTR,#OSRunning
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??OSIntEnter_0
//  269         return;                                             /* No                                                     */
//  270     }
//  271 
//  272     if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#-0x6
        JNC     ??OSIntEnter_0
//  273         return;                                             /* Yes                                                    */
//  274     }
//  275 
//  276     OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
//  277 }
??OSIntEnter_0:
        POP     DPH
        POP     DPL
        RET
//  278 
//  279 /*$PAGE*/
//  280 /*
//  281 ************************************************************************************************************************
//  282 *                                                       EXIT ISR
//  283 *
//  284 * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
//  285 *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
//  286 *              ready to run.
//  287 *
//  288 * Arguments  : none
//  289 *
//  290 * Returns    : none
//  291 *
//  292 * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
//  293 *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
//  294 *                 at the end of the ISR.
//  295 *
//  296 *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
//  297 ************************************************************************************************************************
//  298 */
//  299 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  300 void  OSIntExit (void)
OSIntExit:
        CODE
//  301 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
//  302     CPU_SR_ALLOC();
        MOV     R6,#0x0
//  303 
//  304 
//  305 
//  306     if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
        MOV     DPTR,#OSRunning
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      $+5
        LJMP    ??OSIntExit_0
//  307         return;                                             /* No                                                     */
//  308     }
//  309 
//  310     CPU_INT_DIS();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
//  311     if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JNZ     ??OSIntExit_1
//  312         CPU_INT_EN();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  313         return;
        LJMP    ??OSIntExit_0
//  314     }
//  315     OSIntNestingCtr--;
??OSIntExit_1:
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
//  316     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSIntExit_2
//  317         CPU_INT_EN();                                       /* Yes                                                    */
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  318         return;
        LJMP    ??OSIntExit_0
//  319     }
//  320 
//  321     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
??OSIntExit_2:
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSIntExit_3
//  322         CPU_INT_EN();                                       /* Yes                                                    */
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  323         return;
        LJMP    ??OSIntExit_0
//  324     }
//  325 
//  326     OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
??OSIntExit_3:
        ; Setup parameters for call to function OS_PrioGetHighest
        LCALL   OS_PrioGetHighest
        MOV     A,R1
        MOV     DPTR,#OSPrioHighRdy
        MOVX    @DPTR,A
//  327     OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
        MOV     DPTR,#OSPrioHighRdy
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBHighRdyPtr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  328     if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
        MOV     DPTR,#OSTCBHighRdyPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??OSIntExit_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??OSIntExit_4:
        JNZ     ??OSIntExit_5
//  329         CPU_INT_EN();                                       /* Yes                                                    */
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  330         return;
        SJMP    ??OSIntExit_0
//  331     }
//  332 
//  333 #if OS_CFG_TASK_PROFILE_EN > 0u
//  334     OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
??OSIntExit_5:
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#OSTCBHighRdyPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x69
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
//  335 #endif
//  336     OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#OSTaskCtxSwCtr
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
//  337 
//  338 #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
//  339     OS_TLS_TaskSw();
//  340 #endif
//  341     CPU_INT_EN();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  342     OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
        MOV     0xc9,#0x1e
        SETB    0xe8.4
//  343     //CPU_INT_EN();
//  344 }
??OSIntExit_0:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE WDCTL
        REQUIRE _A_IRCON2
//  345 
//  346 /*$PAGE*/
//  347 /*
//  348 ************************************************************************************************************************
//  349 *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
//  350 *
//  351 * Description: This function is called by the application code to indicate that all initialization has been completed
//  352 *              and that kernel objects are no longer allowed to be created.
//  353 *
//  354 * Arguments  : none
//  355 *
//  356 * Returns    : none
//  357 *
//  358 * Note(s)    : none
//  359 ************************************************************************************************************************
//  360 */
//  361 
//  362 #ifdef OS_SAFETY_CRITICAL_IEC61508
//  363 void  OSSafetyCriticalStart (void)
//  364 {
//  365     OSSafetyCriticalStartFlag = DEF_TRUE;
//  366 }
//  367 
//  368 #endif
//  369 
//  370 /*$PAGE*/
//  371 /*
//  372 ************************************************************************************************************************
//  373 *                                                      SCHEDULER
//  374 *
//  375 * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
//  376 *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
//  377 *              from ISRs (see OSIntExit() for ISR rescheduling).
//  378 *
//  379 * Arguments  : none
//  380 *
//  381 * Returns    : none
//  382 *
//  383 * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
//  384 ************************************************************************************************************************
//  385 */
//  386 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  387 void  OSSched (void)
OSSched:
        CODE
//  388 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
//  389     CPU_SR_ALLOC();
        MOV     R6,#0x0
//  390 
//  391 
//  392 
//  393     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??OSSched_0
//  394         return;                                             /* Yes ... only schedule when no nested ISRs              */
//  395     }
//  396 
//  397     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??OSSched_0
//  398         return;                                             /* Yes                                                    */
//  399     }
//  400 
//  401     CPU_INT_DIS();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
//  402     OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
        ; Setup parameters for call to function OS_PrioGetHighest
        LCALL   OS_PrioGetHighest
        MOV     A,R1
        MOV     DPTR,#OSPrioHighRdy
        MOVX    @DPTR,A
//  403     OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
        MOV     DPTR,#OSPrioHighRdy
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBHighRdyPtr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  404     if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
        MOV     DPTR,#OSTCBHighRdyPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??OSSched_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??OSSched_1:
        JNZ     ??OSSched_2
//  405         CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  406         return;
        SJMP    ??OSSched_0
//  407     }
//  408 
//  409 #if OS_CFG_TASK_PROFILE_EN > 0u
//  410     OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
??OSSched_2:
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#OSTCBHighRdyPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x69
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
//  411 #endif
//  412     OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#OSTaskCtxSwCtr
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
//  413 
//  414 #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
//  415     OS_TLS_TaskSw();
//  416 #endif
//  417 
//  418     OS_TASK_SW();                                           /* Perform a task level context switch                    */
        MOV     0xc9,#0x1e
        SETB    0xe8.4
//  419     CPU_INT_EN();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  420 }
??OSSched_0:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE WDCTL
        REQUIRE _A_IRCON2
//  421 
//  422 /*$PAGE*/
//  423 /*
//  424 ************************************************************************************************************************
//  425 *                                                 PREVENT SCHEDULING
//  426 *
//  427 * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
//  428 *              context switches until you are ready to permit context switching.
//  429 *
//  430 * Arguments  : p_err     is a pointer to a variable that will receive an error code:
//  431 *
//  432 *                            OS_ERR_NONE                 The scheduler is locked
//  433 *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
//  434 *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet.
//  435 *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR.
//  436 *
//  437 * Returns    : none
//  438 *
//  439 * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
//  440 *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
//  441 ************************************************************************************************************************
//  442 */
//  443 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  444 void  OSSchedLock (OS_ERR  *p_err)
OSSchedLock:
        CODE
//  445 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  446     CPU_SR_ALLOC();
        MOV     R1,#0x0
//  447 
//  448 
//  449 
//  450 #ifdef OS_SAFETY_CRITICAL
//  451     if (p_err == (OS_ERR *)0) {
//  452         OS_SAFETY_CRITICAL_EXCEPTION();
//  453         return;
//  454     }
//  455 #endif
//  456 
//  457 #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
//  458     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSSchedLock_0
//  459        *p_err = OS_ERR_SCHED_LOCK_ISR;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x62
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6d
        MOVX    @DPTR,A
//  460         return;
        SJMP    ??OSSchedLock_1
//  461     }
//  462 #endif
//  463 
//  464     if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
??OSSchedLock_0:
        MOV     DPTR,#OSRunning
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??OSSchedLock_2
//  465        *p_err = OS_ERR_OS_NOT_RUNNING;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#-0x77
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x5e
        MOVX    @DPTR,A
//  466         return;
        SJMP    ??OSSchedLock_1
//  467     }
//  468 
//  469     if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
??OSSchedLock_2:
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#-0x6
        JC      ??OSSchedLock_3
//  470        *p_err = OS_ERR_LOCK_NESTING_OVF;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x9
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x52
        MOVX    @DPTR,A
//  471         return;
        SJMP    ??OSSchedLock_1
//  472     }
//  473 
//  474     CPU_CRITICAL_ENTER();
??OSSchedLock_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
//  475     OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
//  476 #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
//  477     OS_SchedLockTimeMeasStart();
//  478 #endif
//  479     CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
//  480    *p_err = OS_ERR_NONE;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  481 }
??OSSchedLock_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
//  482 
//  483 /*$PAGE*/
//  484 /*
//  485 ************************************************************************************************************************
//  486 *                                                  ENABLE SCHEDULING
//  487 *
//  488 * Description: This function is used to re-allow rescheduling.
//  489 *
//  490 * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
//  491 *
//  492 *                            OS_ERR_NONE
//  493 *                            OS_ERR_OS_NOT_RUNNING       The scheduler has been enabled
//  494 *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
//  495 *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
//  496 *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR.
//  497 *
//  498 * Returns    : none
//  499 *
//  500 * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
//  501 *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
//  502 ************************************************************************************************************************
//  503 */
//  504 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  505 void  OSSchedUnlock (OS_ERR  *p_err)
OSSchedUnlock:
        CODE
//  506 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  507     CPU_SR_ALLOC();
        MOV     R1,#0x0
//  508 
//  509 
//  510 
//  511 #ifdef OS_SAFETY_CRITICAL
//  512     if (p_err == (OS_ERR *)0) {
//  513         OS_SAFETY_CRITICAL_EXCEPTION();
//  514         return;
//  515     }
//  516 #endif
//  517 
//  518 #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
//  519     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSSchedUnlock_0
//  520        *p_err = OS_ERR_SCHED_UNLOCK_ISR;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x65
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6d
        MOVX    @DPTR,A
//  521         return;
        SJMP    ??OSSchedUnlock_1
//  522     }
//  523 #endif
//  524 
//  525     if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
??OSSchedUnlock_0:
        MOV     DPTR,#OSRunning
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??OSSchedUnlock_2
//  526        *p_err = OS_ERR_OS_NOT_RUNNING;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#-0x77
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x5e
        MOVX    @DPTR,A
//  527         return;
        SJMP    ??OSSchedUnlock_1
//  528     }
//  529 
//  530     if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
??OSSchedUnlock_2:
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JNZ     ??OSSchedUnlock_3
//  531        *p_err = OS_ERR_SCHED_NOT_LOCKED;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x64
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6d
        MOVX    @DPTR,A
//  532         return;
        SJMP    ??OSSchedUnlock_1
//  533     }
//  534 
//  535     CPU_CRITICAL_ENTER();
??OSSchedUnlock_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
//  536     OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
//  537     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSSchedUnlock_4
//  538         CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
//  539        *p_err = OS_ERR_SCHED_LOCKED;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x63
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6d
        MOVX    @DPTR,A
//  540         return;
        SJMP    ??OSSchedUnlock_1
//  541     }
//  542 
//  543 #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
//  544     OS_SchedLockTimeMeasStop();
//  545 #endif
//  546 
//  547     CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
??OSSchedUnlock_4:
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
//  548     OSSched();                                              /* Run the scheduler                                      */
        ; Setup parameters for call to function OSSched
        LCALL   OSSched
//  549    *p_err = OS_ERR_NONE;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  550 }
??OSSchedUnlock_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
//  551 
//  552 /*$PAGE*/
//  553 /*
//  554 ************************************************************************************************************************
//  555 *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
//  556 *
//  557 * Description: This function is called to change the round-robin scheduling parameters.
//  558 *
//  559 * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
//  560 *
//  561 *              dflt_time_quanta  default number of ticks between time slices.  0 means assumes OSCfg_TickRate_Hz / 10.
//  562 *
//  563 *              p_err             is a pointer to a variable that will contain an error code returned by this function.
//  564 *
//  565 *                                    OS_ERR_NONE    The call was successful
//  566 *
//  567 * Returns    : none
//  568 ************************************************************************************************************************
//  569 */
//  570 
//  571 #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  572 void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
OSSchedRoundRobinCfg:
        CODE
//  573                             OS_TICK       dflt_time_quanta,
//  574                             OS_ERR       *p_err)
//  575 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     A,R1
        MOV     R7,A
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     ?V2,R4
        MOV     ?V3,R5
//  576     CPU_SR_ALLOC();
        MOV     R6,#0x0
//  577 
//  578 
//  579 
//  580 #ifdef OS_SAFETY_CRITICAL
//  581     if (p_err == (OS_ERR *)0) {
//  582         OS_SAFETY_CRITICAL_EXCEPTION();
//  583         return;
//  584     }
//  585 #endif
//  586 
//  587     CPU_CRITICAL_ENTER();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
//  588     if (en != DEF_ENABLED) {
        MOV     A,#0x1
        XRL     A,R7
        JZ      ??OSSchedRoundRobinCfg_0
//  589         OSSchedRoundRobinEn = DEF_DISABLED;
        MOV     DPTR,#OSSchedRoundRobinEn
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??OSSchedRoundRobinCfg_1
//  590     } else {
//  591         OSSchedRoundRobinEn = DEF_ENABLED;
??OSSchedRoundRobinCfg_0:
        MOV     DPTR,#OSSchedRoundRobinEn
        MOV     A,#0x1
        MOVX    @DPTR,A
//  592     }
//  593 
//  594     if (dflt_time_quanta > (OS_TICK)0) {
??OSSchedRoundRobinCfg_1:
        MOV     A,?V0
        ORL     A,?V1
        ORL     A,?V2
        ORL     A,?V3
        JZ      ??OSSchedRoundRobinCfg_2
//  595         OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
        MOV     DPTR,#OSSchedRoundRobinDfltTimeQuanta
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
        SJMP    ??OSSchedRoundRobinCfg_3
//  596     } else {
//  597         OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
??OSSchedRoundRobinCfg_2:
        MOV     DPTR,#OSCfg_TickRate_Hz
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_a
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     R0,#?V4
        MOV     R1,#?V0
        LCALL   ?UL_DIV_MOD
        MOV     R2,?V4
        MOV     R3,?V5
        MOV     R4,?V6
        MOV     R5,?V7
        MOV     DPTR,#OSSchedRoundRobinDfltTimeQuanta
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
//  598     }
//  599     CPU_CRITICAL_EXIT();
??OSSchedRoundRobinCfg_3:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  600    *p_err = OS_ERR_NONE;
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  601 }
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
//  602 #endif
//  603 
//  604 /*$PAGE*/
//  605 /*
//  606 ************************************************************************************************************************
//  607 *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
//  608 *
//  609 * Description: This function is called to give up the CPU when it is done executing before its time slice expires.
//  610 *
//  611 * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
//  612 *
//  613 *                             OS_ERR_NONE                   The call was successful
//  614 *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
//  615 *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
//  616 *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
//  617 *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
//  618 *
//  619 * Returns    : none
//  620 *
//  621 * Note(s)    : 1) This function MUST be called from a task.
//  622 ************************************************************************************************************************
//  623 */
//  624 
//  625 #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  626 void  OSSchedRoundRobinYield (OS_ERR  *p_err)
OSSchedRoundRobinYield:
        CODE
//  627 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V2,R2
        MOV     ?V3,R3
//  628     OS_RDY_LIST  *p_rdy_list;
//  629     OS_TCB       *p_tcb;
//  630     CPU_SR_ALLOC();
        MOV     R6,#0x0
//  631 
//  632 
//  633 
//  634 #ifdef OS_SAFETY_CRITICAL
//  635     if (p_err == (OS_ERR *)0) {
//  636         OS_SAFETY_CRITICAL_EXCEPTION();
//  637         return;
//  638     }
//  639 #endif
//  640 
//  641 #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
//  642     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
        MOV     DPTR,#OSIntNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSSchedRoundRobinYield_0
//  643        *p_err = OS_ERR_YIELD_ISR;
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOV     A,#-0x2f
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x7c
        MOVX    @DPTR,A
//  644         return;
        LJMP    ??OSSchedRoundRobinYield_1
//  645     }
//  646 #endif
//  647 
//  648     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
??OSSchedRoundRobinYield_0:
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JZ      ??OSSchedRoundRobinYield_2
//  649        *p_err = OS_ERR_SCHED_LOCKED;
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOV     A,#0x63
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x6d
        MOVX    @DPTR,A
//  650         return;
        LJMP    ??OSSchedRoundRobinYield_1
//  651     }
//  652 
//  653     if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
??OSSchedRoundRobinYield_2:
        MOV     DPTR,#OSSchedRoundRobinEn
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??OSSchedRoundRobinYield_3
//  654        *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOV     A,#0x7b
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x69
        MOVX    @DPTR,A
//  655         return;
        LJMP    ??OSSchedRoundRobinYield_1
//  656     }
//  657 
//  658     CPU_CRITICAL_ENTER();
??OSSchedRoundRobinYield_3:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
//  659     p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
        MOV     DPTR,#OSPrioCur
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     ?V0,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     ?V1,A
//  660     if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#0x2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x0
        JNC     ??OSSchedRoundRobinYield_4
//  661         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  662        *p_err = OS_ERR_ROUND_ROBIN_1;
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOV     A,#0x7a
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x69
        MOVX    @DPTR,A
//  663         return;
        SJMP    ??OSSchedRoundRobinYield_1
//  664     }
//  665 
//  666     OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
??OSSchedRoundRobinYield_4:
        ; Setup parameters for call to function OS_RdyListMoveHeadToTail
        MOV     R2,?V0
        MOV     R3,?V1
        LCALL   OS_RdyListMoveHeadToTail
//  667     p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
        MOV     DPL,?V0
        MOV     DPH,?V1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
//  668     if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
        MOV     A,R4
        ADD     A,#0x38
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R0
        ORL     A,R1
        ORL     A,R2
        ORL     A,R3
        JNZ     ??OSSchedRoundRobinYield_5
//  669         p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
        MOV     DPTR,#OSSchedRoundRobinDfltTimeQuanta
        LCALL   ?XLOAD_R0123
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XSTORE_R0123
        SJMP    ??OSSchedRoundRobinYield_6
//  670     } else {
//  671         p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
??OSSchedRoundRobinYield_5:
        MOV     A,R4
        ADD     A,#0x38
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XSTORE_R0123
//  672     }
//  673 
//  674     CPU_CRITICAL_EXIT();
??OSSchedRoundRobinYield_6:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
//  675 
//  676     OSSched();                                              /* Run new task                                           */
        ; Setup parameters for call to function OSSched
        LCALL   OSSched
//  677    *p_err = OS_ERR_NONE;
        MOV     DPL,?V2
        MOV     DPH,?V3
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  678 }
??OSSchedRoundRobinYield_1:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
//  679 #endif
//  680 
//  681 /*$PAGE*/
//  682 /*
//  683 ************************************************************************************************************************
//  684 *                                                 START MULTITASKING
//  685 *
//  686 * Description: This function is used to start the multitasking process which lets uC/OS-III manages the task that you
//  687 *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
//  688 *              one application task.
//  689 *
//  690 * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
//  691 *
//  692 *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned.
//  693 *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
//  694 *
//  695 * Returns    : none
//  696 *
//  697 * Note(s)    : 1) OSStartHighRdy() MUST:
//  698 *                 a) Call OSTaskSwHook() then,
//  699 *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
//  700 *                 c) Execute the task.
//  701 *
//  702 *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
//  703 ************************************************************************************************************************
//  704 */
//  705 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  706 void  OSStart (OS_ERR  *p_err)
OSStart:
        CODE
//  707 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  708 #ifdef OS_SAFETY_CRITICAL
//  709     if (p_err == (OS_ERR *)0) {
//  710         OS_SAFETY_CRITICAL_EXCEPTION();
//  711         return;
//  712     }
//  713 #endif
//  714 
//  715     if (OSRunning == OS_STATE_OS_STOPPED) {
        MOV     DPTR,#OSRunning
        MOVX    A,@DPTR
        JNZ     ??OSStart_0
//  716         OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
        ; Setup parameters for call to function OS_PrioGetHighest
        LCALL   OS_PrioGetHighest
        MOV     A,R1
        MOV     DPTR,#OSPrioHighRdy
        MOVX    @DPTR,A
//  717         OSPrioCur       = OSPrioHighRdy;
        MOV     DPTR,#OSPrioHighRdy
        MOVX    A,@DPTR
        MOV     DPTR,#OSPrioCur
        MOVX    @DPTR,A
//  718         OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
        MOV     DPTR,#OSPrioHighRdy
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBHighRdyPtr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  719         OSTCBCurPtr     = OSTCBHighRdyPtr;
        MOV     DPTR,#OSTCBHighRdyPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#OSTCBCurPtr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  720         OSRunning       = OS_STATE_OS_RUNNING;
        MOV     DPTR,#OSRunning
        MOV     A,#0x1
        MOVX    @DPTR,A
//  721         P1_4 = 0;
        CLR     0x90.4
//  722         OSStartHighRdy();                                   /* Execute target specific code to start task             */
        ; Setup parameters for call to function OSStartHighRdy
        LCALL   OSStartHighRdy
//  723        *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#-0x67
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x3a
        MOVX    @DPTR,A
        SJMP    ??OSStart_1
//  724     } else {
//  725        *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
??OSStart_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#-0x76
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x5e
        MOVX    @DPTR,A
//  726     }
//  727 }
??OSStart_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE _A_P1
//  728 
//  729 /*$PAGE*/
//  730 /*
//  731 ************************************************************************************************************************
//  732 *                                                    GET VERSION
//  733 *
//  734 * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
//  735 *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
//  736 *
//  737 * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
//  738 *                      variable to
//  739 *
//  740 *                         OS_ERR_NONE
//  741 *
//  742 * Returns    : The version number of uC/OS-III multiplied by 10000.
//  743 ************************************************************************************************************************
//  744 */
//  745 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  746 CPU_INT16U  OSVersion (OS_ERR  *p_err)
OSVersion:
        CODE
//  747 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
//  748 #ifdef OS_SAFETY_CRITICAL
//  749     if (p_err == (OS_ERR *)0) {
//  750         OS_SAFETY_CRITICAL_EXCEPTION();
//  751         return ((CPU_INT16U)0u);
//  752     }
//  753 #endif
//  754 
//  755    *p_err = OS_ERR_NONE;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  756     return (OS_VERSION);
        MOV     R2,#0x5d
        MOV     R3,#0x76
        POP     DPH
        POP     DPL
        RET
//  757 }
//  758 
//  759 /*$PAGE*/
//  760 /*
//  761 ************************************************************************************************************************
//  762 *                                                      IDLE TASK
//  763 *
//  764 * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
//  765 *              they are ALL waiting for event(s) to occur.
//  766 *
//  767 * Arguments  : p_arg    is an argument passed to the task when the task is created.
//  768 *
//  769 * Returns    : none
//  770 *
//  771 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
//  772 *
//  773 *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
//  774 *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
//  775 *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
//  776 *                 uC/OS-III would thus never recognize interrupts.
//  777 *
//  778 *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
//  779 ************************************************************************************************************************
//  780 */
//  781 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  782 void  OS_IdleTask (void  *p_arg)
OS_IdleTask:
        CODE
//  783 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
//  784     CPU_SR_ALLOC();
        MOV     R1,#0x0
//  785 
//  786 
//  787 
//  788     p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
//  789 
//  790     while (DEF_ON) {
//  791         CPU_CRITICAL_ENTER();
??OS_IdleTask_0:
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R1,A
//  792         OSIdleTaskCtr++;
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#OSIdleTaskCtr
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
//  793 #if OS_CFG_STAT_TASK_EN > 0u
//  794         OSStatTaskCtr++;
//  795 #endif
//  796         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        LCALL   CPU_SR_Restore
//  797 
//  798         OSIdleTaskHook();                                   /* Call user definable HOOK                               */
        ; Setup parameters for call to function OSIdleTaskHook
        LCALL   OSIdleTaskHook
        SJMP    ??OS_IdleTask_0
//  799     }
//  800 }
//  801 
//  802 /*$PAGE*/
//  803 /*
//  804 ************************************************************************************************************************
//  805 *                                               INITIALIZE THE IDLE TASK
//  806 *
//  807 * Description: This function initializes the idle task
//  808 *
//  809 * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
//  810 *
//  811 * Returns    : none
//  812 *
//  813 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
//  814 ************************************************************************************************************************
//  815 */
//  816 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  817 void  OS_IdleTaskInit (OS_ERR  *p_err)
OS_IdleTaskInit:
        CODE
//  818 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  819 #ifdef OS_SAFETY_CRITICAL
//  820     if (p_err == (OS_ERR *)0) {
//  821         OS_SAFETY_CRITICAL_EXCEPTION();
//  822         return;
//  823     }
//  824 #endif
//  825 
//  826     OSIdleTaskCtr = (OS_IDLE_CTR)0;
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R6,#0x0
        MOV     R7,#0x0
        MOV     DPTR,#OSIdleTaskCtr
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  827                                                             /* ---------------- CREATE THE IDLE TASK ---------------- */
//  828     OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
//  829                  (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
//  830                  (OS_TASK_PTR)OS_IdleTask,
//  831                  (void       *)0,
//  832                  (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
//  833                  (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
//  834                  (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
//  835                  (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
//  836                  (OS_MSG_QTY  )0u,
//  837                  (OS_TICK     )0u,
//  838                  (void       *)0,
//  839                  (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
//  840                  (OS_ERR     *)p_err);
        ; Setup parameters for call to function OSTaskCreate
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0,#0xb
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        CLR     A
        MOV     ?V0,A
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     DPTR,#__Constant_0
        LCALL   ?PUSH_XSTACK8_X_FOUR
        CLR     A
        MOV     ?V0,A
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     DPTR,#OSCfg_IdleTaskStkSize
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     DPTR,#OSCfg_IdleTaskStkLimit
        LCALL   ?PUSH_XSTACK8_X_TWO
        MOV     DPTR,#OSCfg_IdleTaskStkBasePtr
        LCALL   ?PUSH_XSTACK8_X_TWO
        CLR     A
        MOV     ?V0,A
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     ?V0,#OS_IdleTask & 0xff
        MOV     ?V1,#(OS_IdleTask >> 8) & 0xff
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R1,#0x1f
        MOV     R4,#`?<Constant "uC/OS-III Idle Task">` & 0xff
        MOV     R5,#(`?<Constant "uC/OS-III Idle Task">` >> 8) & 0xff
        MOV     R2,#OSIdleTaskTCB & 0xff
        MOV     R3,#(OSIdleTaskTCB >> 8) & 0xff
        LCALL   OSTaskCreate
        MOV     A,#0x16
        LCALL   ?DEALLOC_XSTACK8
//  841 }
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  842 
//  843 /*$PAGE*/
//  844 /*
//  845 ************************************************************************************************************************
//  846 *                                             BLOCK A TASK PENDING ON EVENT
//  847 *
//  848 * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
//  849 *              exist because it is common to a number of OSxxxPend() services.
//  850 *
//  851 * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
//  852 *              -----------    pending on the desired object.
//  853 
//  854 *              p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
//  855 *              -----          the caller must pass a NULL pointer.
//  856 *
//  857 *              pending_on     Specifies what the task will be pending on:
//  858 *
//  859 *                                 OS_TASK_PEND_ON_FLAG
//  860 *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
//  861 *                                 OS_TASK_PEND_ON_MUTEX
//  862 *                                 OS_TASK_PEND_ON_Q
//  863 *                                 OS_TASK_PEND_ON_SEM
//  864 *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
//  865 *
//  866 *              timeout        Is the amount of time the task will wait for the event to occur.
//  867 *
//  868 * Returns    : none
//  869 *
//  870 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
//  871 ************************************************************************************************************************
//  872 */
//  873 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  874 void  OS_Pend (OS_PEND_DATA  *p_pend_data,
OS_Pend:
        CODE
//  875                OS_PEND_OBJ   *p_obj,
//  876                OS_STATE       pending_on,
//  877                OS_TICK        timeout)
//  878 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     ?V2,R1
//  879     OS_PEND_LIST  *p_pend_list;
//  880 
//  881 
//  882 
//  883     OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
        MOV     A,?V2
        PUSH    A
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x1a
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        POP     A
        MOVX    @DPTR,A
//  884     OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x1b
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
//  885 
//  886     OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
//  887                  timeout);
        ; Setup parameters for call to function OS_TaskBlock
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_FOUR
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   OS_TaskBlock
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
//  888 
//  889     if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
        MOV     A,R6
        ORL     A,R7
        JZ      ??OS_Pend_0
//  890         p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
        MOV     A,R6
        ADD     A,#0x6
        MOV     ?V6,A
        CLR     A
        ADDC    A,R7
        MOV     ?V7,A
//  891         p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  892         OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
//  893                         (OS_PEND_DATA *)p_pend_data,
//  894                         (OS_OBJ_QTY    )1);
        ; Setup parameters for call to function OS_PendDataInit
        MOV     ?V4,#0x1
        MOV     ?V5,#0x0
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,?V0
        MOV     R5,?V1
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   OS_PendDataInit
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  895         OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
//  896                               p_pend_data);
        ; Setup parameters for call to function OS_PendListInsertPrio
        MOV     R4,?V0
        MOV     R5,?V1
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   OS_PendListInsertPrio
        SJMP    ??OS_Pend_1
//  897     } else {
//  898         OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
??OS_Pend_0:
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x22
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  899         OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x18
        MOV     DPL,A
        XCH     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  900     }
//  901 #if OS_CFG_DBG_EN > 0u
//  902     OS_PendDbgNameAdd(p_obj,
//  903                       OSTCBCurPtr);
??OS_Pend_1:
        ; Setup parameters for call to function OS_PendDbgNameAdd
        MOV     DPTR,#OSTCBCurPtr
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendDbgNameAdd
//  904 #endif
//  905 }
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
//  906 
//  907 /*$PAGE*/
//  908 /*
//  909 ************************************************************************************************************************
//  910 *                                                     ABORT PENDING
//  911 *
//  912 * Description: This function is called by OSxxxPendAbort() functions to abort pending on an event.
//  913 *
//  914 * Arguments  : p_obj          Is a pointer to the object to pend abort.
//  915 *              -----
//  916 *
//  917 *              p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
//  918 *              -----
//  919 *
//  920 *              ts             The is a timestamp as to when the pend abort occurred
//  921 *
//  922 * Returns    : none
//  923 *
//  924 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
//  925 ************************************************************************************************************************
//  926 */
//  927 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  928 void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
OS_PendAbort:
        CODE
//  929                     OS_TCB       *p_tcb,
//  930                     CPU_TS        ts)
//  931 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V4,R2
        MOV     ?V5,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
//  932     switch (p_tcb->TaskState) {
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??OS_PendAbort_0
        DEC     A
        JZ      ??OS_PendAbort_0
        DEC     A
        JZ      ??OS_PendAbort_1
        DEC     A
        JZ      ??OS_PendAbort_1
        DEC     A
        JZ      ??OS_PendAbort_0
        DEC     A
        JZ      ??OS_PendAbort_0
        DEC     A
        JNZ     $+5
        LJMP    ??OS_PendAbort_2
        DEC     A
        JNZ     $+5
        LJMP    ??OS_PendAbort_2
        LJMP    ??OS_PendAbort_3
//  933         case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
//  934         case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
//  935         case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
//  936         case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
//  937              break;
??OS_PendAbort_0:
        LJMP    ??OS_PendAbort_3
//  938 
//  939         case OS_TASK_STATE_PEND:
//  940         case OS_TASK_STATE_PEND_TIMEOUT:
//  941              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_PendAbort_1:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_PendAbort_4
//  942                  OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
//  943                                p_tcb,
//  944                                ts);
        ; Setup parameters for call to function OS_PendAbort1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V4
        MOV     R3,?V5
        LCALL   OS_PendAbort1
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
//  945              }
//  946 #if (OS_MSG_EN > 0u)
//  947              p_tcb->MsgPtr     = (void      *)0;
??OS_PendAbort_4:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  948              p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  949 #endif
//  950              p_tcb->TS         = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
//  951              if (p_obj != (OS_PEND_OBJ *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JZ      ??OS_PendAbort_5
//  952                  OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
//  953              }
//  954              OS_TaskRdy(p_tcb);
??OS_PendAbort_5:
        ; Setup parameters for call to function OS_TaskRdy
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TaskRdy
//  955              p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
//  956              p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x1
        MOVX    @DPTR,A
//  957              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
//  958              break;
        LJMP    ??OS_PendAbort_3
//  959 
//  960         case OS_TASK_STATE_PEND_SUSPENDED:
//  961         case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
//  962              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_PendAbort_2:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_PendAbort_6
//  963                  OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
//  964                                p_tcb,
//  965                                ts);
        ; Setup parameters for call to function OS_PendAbort1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V4
        MOV     R3,?V5
        LCALL   OS_PendAbort1
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
//  966              }
//  967 #if (OS_MSG_EN > 0u)
//  968              p_tcb->MsgPtr     = (void      *)0;
??OS_PendAbort_6:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  969              p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  970 #endif
//  971              p_tcb->TS         = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
//  972              if (p_obj != (OS_PEND_OBJ *)0) {
        MOV     A,?V4
        ORL     A,?V5
        JZ      ??OS_PendAbort_7
//  973                  OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
//  974              }
//  975              OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
??OS_PendAbort_7:
        ; Setup parameters for call to function OS_TickListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickListRemove
//  976              p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x4
        MOVX    @DPTR,A
//  977              p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x1
        MOVX    @DPTR,A
//  978              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
//  979              break;
//  980 
//  981         default:
//  982              break;
//  983     }
//  984 }
??OS_PendAbort_3:
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
//  985 
//  986 /*$PAGE*/
//  987 /*
//  988 ************************************************************************************************************************
//  989 *                                           PEND ABORT A TASK PENDING ON MULTIPLE OBJECTS
//  990 *
//  991 * Description: This function is called when a task is pending on multiple objects and one of the objects has been pend
//  992 *              aborted.  This function needs to indicate to the caller which object was pend aborted by placing the
//  993 *              address of the object in the OS_PEND_DATA table corresponding to the pend aborted object.
//  994 *
//  995 *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
//  996 *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries of the
//  997 *              OS_TCB would be set to six (6) in this case.  As shown, when the pend call returns because a task pend
//  998 *              aborted 'Obj C' then, only the one entry contains the .RdyObjPtr filled in data and the other entries
//  999 *              contains NULL pointers and zero data.
// 1000 *
// 1001 *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
// 1002 *
// 1003 *
// 1004 *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
// 1005 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1006 *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
// 1007 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1008 *                                         |  Obj B       |  0           | 0            | 0            | 0            |
// 1009 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1010 *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
// 1011 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1012 *                                         |  Obj D       |  0           | 0            | 0            | 0            |
// 1013 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1014 *                                         |  Obj E       |  0           | 0            | 0            | 0            |
// 1015 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1016 *                                         |  Obj F       |  0           | 0            | 0            | 0            |
// 1017 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1018 *
// 1019 *
// 1020 * Arguments  : p_obj        is a pointer to the object being pend aborted to
// 1021 *              -----
// 1022 *
// 1023 *              p_tcb        is a pointer to the OS_TCB of the task that we'll abort he pend for
// 1024 *              -----
// 1025 *
// 1026 *              ts           is the time stamp of when the pend abort occurred
// 1027 *
// 1028 * Returns    : none
// 1029 *
// 1030 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1031 ************************************************************************************************************************
// 1032 */
// 1033 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1034 void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
OS_PendAbort1:
        CODE
// 1035                      OS_TCB       *p_tcb,
// 1036                      CPU_TS        ts)
// 1037 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 1038     OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
// 1039     OS_PEND_DATA   *p_pend_data;
// 1040 
// 1041 
// 1042 
// 1043     p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
        MOV     A,R4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1044     n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
        MOV     A,R4
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        SJMP    ??OS_PendAbort1_0
// 1045 
// 1046     while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
// 1047         if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
// 1048             p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
// 1049             p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
// 1050             break;
// 1051         }
// 1052         p_pend_data++;
??OS_PendAbort1_1:
        MOV     A,R0
        ADD     A,#0x12
        MOV     R0,A
        JNC     ??OS_PendAbort1_2
        INC     R1
// 1053         n_pend_list--;
??OS_PendAbort1_2:
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
??OS_PendAbort1_0:
        MOV     A,R4
        ORL     A,R5
        JZ      ??OS_PendAbort1_3
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R2
        XRL     A,R6
        JNZ     ??OS_PendAbort1_4
        MOV     A,R3
        XRL     A,R7
??OS_PendAbort1_4:
        JNZ     ??OS_PendAbort1_1
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XLOAD_R4567
        MOV     A,R0
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        LCALL   ?XSTORE_R4567
// 1054     }
// 1055 }
??OS_PendAbort1_3:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1056 
// 1057 /*$PAGE*/
// 1058 /*
// 1059 ************************************************************************************************************************
// 1060 *                                              INITIALIZE A WAIT LIST TABLE
// 1061 *
// 1062 * Description: This function is called to initialize the fields of a table of OS_PEND_DATA entries.  It's assumed that
// 1063 *              the .PendObjPtr field of each entry in the table is set by the caller and thus will NOT be touched by
// 1064 *              this function.
// 1065 *
// 1066 * Arguments  : p_tcb              is a pointer to the TCB of the task that we want to pend abort.
// 1067 *              -----
// 1068 *
// 1069 *              p_pend_data_tbl    is a pointer to a table (see below) of OS_PEND_DATA elements to initialize.
// 1070 *              ---------------
// 1071 *
// 1072 *                                  .PendObjPtr .RdyObjPtr .RdyMsgPtr .RdyMsgSize .RdyTS .TCBPtr .NextPtr .PrevPtr
// 1073 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    ^
// 1074 *               p_pend_data_tbl-> |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1075 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
// 1076 *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1077 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
// 1078 *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1079 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+  size
// 1080 *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1081 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
// 1082 *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1083 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
// 1084 *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
// 1085 *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    V
// 1086 *
// 1087 *              tbl_size           is the size of the table in number of entries
// 1088 *
// 1089 * Returns    : none
// 1090 *
// 1091 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
// 1092 *
// 1093 *              2) It's possible for the table to be of size 1 when multi-pend is not used
// 1094 *
// 1095 *              3) Note that the .PendObjPtr is NOT touched because it's assumed to be set by the caller.
// 1096 ************************************************************************************************************************
// 1097 */
// 1098 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1099 void  OS_PendDataInit (OS_TCB        *p_tcb,
OS_PendDataInit:
        CODE
// 1100                        OS_PEND_DATA  *p_pend_data_tbl,
// 1101                        OS_OBJ_QTY     tbl_size)
// 1102 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
// 1103     OS_OBJ_QTY  i;
// 1104 
// 1105 
// 1106 
// 1107     p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
        MOV     A,?V2
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,?V3
        MOV     DPH,A
        MOV     A,?V4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V5
        MOVX    @DPTR,A
// 1108     p_tcb->PendDataTblPtr     = p_pend_data_tbl;
        MOV     A,?V2
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V3
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1109 
// 1110     for (i = 0u; i < tbl_size; i++) {
        MOV     ?V0,#0x0
        MOV     ?V1,#0x0
        LJMP    ??OS_PendDataInit_0
// 1111         p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
??OS_PendDataInit_1:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1112         p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1113         p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1114         p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1115         p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
        MOV     A,R2
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1116         p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R6,#0x0
        MOV     R7,#0x0
        MOV     A,R2
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 1117         p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V3
        MOVX    @DPTR,A
// 1118         p_pend_data_tbl++;
        MOV     A,R2
        ADD     A,#0x12
        MOV     R2,A
        JNC     ??OS_PendDataInit_2
        INC     R3
// 1119     }
??OS_PendDataInit_2:
        INC     ?V0
        MOV     A,?V0
        JNZ     ??OS_PendDataInit_0
        INC     ?V1
??OS_PendDataInit_0:
        CLR     C
        MOV     A,?V0
        SUBB    A,?V4
        MOV     A,?V1
        SUBB    A,?V5
        JNC     $+5
        LJMP    ??OS_PendDataInit_1
// 1120 }
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 1121 
// 1122 /*$PAGE*/
// 1123 /*
// 1124 ************************************************************************************************************************
// 1125 *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
// 1126 *
// 1127 * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
// 1128 *              using a kernel aware tool.
// 1129 *
// 1130 * Arguments  : p_obj              is a pointer to the object being pended on
// 1131 *
// 1132 *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
// 1133 *
// 1134 * Returns    : none
// 1135 *
// 1136 * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
// 1137 ************************************************************************************************************************
// 1138 */
// 1139 
// 1140 
// 1141 #if OS_CFG_DBG_EN > 0u

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1142 void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
OS_PendDbgNameAdd:
        CODE
// 1143                          OS_TCB       *p_tcb)
// 1144 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
// 1145     OS_PEND_LIST  *p_pend_list;
// 1146     OS_PEND_DATA  *p_pend_data;
// 1147     OS_TCB        *p_tcb1;
// 1148 
// 1149 
// 1150     if (p_obj != (OS_PEND_OBJ *)0) {
        MOV     A,R2
        ORL     A,R3
        JZ      ??OS_PendDbgNameAdd_0
// 1151         p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R4
        ADD     A,#-0x73
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1152         p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        MOV     A,R2
        ADD     A,#0x6
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
// 1153         p_pend_data       =  p_pend_list->HeadPtr;
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
// 1154         p_tcb1            =  p_pend_data->TCBPtr;
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1155         p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
        MOV     A,R0
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??OS_PendDbgNameAdd_1
// 1156     } else {
// 1157         switch (p_tcb->PendOn) {
??OS_PendDbgNameAdd_0:
        MOV     A,R4
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#-0x2
        JZ      ??OS_PendDbgNameAdd_2
        ADD     A,#-0x5
        JZ      ??OS_PendDbgNameAdd_3
        SJMP    ??OS_PendDbgNameAdd_4
// 1158             case OS_TASK_PEND_ON_TASK_Q:
// 1159                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
??OS_PendDbgNameAdd_2:
        MOV     A,R4
        ADD     A,#-0x73
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     A,#`?<Constant "Task Q">` & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(`?<Constant "Task Q">` >> 8) & 0xff
        MOVX    @DPTR,A
// 1160                  break;
        SJMP    ??OS_PendDbgNameAdd_1
// 1161 
// 1162             case OS_TASK_PEND_ON_TASK_SEM:
// 1163                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
??OS_PendDbgNameAdd_3:
        MOV     A,R4
        ADD     A,#-0x73
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     A,#`?<Constant "Task Sem">` & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(`?<Constant "Task Sem">` >> 8) & 0xff
        MOVX    @DPTR,A
// 1164                  break;
        SJMP    ??OS_PendDbgNameAdd_1
// 1165 
// 1166             default:
// 1167                  p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
??OS_PendDbgNameAdd_4:
        MOV     A,R4
        ADD     A,#-0x73
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     A,#`?<Constant " ">` & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(`?<Constant " ">` >> 8) & 0xff
        MOVX    @DPTR,A
// 1168                  break;
// 1169         }
// 1170     }
// 1171 }
??OS_PendDbgNameAdd_1:
        POP     DPH
        POP     DPL
        RET
// 1172 
// 1173 
// 1174 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1175 void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
OS_PendDbgNameRemove:
        CODE
// 1176                             OS_TCB       *p_tcb)
// 1177 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
// 1178     OS_PEND_LIST  *p_pend_list;
// 1179     OS_PEND_DATA  *p_pend_data;
// 1180     OS_TCB        *p_tcb1;
// 1181 
// 1182 
// 1183     p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
        MOV     A,R4
        ADD     A,#-0x73
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     A,#`?<Constant " ">` & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(`?<Constant " ">` >> 8) & 0xff
        MOVX    @DPTR,A
// 1184     p_pend_list       = &p_obj->PendList;
        MOV     A,R2
        ADD     A,#0x6
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
// 1185     p_pend_data       =  p_pend_list->HeadPtr;
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
// 1186     if (p_pend_data  != (OS_PEND_DATA *)0) {
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??OS_PendDbgNameRemove_0
// 1187         p_tcb1            = p_pend_data->TCBPtr;
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1188         p_obj->DbgNamePtr = p_tcb1->NamePtr;
        MOV     A,R0
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??OS_PendDbgNameRemove_1
// 1189     } else {
// 1190         p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
??OS_PendDbgNameRemove_0:
        MOV     A,R2
        ADD     A,#0x10
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOV     A,#`?<Constant " ">` & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(`?<Constant " ">` >> 8) & 0xff
        MOVX    @DPTR,A
// 1191     }
// 1192 }
??OS_PendDbgNameRemove_1:
        POP     DPH
        POP     DPL
        RET
// 1193 #endif
// 1194 
// 1195 /*$PAGE*/
// 1196 /*
// 1197 ************************************************************************************************************************
// 1198 *                               CHANGE THE PRIORITY OF A TASK WAITING IN ONE OR MORE PEND LISTS
// 1199 *
// 1200 * Description: This function is called to change the position of a task waiting in one or more pend lists.  Because a
// 1201 *              task can be waiting on multiple objects then each pend list needs to be updated.  Specifically, the
// 1202 *              task can be the highest priority task waiting on one pend list, the lowest priority task waiting in yet
// 1203 *              another pend list or somewhere else in another pend list.  Because of this, we need to be able to change
// 1204 *              each of those pend lists individually.
// 1205 *
// 1206 *              The drawing below shows an example of a task (OS_TCB) that belongs to 3 separate pend lists.  Each
// 1207 *              pend list can contain multiple tasks (the .PrevPtr and .NextPtr show a '?' to indicate this).  The OS_TCB
// 1208 *              contains a pointer (.PendDataTblPtr) to the first entry in the list of pend lists.
// 1209 *
// 1210 *                                                                                                          OS_TCB
// 1211 *                                                                                                   +--------------------+
// 1212 *                                                                                                   |                    |
// 1213 *                                                                                                   +--------------------+
// 1214 *                                                                                                   | PendDataTblEntries |
// 1215 *                                      Point to first entry in the OS_PEND_DATA table (i.e. [0])    +--------------------+
// 1216 *                                          /-----------------------------<------------------------- | PendDataTblPtr     |
// 1217 *                                          |                                                        +--------------------+
// 1218 *                                          |                                                                 ^
// 1219 *              OS_PEND_LIST                |                                                                 |
// 1220 *              +------------+              |                                                                 |
// 1221 *              | TailPtr    |              |                                                                 |
// 1222 *              +------------+              |                                                                 |
// 1223 *              | HeadPtr    |              |                                                                 |
// 1224 *              +------------+              |                                        /---------->-------------/
// 1225 *              | NbrEntries |              |                                        |                        |
// 1226 *              +------------+     [0]      V   OS_PEND_DATA                         |                        |
// 1227 *                                     +---------+------------+-------+---------+--------+---------+          |
// 1228 *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
// 1229 *                                     +---------+------------+-------+---------+--------+---------+          |
// 1230 *                                                                                                            |
// 1231 *                                                                                                            |
// 1232 *                                                                                                            |
// 1233 *                                                                                                            |
// 1234 *                                                                                                            |
// 1235 *              OS_PEND_LIST                                                                Point back to TCB |
// 1236 *              +------------+                                                                                |
// 1237 *              | TailPtr    |                                                                                |
// 1238 *              +------------+                                                                                |
// 1239 *              | HeadPtr    |                                                                                |
// 1240 *              +------------+                                                      /----------->-------------/
// 1241 *              | NbrEntries |                                                      |                         |
// 1242 *              +------------+     [1]          OS_PEND_DATA                        |                         |
// 1243 *                                     +---------+------------+-------+---------+--------+---------+          |
// 1244 *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
// 1245 *                                     +---------+------------+-------+---------+--------+---------+          |
// 1246 *                                                                                                            |
// 1247 *                                                                                                            |
// 1248 *                                                                                                            |
// 1249 *                                                                                                            |
// 1250 *                                                                                                            |
// 1251 *              OS_PEND_LIST                                                                                  |
// 1252 *              +------------+                                                                                |
// 1253 *              | TailPtr    |                                                                                |
// 1254 *              +------------+                                                                                |
// 1255 *              | HeadPtr    |                                                                                |
// 1256 *              +------------+                                                      /----------->-------------/
// 1257 *              | NbrEntries |                                                      |
// 1258 *              +------------+     [2]          OS_PEND_DATA                        |
// 1259 *                                     +---------+------------+-------+---------+--------+---------+
// 1260 *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | ----> ?
// 1261 *                                     +---------+------------+-------+---------+--------+---------+
// 1262 *
// 1263 *
// 1264 * Arguments  : p_tcb       is a pointer to the TCB of the task to move
// 1265 *              -----
// 1266 *
// 1267 *              prio_new    is the new priority for the task
// 1268 *
// 1269 * Returns    : none
// 1270 *
// 1271 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1272 *
// 1273 *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
// 1274 ************************************************************************************************************************
// 1275 */
// 1276 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1277 void  OS_PendListChangePrio (OS_TCB   *p_tcb,
OS_PendListChangePrio:
        CODE
// 1278                              OS_PRIO   prio_new)
// 1279 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        MOV     A,#-0xc
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V4,R1
// 1280     OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
// 1281     OS_PEND_DATA   *p_pend_data;
// 1282     OS_PEND_LIST   *p_pend_list;
// 1283     OS_PEND_OBJ    *p_obj;
// 1284 
// 1285 
// 1286     p_tcb->Prio = prio_new;
        MOV     A,?V4
        PUSH    A
        MOV     A,R2
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        POP     A
        MOVX    @DPTR,A
// 1287     p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
        MOV     A,R2
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1288     n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
        MOV     A,R2
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
        SJMP    ??OS_PendListChangePrio_0
// 1289 
// 1290     while (n_pend_list > 0u) {
// 1291         p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
??OS_PendListChangePrio_1:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1292         p_pend_list = &p_obj->PendList;
        MOV     A,R0
        ADD     A,#0x6
        MOV     ?V0,A
        CLR     A
        ADDC    A,R1
        MOV     ?V1,A
// 1293         if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#0x2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x0
        JC      ??OS_PendListChangePrio_2
// 1294             OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
// 1295                                p_pend_data);
        ; Setup parameters for call to function OS_PendListRemove1
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0
        MOV     R3,?V1
        LCALL   OS_PendListRemove1
// 1296             OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
// 1297                                   p_pend_data);
        ; Setup parameters for call to function OS_PendListInsertPrio
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0
        MOV     R3,?V1
        LCALL   OS_PendListInsertPrio
// 1298         }
// 1299         p_pend_data++;                                              /* Point to next wait list                        */
??OS_PendListChangePrio_2:
        MOV     A,R6
        ADD     A,#0x12
        MOV     R6,A
        JNC     ??OS_PendListChangePrio_3
        INC     R7
// 1300         n_pend_list--;
??OS_PendListChangePrio_3:
        MOV     A,?V2
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
// 1301     }
??OS_PendListChangePrio_0:
        MOV     A,?V2
        ORL     A,?V3
        JNZ     ??OS_PendListChangePrio_1
// 1302 }
        MOV     R7,#0x5
        LJMP    ?FUNC_LEAVE_XDATA
// 1303 
// 1304 /*$PAGE*/
// 1305 /*
// 1306 ************************************************************************************************************************
// 1307 *                                                INITIALIZE A WAIT LIST
// 1308 *
// 1309 * Description: This function is called to initialize the fields of an OS_PEND_LIST.
// 1310 *
// 1311 * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
// 1312 *              -----------
// 1313 *
// 1314 * Returns    : none
// 1315 *
// 1316 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
// 1317 ************************************************************************************************************************
// 1318 */
// 1319 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1320 void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
OS_PendListInit:
        CODE
// 1321 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
// 1322     p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1323     p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1324     p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1325 }
        POP     DPH
        POP     DPL
        RET
// 1326 
// 1327 /*$PAGE*/
// 1328 /*
// 1329 ************************************************************************************************************************
// 1330 *                                     INSERT PEND DATA AT THE BEGINNING OF A WAIT LIST
// 1331 *
// 1332 * Description: This function is called to place an OS_PEND_DATA entry at the beginning of a linked list as follows:
// 1333 *
// 1334 *              CASE 0: Insert in an empty list.
// 1335 *
// 1336 *                     OS_PEND_LIST
// 1337 *                     +--------------+
// 1338 *                     | TailPtr      |-> 0
// 1339 *                     +--------------+
// 1340 *                     | HeadPtr      |-> 0
// 1341 *                     +--------------+
// 1342 *                     | NbrEntries=0 |
// 1343 *                     +--------------+
// 1344 *
// 1345 *
// 1346 *
// 1347 *              CASE 1: Insert BEFORE the current head of list
// 1348 *
// 1349 *                     OS_PEND_LIST
// 1350 *                     +--------------+         OS_PEND_DATA
// 1351 *                     | TailPtr      |--+---> +------------+
// 1352 *                     +--------------+  |     | NextPtr    |->0
// 1353 *                     | HeadPtr      |--/     +------------+
// 1354 *                     +--------------+     0<-| PrevPtr    |
// 1355 *                     | NbrEntries=1 |        +------------+
// 1356 *                     +--------------+        |            |
// 1357 *                                             +------------+
// 1358 *                                             |            |
// 1359 *                                             +------------+
// 1360 *
// 1361 *
// 1362 * Arguments  : p_pend_list    is a pointer to a wait list found inside an object.  The OS_PEND_DATA entry will be
// 1363 *              -----------    inserted at the head of the list.
// 1364 *
// 1365 *              p_pend_data    is a pointer to the OS_PEND_DATA entry to add to the list
// 1366 *              -----------
// 1367 *
// 1368 * Returns    : none
// 1369 *
// 1370 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1371 ************************************************************************************************************************
// 1372 */
// 1373 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1374 void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
OS_PendListInsertHead:
        CODE
// 1375                              OS_PEND_DATA  *p_pend_data)
// 1376 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 1377     OS_PEND_DATA  *p_pend_data_next;
// 1378 
// 1379 
// 1380 
// 1381     p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1382     p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1383     p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1384     p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
// 1385     if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??OS_PendListInsertHead_0
// 1386         p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1387     }
// 1388     p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
??OS_PendListInsertHead_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1389     if (p_pend_list->NbrEntries == 1u) {
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??OS_PendListInsertHead_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??OS_PendListInsertHead_1:
        JNZ     ??OS_PendListInsertHead_2
// 1390         p_pend_list->TailPtr = p_pend_data;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1391     }
// 1392 }
??OS_PendListInsertHead_2:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1393 
// 1394 /*$PAGE*/
// 1395 /*
// 1396 ************************************************************************************************************************
// 1397 *                                   INSERT PEND DATA BASED ON IT'S PRIORITY IN A LIST
// 1398 *
// 1399 * Description: This function is called to place an OS_PEND_DATA entry in a linked list based on its priority.  The
// 1400 *              highest priority being placed at the head of the list.  It's assumed that the OS_PEND_DATA entry to
// 1401 *              insert points to the TCB of the task being inserted.  The TCB is also assumed to contain the priority
// 1402 *              of the task in its .Prio field.
// 1403 *
// 1404 *              CASE 0: Insert in an empty list.
// 1405 *
// 1406 *                     OS_PEND_LIST
// 1407 *                     +---------------+
// 1408 *                     | TailPtr       |-> 0
// 1409 *                     +---------------+
// 1410 *                     | HeadPtr       |-> 0
// 1411 *                     +---------------+
// 1412 *                     | NbrEntries=0  |
// 1413 *                     +---------------+
// 1414 *
// 1415 *
// 1416 *
// 1417 *              CASE 1: Insert BEFORE or AFTER an OS_TCB
// 1418 *
// 1419 *                     OS_PEND_LIST
// 1420 *                     +--------------+         OS_PEND_DATA
// 1421 *                     | TailPtr      |--+---> +------------+
// 1422 *                     +--------------+  |     | NextPtr    |->0
// 1423 *                     | HeadPtr      |--/     +------------+
// 1424 *                     +--------------+     0<-| PrevPtr    |
// 1425 *                     | NbrEntries=1 |        +------------+
// 1426 *                     +--------------+        |            |
// 1427 *                                             +------------+
// 1428 *                                             |            |
// 1429 *                                             +------------+
// 1430 *
// 1431 *
// 1432 *                     OS_PEND_LIST
// 1433 *                     +--------------+
// 1434 *                     | TailPtr      |-----------------------------------------------+
// 1435 *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
// 1436 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 1437 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 1438 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 1439 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 1440 *                                             +------------+       +------------+        +------------+
// 1441 *                                             |            |       |            |        |            |
// 1442 *                                             +------------+       +------------+        +------------+
// 1443 *                                             |            |       |            |        |            |
// 1444 *                                             +------------+       +------------+        +------------+
// 1445 *
// 1446 *
// 1447 * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_PEND_DATA entry will be inserted
// 1448 *              -----------
// 1449 *
// 1450 *              p_pend_data    is the OS_PEND_DATA to insert in the list
// 1451 *              -----------
// 1452 *
// 1453 * Returns    : none
// 1454 *
// 1455 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1456 *
// 1457 *              2) 'p_pend_data->TCBPtr->Prio' contains the priority of the TCB associated with the entry to insert.
// 1458 *                 We can compare this priority with the priority of other entries in the list.
// 1459 ************************************************************************************************************************
// 1460 */
// 1461 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1462 void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
OS_PendListInsertPrio:
        CODE
// 1463                              OS_PEND_DATA  *p_pend_data)
// 1464 {
        REQUIRE ?V0
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 1465     OS_PRIO        prio;
// 1466     OS_TCB        *p_tcb;
// 1467     OS_TCB        *p_tcb_next;
// 1468     OS_PEND_DATA  *p_pend_data_prev;
// 1469     OS_PEND_DATA  *p_pend_data_next;
// 1470 
// 1471 
// 1472 
// 1473     p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1474     prio  = p_tcb->Prio;
        MOV     A,R0
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0,A
// 1475     if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_PendListInsertPrio_0
// 1476         p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1477         p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1478         p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1479         p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1480         p_pend_list->TailPtr    = p_pend_data;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        LJMP    ??OS_PendListInsertPrio_1
// 1481     } else {
// 1482         p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
??OS_PendListInsertPrio_0:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1483         p_pend_data_next = p_pend_list->HeadPtr;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        SJMP    ??OS_PendListInsertPrio_2
// 1484         while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
// 1485             p_tcb_next   = p_pend_data_next->TCBPtr;
// 1486             if (prio < p_tcb_next->Prio) {
// 1487                 break;                                                /*         Found! ... insert BEFORE current     */
// 1488             } else {
// 1489                 p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
??OS_PendListInsertPrio_3:
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1490             }
??OS_PendListInsertPrio_2:
        MOV     A,R0
        ORL     A,R1
        JZ      ??OS_PendListInsertPrio_4
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R6
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,?V0
        CLR     C
        SUBB    A,R6
        JNC     ??OS_PendListInsertPrio_3
// 1491         }
// 1492         if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
??OS_PendListInsertPrio_4:
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_PendListInsertPrio_5
// 1493             p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1494             p_pend_data_prev          = p_pend_list->TailPtr;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1495             p_pend_data->PrevPtr      = p_pend_data_prev;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 1496             p_pend_data_prev->NextPtr = p_pend_data;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1497             p_pend_list->TailPtr      = p_pend_data;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        SJMP    ??OS_PendListInsertPrio_1
// 1498         } else {
// 1499             if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
??OS_PendListInsertPrio_5:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R6
        ORL     A,R7
        JNZ     ??OS_PendListInsertPrio_6
// 1500                 p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1501                 p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1502                 p_pend_data->NextPtr       = p_pend_data_next;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1503                 p_pend_list->HeadPtr       = p_pend_data;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        SJMP    ??OS_PendListInsertPrio_1
// 1504             } else {
// 1505                 p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
??OS_PendListInsertPrio_6:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1506                 p_pend_data->PrevPtr       = p_pend_data_prev;
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1507                 p_pend_data->NextPtr       = p_pend_data_next;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1508                 p_pend_data_prev->NextPtr  = p_pend_data;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1509                 p_pend_data_next->PrevPtr  = p_pend_data;
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1510             }
// 1511         }
// 1512     }
// 1513 }
??OS_PendListInsertPrio_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1514 
// 1515 /*$PAGE*/
// 1516 /*
// 1517 ************************************************************************************************************************
// 1518 *                           REMOVE TASK FROM PEND LIST(s) KNOWING ONLY WHICH TCB TO REMOVE
// 1519 *
// 1520 * Description: This function is called to remove a task from a pend list knowing only the TCB of the task to remove
// 1521 *
// 1522 *
// 1523 *              CASE 0: OS_PEND_DATA list is empty, nothing to do.
// 1524 *
// 1525 *              CASE 1: Only 1 OS_PEND_DATA in the list.
// 1526 *
// 1527 *                     OS_PEND_LIST
// 1528 *                     +--------------+         OS_PEND_DATA
// 1529 *                     | TailPtr      |--+---> +------------+
// 1530 *                     +--------------+  |     | NextPtr    |->0
// 1531 *                     | HeadPtr      |--/     +------------+
// 1532 *                     +--------------+     0<-| PrevPtr    |
// 1533 *                     | NbrEntries=1 |        +------------+
// 1534 *                     +--------------+        |            |
// 1535 *                                             +------------+
// 1536 *                                             |            |
// 1537 *                                             +------------+
// 1538 *
// 1539 *              CASE N: Two or more OS_PEND_DATAs in the list.
// 1540 *
// 1541 *                     OS_PEND_LIST
// 1542 *                     +--------------+
// 1543 *                     | TailPtr      |-----------------------------------------------+
// 1544 *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
// 1545 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 1546 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 1547 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 1548 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 1549 *                                             +------------+       +------------+        +------------+
// 1550 *                                             |            |       |            |        |            |
// 1551 *                                             +------------+       +------------+        +------------+
// 1552 *                                             |            |       |            |        |            |
// 1553 *                                             +------------+       +------------+        +------------+
// 1554 *
// 1555 *
// 1556 * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from all pend lists
// 1557 *              -----
// 1558 *
// 1559 * Returns    : none
// 1560 *
// 1561 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1562 ************************************************************************************************************************
// 1563 */
// 1564 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1565 void  OS_PendListRemove (OS_TCB  *p_tcb)
OS_PendListRemove:
        CODE
// 1566 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V0,R2
        MOV     ?V1,R3
// 1567     OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
// 1568     OS_PEND_DATA   *p_pend_data;
// 1569     OS_PEND_LIST   *p_pend_list;
// 1570     OS_PEND_OBJ    *p_obj;
// 1571 
// 1572 
// 1573 
// 1574     p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
        MOV     A,?V0
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1575     n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
        MOV     A,?V0
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,?V1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V3,A
        SJMP    ??OS_PendListRemove_0
// 1576 
// 1577     while (n_pend_list > (OS_OBJ_QTY)0) {
// 1578         p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
??OS_PendListRemove_1:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1579         p_pend_list = &p_obj->PendList;
        MOV     A,R0
        ADD     A,#0x6
        MOV     R2,A
        CLR     A
        ADDC    A,R1
        MOV     R3,A
// 1580         OS_PendListRemove1(p_pend_list,
// 1581                            p_pend_data);
        ; Setup parameters for call to function OS_PendListRemove1
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        LCALL   OS_PendListRemove1
// 1582         p_pend_data++;
        MOV     A,R6
        ADD     A,#0x12
        MOV     R6,A
        JNC     ??OS_PendListRemove_2
        INC     R7
// 1583         n_pend_list--;
??OS_PendListRemove_2:
        MOV     A,?V2
        ADD     A,#-0x1
        MOV     ?V2,A
        MOV     A,?V3
        ADDC    A,#-0x1
        MOV     ?V3,A
// 1584     }
??OS_PendListRemove_0:
        MOV     A,?V2
        ORL     A,?V3
        JNZ     ??OS_PendListRemove_1
// 1585     p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
        MOV     A,?V0
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,?V1
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1586     p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
        MOV     A,?V0
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,?V1
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1587 }
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
// 1588 
// 1589 /*$PAGE*/
// 1590 /*
// 1591 ************************************************************************************************************************
// 1592 *                               REMOVE AN 'OS_PEND_DATA' ENTRY from a 'OS_PEND_LIST'
// 1593 *
// 1594 * Description: This function is called to remove a task from a wait list knowing only the TCB of the task to remove
// 1595 *
// 1596 *
// 1597 *              CASE 1: Only 1 OS_PEND_DATA in the list.
// 1598 *
// 1599 *                     OS_PEND_LIST
// 1600 *                     +--------------+         OS_PEND_DATA
// 1601 *                     | TailPtr      |--+---> +------------+
// 1602 *                     +--------------+  |     | NextPtr    |->0
// 1603 *                     | HeadPtr      |--/      +------------+
// 1604 *                     +--------------+     0<-| PrevPtr    |
// 1605 *                     | NbrEntries=1 |        +------------+
// 1606 *                     +--------------+        |            |
// 1607 *                                             +------------+
// 1608 *                                             |            |
// 1609 *                                             +------------+
// 1610 *
// 1611 *              CASE N: Two or more OS_PEND_DATAs in the list.
// 1612 *
// 1613 *                     OS_PEND_LIST
// 1614 *                     +--------------+
// 1615 *                     | TailPtr      |-----------------------------------------------+
// 1616 *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
// 1617 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 1618 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 1619 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 1620 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 1621 *                                             +------------+       +------------+        +------------+
// 1622 *                                             |            |       |            |        |            |
// 1623 *                                             +------------+       +------------+        +------------+
// 1624 *                                             |            |       |            |        |            |
// 1625 *                                             +------------+       +------------+        +------------+
// 1626 *
// 1627 *
// 1628 * Arguments  : p_pend_list     is a pointer to the pend list where 'p_pend_data' will be removed from
// 1629 *              -----------
// 1630 *
// 1631 *              p_pend_data     is a pointer to the OS_PEND_DATA to remove from the pend list
// 1632 *              -----------
// 1633 *
// 1634 * Returns    : none
// 1635 *
// 1636 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1637 ************************************************************************************************************************
// 1638 */
// 1639 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1640 void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
OS_PendListRemove1:
        CODE
// 1641                           OS_PEND_DATA  *p_pend_data)
// 1642 {
        REQUIRE ?V0
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1643     OS_PEND_DATA  *p_prev;
// 1644     OS_PEND_DATA  *p_next;
// 1645 
// 1646 
// 1647 
// 1648     if (p_pend_list->NbrEntries == 1u) {
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??OS_PendListRemove1_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??OS_PendListRemove1_0:
        JNZ     ??OS_PendListRemove1_1
// 1649         p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1650         p_pend_list->TailPtr = (OS_PEND_DATA *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        LJMP    ??OS_PendListRemove1_2
// 1651 
// 1652     } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
??OS_PendListRemove1_1:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_PendListRemove1_3
// 1653         p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 1654         p_next->PrevPtr      = (OS_PEND_DATA *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1655         p_pend_list->HeadPtr = p_next;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        SJMP    ??OS_PendListRemove1_2
// 1656 
// 1657     } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
??OS_PendListRemove1_3:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_PendListRemove1_4
// 1658         p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1659         p_prev->NextPtr      = (OS_PEND_DATA *)0;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1660         p_pend_list->TailPtr = p_prev;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??OS_PendListRemove1_2
// 1661 
// 1662     } else {
// 1663         p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
??OS_PendListRemove1_4:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1664         p_next               = p_pend_data->NextPtr;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 1665         p_prev->NextPtr      = p_next;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1666         p_next->PrevPtr      = p_prev;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1667     }
// 1668     p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
??OS_PendListRemove1_2:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
// 1669     p_pend_data->NextPtr = (OS_PEND_DATA *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1670     p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1671 }
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1672 
// 1673 /*$PAGE*/
// 1674 /*
// 1675 ************************************************************************************************************************
// 1676 *                                READY A TASK THAT WAS PENDING ON AN OBJECT BEING DELETED
// 1677 *
// 1678 * Description: This function is called to make a task ready-to-run because an object is being deleted
// 1679 *
// 1680 * Arguments  : p_obj          is a pointer to the object being deleted
// 1681 *              -----
// 1682 *
// 1683 *              p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
// 1684 *              -----
// 1685 *
// 1686 *              ts             is a timestamp to indicate when the object was deleted
// 1687 *
// 1688 * Returns    : none
// 1689 *
// 1690 * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
// 1691 ************************************************************************************************************************
// 1692 */
// 1693 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1694 void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
OS_PendObjDel:
        CODE
// 1695                      OS_TCB       *p_tcb,
// 1696                      CPU_TS        ts)
// 1697 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
// 1698     switch (p_tcb->TaskState) {
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??OS_PendObjDel_0
        DEC     A
        JZ      ??OS_PendObjDel_0
        DEC     A
        JZ      ??OS_PendObjDel_1
        DEC     A
        JZ      ??OS_PendObjDel_1
        DEC     A
        JZ      ??OS_PendObjDel_0
        DEC     A
        JZ      ??OS_PendObjDel_0
        DEC     A
        JNZ     $+5
        LJMP    ??OS_PendObjDel_2
        DEC     A
        JNZ     $+5
        LJMP    ??OS_PendObjDel_2
        LJMP    ??OS_PendObjDel_3
// 1699         case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
// 1700         case OS_TASK_STATE_DLY:
// 1701         case OS_TASK_STATE_SUSPENDED:
// 1702         case OS_TASK_STATE_DLY_SUSPENDED:
// 1703              break;
??OS_PendObjDel_0:
        LJMP    ??OS_PendObjDel_3
// 1704 
// 1705         case OS_TASK_STATE_PEND:
// 1706         case OS_TASK_STATE_PEND_TIMEOUT:
// 1707              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_PendObjDel_1:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_PendObjDel_4
// 1708                  OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
// 1709                                 p_tcb,
// 1710                                 ts);
        ; Setup parameters for call to function OS_PendObjDel1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        LCALL   OS_PendObjDel1
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
// 1711              }
// 1712 #if (OS_MSG_EN > 0u)
// 1713              p_tcb->MsgPtr     = (void *)0;
??OS_PendObjDel_4:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1714              p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1715 #endif
// 1716              p_tcb->TS         = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
// 1717              OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
// 1718              OS_TaskRdy(p_tcb);
        ; Setup parameters for call to function OS_TaskRdy
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TaskRdy
// 1719              p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1720              p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x2
        MOVX    @DPTR,A
// 1721              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1722              break;
        SJMP    ??OS_PendObjDel_3
// 1723 
// 1724         case OS_TASK_STATE_PEND_SUSPENDED:
// 1725         case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
// 1726              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_PendObjDel_2:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_PendObjDel_5
// 1727                  OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
// 1728                                 p_tcb,
// 1729                                 ts);
        ; Setup parameters for call to function OS_PendObjDel1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        LCALL   OS_PendObjDel1
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
// 1730              }
// 1731 #if (OS_MSG_EN > 0u)
// 1732              p_tcb->MsgPtr     = (void      *)0;
??OS_PendObjDel_5:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1733              p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1734 #endif
// 1735              p_tcb->TS         = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
// 1736              OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
        ; Setup parameters for call to function OS_TickListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickListRemove
// 1737              OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
// 1738              p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1739              p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x2
        MOVX    @DPTR,A
// 1740              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1741              break;
// 1742 
// 1743         default:
// 1744              break;
// 1745     }
// 1746 }
??OS_PendObjDel_3:
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
// 1747 
// 1748 /*$PAGE*/
// 1749 /*
// 1750 ************************************************************************************************************************
// 1751 *                                    DELETE AN OBJECT FROM A TASK PENDING ON MULTIPLE OBJECTS
// 1752 *
// 1753 * Description: This function is called when a task is pending on multiple objects and the object is being deleted.
// 1754 *              This function needs to indicate to the caller which object was deleted by placing the address of the
// 1755 *              object in the OS_PEND_DATA table corresponding to the deleted object.
// 1756 *
// 1757 *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
// 1758 *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
// 1759 *              set to six (6) in this case.  As shown, when the pend call returns because a task deleted 'Obj C' then,
// 1760 *              only the one entry contains the filled in data and the other entries contains NULL pointers and zero
// 1761 *              data.
// 1762 *
// 1763 *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
// 1764 *
// 1765 *
// 1766 *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
// 1767 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1768 *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
// 1769 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1770 *                                         |  Obj B       |  0           | 0            | 0            | 0            |
// 1771 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1772 *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
// 1773 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1774 *                                         |  Obj D       |  0           | 0            | 0            | 0            |
// 1775 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1776 *                                         |  Obj E       |  0           | 0            | 0            | 0            |
// 1777 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1778 *                                         |  Obj F       |  0           | 0            | 0            | 0            |
// 1779 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1780 *
// 1781 *
// 1782 * Arguments  : p_obj        is a pointer to the object being deleted
// 1783 *              -----
// 1784 *
// 1785 *              p_tcb        is the OS_TCB of the task pending on the object being deleted
// 1786 *              -----
// 1787 *
// 1788 *              ts           is the time stamp of when the object was deleted
// 1789 *
// 1790 * Returns    : none
// 1791 *
// 1792 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1793 ************************************************************************************************************************
// 1794 */
// 1795 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1796 void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
OS_PendObjDel1:
        CODE
// 1797                       OS_TCB       *p_tcb,
// 1798                       CPU_TS        ts)
// 1799 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 1800     OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
// 1801     OS_PEND_DATA   *p_pend_data;
// 1802 
// 1803 
// 1804 
// 1805     p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
        MOV     A,R4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1806     n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
        MOV     A,R4
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        SJMP    ??OS_PendObjDel1_0
// 1807 
// 1808     while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
// 1809         if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
// 1810             p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
// 1811             p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
// 1812             break;
// 1813         }
// 1814         p_pend_data++;
??OS_PendObjDel1_1:
        MOV     A,R0
        ADD     A,#0x12
        MOV     R0,A
        JNC     ??OS_PendObjDel1_2
        INC     R1
// 1815         n_pend_list--;
??OS_PendObjDel1_2:
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
??OS_PendObjDel1_0:
        MOV     A,R4
        ORL     A,R5
        JZ      ??OS_PendObjDel1_3
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R2
        XRL     A,R6
        JNZ     ??OS_PendObjDel1_4
        MOV     A,R3
        XRL     A,R7
??OS_PendObjDel1_4:
        JNZ     ??OS_PendObjDel1_1
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XLOAD_R4567
        MOV     A,R0
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        LCALL   ?XSTORE_R4567
// 1816     }
// 1817 }
??OS_PendObjDel1_3:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1818 
// 1819 /*$PAGE*/
// 1820 /*
// 1821 ************************************************************************************************************************
// 1822 *                                                   POST TO A TASK
// 1823 *
// 1824 * Description: This function is called to post to a task.  This function exist because it is common to a number of
// 1825 *              OSxxxPost() services.
// 1826 *
// 1827 * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
// 1828 *              -----
// 1829 *
// 1830 *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
// 1831 *              -----
// 1832 *
// 1833 *              p_void         If we are posting a message to a task, this is the message that the task will receive
// 1834 *
// 1835 *              msg_size       If we are posting a message to a task, this is the size of the message
// 1836 *
// 1837 *              ts             The timestamp as to when the post occurred
// 1838 *
// 1839 * Returns    : none
// 1840 *
// 1841 * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
// 1842 ************************************************************************************************************************
// 1843 */
// 1844 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1845 void  OS_Post (OS_PEND_OBJ  *p_obj,
OS_Post:
        CODE
// 1846                OS_TCB       *p_tcb,
// 1847                void         *p_void,
// 1848                OS_MSG_SIZE   msg_size,
// 1849                CPU_TS        ts)
// 1850 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 15
        ; Auto size: 0
        MOV     ?V6,R2
        MOV     ?V7,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V5,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
// 1851     switch (p_tcb->TaskState) {
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??OS_Post_0
        DEC     A
        JZ      ??OS_Post_0
        DEC     A
        JZ      ??OS_Post_1
        DEC     A
        JZ      ??OS_Post_1
        DEC     A
        JZ      ??OS_Post_0
        DEC     A
        JZ      ??OS_Post_0
        DEC     A
        JNZ     $+5
        LJMP    ??OS_Post_2
        DEC     A
        JNZ     $+5
        LJMP    ??OS_Post_2
        LJMP    ??OS_Post_3
// 1852         case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
// 1853         case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
// 1854         case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
// 1855         case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
// 1856              break;
??OS_Post_0:
        LJMP    ??OS_Post_3
// 1857 
// 1858         case OS_TASK_STATE_PEND:
// 1859         case OS_TASK_STATE_PEND_TIMEOUT:
// 1860              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_Post_1:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_Post_4
// 1861                  OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
// 1862                           p_tcb,
// 1863                           p_void,
// 1864                           msg_size,
// 1865                           ts);
        ; Setup parameters for call to function OS_Post1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   OS_Post1
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        SJMP    ??OS_Post_5
// 1866              } else {
// 1867 #if (OS_MSG_EN > 0u)
// 1868                  p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
??OS_Post_4:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,?V4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V5
        MOVX    @DPTR,A
// 1869                  p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1870 #endif
// 1871                  p_tcb->TS      = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
// 1872              }
// 1873              if (p_obj != (OS_PEND_OBJ *)0) {
??OS_Post_5:
        MOV     A,?V6
        ORL     A,?V7
        JZ      ??OS_Post_6
// 1874                  OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
// 1875 #if OS_CFG_DBG_EN > 0u
// 1876                  OS_PendDbgNameRemove(p_obj,
// 1877                                       p_tcb);
        ; Setup parameters for call to function OS_PendDbgNameRemove
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   OS_PendDbgNameRemove
// 1878 #endif
// 1879              }
// 1880              OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
??OS_Post_6:
        ; Setup parameters for call to function OS_TaskRdy
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TaskRdy
// 1881              p_tcb->TaskState  = OS_TASK_STATE_RDY;
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1882              p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1883              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1884              break;
        LJMP    ??OS_Post_3
// 1885 
// 1886         case OS_TASK_STATE_PEND_SUSPENDED:
// 1887         case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
// 1888              if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
??OS_Post_2:
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??OS_Post_7
// 1889                  OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
// 1890                           p_tcb,
// 1891                           p_void,
// 1892                           msg_size,
// 1893                           ts);
        ; Setup parameters for call to function OS_Post1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   OS_Post1
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        SJMP    ??OS_Post_8
// 1894              } else {
// 1895 #if (OS_MSG_EN > 0u)
// 1896                  p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
??OS_Post_7:
        MOV     A,R6
        ADD     A,#0x40
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,?V4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V5
        MOVX    @DPTR,A
// 1897                  p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
        MOV     A,R6
        ADD     A,#0x42
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1898 #endif
// 1899                  p_tcb->TS      = ts;
        MOV     A,R6
        ADD     A,#0x24
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
// 1900              }
// 1901              OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
??OS_Post_8:
        ; Setup parameters for call to function OS_TickListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickListRemove
// 1902              if (p_obj != (OS_PEND_OBJ *)0) {
        MOV     A,?V6
        ORL     A,?V7
        JZ      ??OS_Post_9
// 1903                  OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
        ; Setup parameters for call to function OS_PendListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_PendListRemove
// 1904 #if OS_CFG_DBG_EN > 0u
// 1905                  OS_PendDbgNameRemove(p_obj,
// 1906                                       p_tcb);
        ; Setup parameters for call to function OS_PendDbgNameRemove
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V6
        MOV     R3,?V7
        LCALL   OS_PendDbgNameRemove
// 1907 #endif
// 1908              }
// 1909              p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
??OS_Post_9:
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1910              p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
        MOV     A,R6
        ADD     A,#0x1b
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1911              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
        MOV     A,R6
        ADD     A,#0x1a
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1912              break;
// 1913 
// 1914         default:
// 1915              break;
// 1916     }
// 1917 }
??OS_Post_3:
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
// 1918 
// 1919 /*$PAGE*/
// 1920 /*
// 1921 ************************************************************************************************************************
// 1922 *                                           POST TO A TASK PENDING ON MULTIPLE OBJECTS
// 1923 *
// 1924 * Description: This function is called when a task is pending on multiple objects and the object has been posted to.
// 1925 *              This function needs to indicate to the caller which object was posted to by placing the address of the
// 1926 *              object in the OS_PEND_DATA table corresponding to the posted object.
// 1927 *
// 1928 *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
// 1929 *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
// 1930 *              set to six (6) in this case.  As shown, when the pend call returns because a task or an ISR posted to
// 1931 *              'Obj C' then, only the one entry contains the filled in data and the other entries contains NULL pointers
// 1932 *              and zero data.
// 1933 *
// 1934 *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
// 1935 *
// 1936 *
// 1937 *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
// 1938 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1939 *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
// 1940 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1941 *                                         |  Obj B       |  0           | 0            | 0            | 0            |
// 1942 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1943 *                                         |  Obj C       |  Obj C       | Msg Ptr      | Msg Size     | TS           |
// 1944 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1945 *                                         |  Obj D       |  0           | 0            | 0            | 0            |
// 1946 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1947 *                                         |  Obj E       |  0           | 0            | 0            | 0            |
// 1948 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1949 *                                         |  Obj F       |  0           | 0            | 0            | 0            |
// 1950 *                                         +--------------+--------------+--------------+--------------+--------------+
// 1951 *
// 1952 *
// 1953 * Arguments  : p_obj        is a pointer to the object being posted to
// 1954 *              -----
// 1955 *
// 1956 *              p_tcb        is the OS_TCB of the task receiving the signal or the message
// 1957 *              -----
// 1958 *
// 1959 *              p_void       is the actual message (assuming posting to a message queue).  A NULL pointer otherwise.
// 1960 *
// 1961 *              msg_size     is the size of the message sent (if posted to a message queue)
// 1962 *
// 1963 *              ts           is the time stamp of when the post occurred
// 1964 *
// 1965 * Returns    : none
// 1966 *
// 1967 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 1968 ************************************************************************************************************************
// 1969 */
// 1970 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1971 void  OS_Post1 (OS_PEND_OBJ  *p_obj,
OS_Post1:
        CODE
// 1972                 OS_TCB       *p_tcb,
// 1973                 void         *p_void,
// 1974                 OS_MSG_SIZE   msg_size,
// 1975                 CPU_TS        ts)
// 1976 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 1977     OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
// 1978     OS_PEND_DATA   *p_pend_data;
// 1979 
// 1980 
// 1981 
// 1982     p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
        MOV     A,R4
        ADD     A,#0x18
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1983     n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
        MOV     A,R4
        ADD     A,#0x22
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        SJMP    ??OS_Post1_0
// 1984 
// 1985     while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
// 1986         if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
// 1987             p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
// 1988             p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
// 1989             p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
// 1990             p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
// 1991             break;
// 1992         }
// 1993         p_pend_data++;
??OS_Post1_1:
        MOV     A,R0
        ADD     A,#0x12
        MOV     R0,A
        JNC     ??OS_Post1_2
        INC     R1
// 1994         n_pend_list--;
??OS_Post1_2:
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R5,A
??OS_Post1_0:
        MOV     A,R4
        ORL     A,R5
        JZ      ??OS_Post1_3
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R2
        XRL     A,R6
        JNZ     ??OS_Post1_4
        MOV     A,R3
        XRL     A,R7
??OS_Post1_4:
        JNZ     ??OS_Post1_1
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XLOAD_R4567
        MOV     A,R0
        ADD     A,#0xe
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        LCALL   ?XSTORE_R4567
// 1995     }
// 1996 }
??OS_Post1_3:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 1997 
// 1998 /*$PAGE*/
// 1999 /*
// 2000 ************************************************************************************************************************
// 2001 *                                                    INITIALIZATION
// 2002 *                                               READY LIST INITIALIZATION
// 2003 *
// 2004 * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
// 2005 *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
// 2006 *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
// 2007 *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
// 2008 *
// 2009 *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
// 2010 *              to.
// 2011 *
// 2012 *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
// 2013 *
// 2014 *                               +---------------+--------------+
// 2015 *                               |               | TailPtr      |-----> 0
// 2016 *                          [0]  | NbrEntries=0  +--------------+
// 2017 *                               |               | HeadPtr      |-----> 0
// 2018 *                               +---------------+--------------+
// 2019 *                               |               | TailPtr      |-----> 0
// 2020 *                          [1]  | NbrEntries=0  +--------------+
// 2021 *                               |               | HeadPtr      |-----> 0
// 2022 *                               +---------------+--------------+
// 2023 *                                       :              :
// 2024 *                                       :              :
// 2025 *                                       :              :
// 2026 *                               +---------------+--------------+
// 2027 *                               |               | TailPtr      |-----> 0
// 2028 *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
// 2029 *                               |               | HeadPtr      |-----> 0
// 2030 *                               +---------------+--------------+
// 2031 *
// 2032 *
// 2033 * Arguments  : none
// 2034 *
// 2035 * Returns    : none
// 2036 *
// 2037 * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
// 2038 ************************************************************************************************************************
// 2039 */
// 2040 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2041 void  OS_RdyListInit (void)
OS_RdyListInit:
        CODE
// 2042 {
        PUSH    DPL
        PUSH    DPH
        ; Saved register size: 2
        ; Auto size: 0
// 2043     OS_PRIO       i;
// 2044     OS_RDY_LIST  *p_rdy_list;
// 2045 
// 2046 
// 2047 
// 2048     for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
        MOV     R2,#0x0
        SJMP    ??OS_RdyListInit_0
// 2049         p_rdy_list = &OSRdyList[i];
??OS_RdyListInit_1:
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
// 2050         p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2051         p_rdy_list->HeadPtr    = (OS_TCB   *)0;
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2052         p_rdy_list->TailPtr    = (OS_TCB   *)0;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2053     }
        INC     R2
??OS_RdyListInit_0:
        MOV     A,R2
        CLR     C
        SUBB    A,#0x20
        JC      ??OS_RdyListInit_1
// 2054 }
        POP     DPH
        POP     DPL
        RET
// 2055 
// 2056 /*$PAGE*/
// 2057 /*
// 2058 ************************************************************************************************************************
// 2059 *                                             INSERT TCB IN THE READY LIST
// 2060 *
// 2061 * Description: This function is called to insert a TCB in the ready list.
// 2062 *
// 2063 *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
// 2064 *              current task.  The TCB is inserted at the head of the list if not.
// 2065 *
// 2066 * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
// 2067 *              -----
// 2068 *
// 2069 * Returns    : none
// 2070 *
// 2071 * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
// 2072 ************************************************************************************************************************
// 2073 */
// 2074 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2075 void  OS_RdyListInsert (OS_TCB  *p_tcb)
OS_RdyListInsert:
        CODE
// 2076 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2077     OS_PrioInsert(p_tcb->Prio);
        ; Setup parameters for call to function OS_PrioInsert
        MOV     A,R6
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   OS_PrioInsert
// 2078     if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
        MOV     A,R6
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPTR,#OSPrioCur
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??OS_RdyListInsert_0
// 2079         OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
        ; Setup parameters for call to function OS_RdyListInsertTail
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_RdyListInsertTail
        SJMP    ??OS_RdyListInsert_1
// 2080     } else {
// 2081         OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
??OS_RdyListInsert_0:
        ; Setup parameters for call to function OS_RdyListInsertHead
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_RdyListInsertHead
// 2082     }
// 2083 }
??OS_RdyListInsert_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 2084 
// 2085 
// 2086 /*
// 2087 ************************************************************************************************************************
// 2088 *                                          INSERT TCB AT THE BEGINNING OF A LIST
// 2089 *
// 2090 * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
// 2091 *
// 2092 *              CASE 0: Insert in an empty list.
// 2093 *
// 2094 *                     OS_RDY_LIST
// 2095 *                     +--------------+
// 2096 *                     | TailPtr      |-> 0
// 2097 *                     +--------------+
// 2098 *                     | HeadPtr      |-> 0
// 2099 *                     +--------------+
// 2100 *                     | NbrEntries=0 |
// 2101 *                     +--------------+
// 2102 *
// 2103 *
// 2104 *
// 2105 *              CASE 1: Insert BEFORE the current head of list
// 2106 *
// 2107 *                     OS_RDY_LIST
// 2108 *                     +--------------+          OS_TCB
// 2109 *                     | TailPtr      |--+---> +------------+
// 2110 *                     +--------------+  |     | NextPtr    |->0
// 2111 *                     | HeadPtr      |--/     +------------+
// 2112 *                     +--------------+     0<-| PrevPtr    |
// 2113 *                     | NbrEntries=1 |        +------------+
// 2114 *                     +--------------+        :            :
// 2115 *                                             :            :
// 2116 *                                             +------------+
// 2117 *
// 2118 *
// 2119 *                     OS_RDY_LIST
// 2120 *                     +--------------+
// 2121 *                     | TailPtr      |-----------------------------------------------+
// 2122 *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
// 2123 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 2124 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 2125 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 2126 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 2127 *                                             +------------+       +------------+        +------------+
// 2128 *                                             :            :       :            :        :            :
// 2129 *                                             :            :       :            :        :            :
// 2130 *                                             +------------+       +------------+        +------------+
// 2131 *
// 2132 *
// 2133 * Arguments  : p_tcb     is the OS_TCB to insert in the list
// 2134 *              -----
// 2135 *
// 2136 * Returns    : none
// 2137 *
// 2138 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2139 ************************************************************************************************************************
// 2140 */
// 2141 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2142 void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
OS_RdyListInsertHead:
        CODE
// 2143 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 2144     OS_RDY_LIST  *p_rdy_list;
// 2145     OS_TCB       *p_tcb2;
// 2146 
// 2147 
// 2148 
// 2149     p_rdy_list = &OSRdyList[p_tcb->Prio];
        MOV     A,R2
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
// 2150     if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_RdyListInsertHead_0
// 2151         p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2152         p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2153         p_tcb->PrevPtr         =  (OS_TCB   *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2154         p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2155         p_rdy_list->TailPtr    =  p_tcb;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        SJMP    ??OS_RdyListInsertHead_1
// 2156     } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
// 2157         p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
??OS_RdyListInsertHead_0:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 2158         p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2159         p_tcb->PrevPtr         = (OS_TCB    *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2160         p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
// 2161         p_tcb2->PrevPtr        = p_tcb;
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2162         p_rdy_list->HeadPtr    = p_tcb;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2163     }
// 2164 }
??OS_RdyListInsertHead_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 2165 
// 2166 /*$PAGE*/
// 2167 /*
// 2168 ************************************************************************************************************************
// 2169 *                                           INSERT TCB AT THE END OF A LIST
// 2170 *
// 2171 * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
// 2172 *
// 2173 *              CASE 0: Insert in an empty list.
// 2174 *
// 2175 *                     OS_RDY_LIST
// 2176 *                     +--------------+
// 2177 *                     | TailPtr      |-> 0
// 2178 *                     +--------------+
// 2179 *                     | HeadPtr      |-> 0
// 2180 *                     +--------------+
// 2181 *                     | NbrEntries=0 |
// 2182 *                     +--------------+
// 2183 *
// 2184 *
// 2185 *
// 2186 *              CASE 1: Insert AFTER the current tail of list
// 2187 *
// 2188 *                     OS_RDY_LIST
// 2189 *                     +--------------+          OS_TCB
// 2190 *                     | TailPtr      |--+---> +------------+
// 2191 *                     +--------------+  |     | NextPtr    |->0
// 2192 *                     | HeadPtr      |--/     +------------+
// 2193 *                     +--------------+     0<-| PrevPtr    |
// 2194 *                     | NbrEntries=1 |        +------------+
// 2195 *                     +--------------+        :            :
// 2196 *                                             :            :
// 2197 *                                             +------------+
// 2198 *
// 2199 *
// 2200 *                     OS_RDY_LIST
// 2201 *                     +--------------+
// 2202 *                     | TailPtr      |-----------------------------------------------+
// 2203 *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
// 2204 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 2205 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 2206 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 2207 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 2208 *                                             +------------+       +------------+        +------------+
// 2209 *                                             :            :       :            :        :            :
// 2210 *                                             :            :       :            :        :            :
// 2211 *                                             +------------+       +------------+        +------------+
// 2212 *
// 2213 *
// 2214 * Arguments  : p_tcb     is the OS_TCB to insert in the list
// 2215 *              -----
// 2216 *
// 2217 * Returns    : none
// 2218 *
// 2219 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2220 ************************************************************************************************************************
// 2221 */
// 2222 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2223 void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
OS_RdyListInsertTail:
        CODE
// 2224 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
// 2225     OS_RDY_LIST  *p_rdy_list;
// 2226     OS_TCB       *p_tcb2;
// 2227 
// 2228 
// 2229 
// 2230     p_rdy_list = &OSRdyList[p_tcb->Prio];
        MOV     A,R2
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     R4,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     R5,A
// 2231     if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_RdyListInsertTail_0
// 2232         p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2233         p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2234         p_tcb->PrevPtr          = (OS_TCB   *)0;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2235         p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2236         p_rdy_list->TailPtr     = p_tcb;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        SJMP    ??OS_RdyListInsertTail_1
// 2237     } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
// 2238         p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
??OS_RdyListInsertTail_0:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 2239         p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2240         p_tcb2                  = p_rdy_list->TailPtr;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 2241         p_tcb->PrevPtr          = p_tcb2;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2242         p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2243         p_rdy_list->TailPtr     = p_tcb;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2244     }
// 2245 }
??OS_RdyListInsertTail_1:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 2246 
// 2247 /*$PAGE*/
// 2248 /*
// 2249 ************************************************************************************************************************
// 2250 *                                                MOVE TCB AT HEAD TO TAIL
// 2251 *
// 2252 * Description: This function is called to move the current head of a list to the tail of the list.
// 2253 *
// 2254 *
// 2255 *              CASE 0: TCB list is empty, nothing to do.
// 2256 *
// 2257 *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
// 2258 *
// 2259 *              CASE 2: Only 2 OS_TCBs in the list.
// 2260 *
// 2261 *                     OS_RDY_LIST
// 2262 *                     +--------------+
// 2263 *                     | TailPtr      |--------------------------+
// 2264 *                     +--------------+          OS_TCB          |     OS_TCB
// 2265 *                     | HeadPtr      |------> +------------+    +-> +------------+
// 2266 *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
// 2267 *                     | NbrEntries=2 |        +------------+        +------------+
// 2268 *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
// 2269 *                                             +------------+        +------------+
// 2270 *                                             :            :        :            :
// 2271 *                                             :            :        :            :
// 2272 *                                             +------------+        +------------+
// 2273 *
// 2274 *
// 2275 *              CASE N: More than 2 OS_TCBs in the list.
// 2276 *
// 2277 *                     OS_RDY_LIST
// 2278 *                     +--------------+
// 2279 *                     | TailPtr      |-----------------------------------------------+
// 2280 *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
// 2281 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 2282 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 2283 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 2284 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 2285 *                                             +------------+       +------------+        +------------+
// 2286 *                                             :            :       :            :        :            :
// 2287 *                                             :            :       :            :        :            :
// 2288 *                                             +------------+       +------------+        +------------+
// 2289 *
// 2290 *
// 2291 * Arguments  : p_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
// 2292 *              ------
// 2293 *
// 2294 * Returns    : none
// 2295 *
// 2296 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2297 ************************************************************************************************************************
// 2298 */
// 2299 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2300 void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
OS_RdyListMoveHeadToTail:
        CODE
// 2301 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
// 2302     OS_TCB  *p_tcb1;
// 2303     OS_TCB  *p_tcb2;
// 2304     OS_TCB  *p_tcb3;
// 2305 
// 2306 
// 2307 
// 2308     switch (p_rdy_list->NbrEntries) {
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?US_SWITCH_DENSE
`?<Jumptable for OS_RdyListMoveHeadToTail>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA8
        DATA
        DATA8
        DB        2
        DATA
        DATA16
        DATA
        DATA16
        DW        ??OS_RdyListMoveHeadToTail_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??OS_RdyListMoveHeadToTail_1
        DATA
        DATA16
        DATA
        DATA16
        DW        ??OS_RdyListMoveHeadToTail_1
        DATA
        DATA16
        DATA
        DATA16
        DW        ??OS_RdyListMoveHeadToTail_2
        CODE
// 2309         case 0:
// 2310         case 1:
// 2311              break;
// 2312 
// 2313         case 2:                                             /* SWAP the TCBs                                          */
// 2314              p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
??OS_RdyListMoveHeadToTail_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2315              p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 2316              p_tcb1->PrevPtr     = p_tcb2;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2317              p_tcb1->NextPtr     = (OS_TCB *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2318              p_tcb2->PrevPtr     = (OS_TCB *)0;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2319              p_tcb2->NextPtr     = p_tcb1;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2320              p_rdy_list->HeadPtr = p_tcb2;
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2321              p_rdy_list->TailPtr = p_tcb1;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2322              break;
        SJMP    ??OS_RdyListMoveHeadToTail_1
// 2323 
// 2324         default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
// 2325              p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
??OS_RdyListMoveHeadToTail_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2326              p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 2327              p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2328              p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2329              p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2330              p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2331              p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2332              p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2333              p_rdy_list->TailPtr = p_tcb1;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2334              break;
// 2335     }
// 2336 }
??OS_RdyListMoveHeadToTail_1:
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
// 2337 
// 2338 /*$PAGE*/
// 2339 /*
// 2340 ************************************************************************************************************************
// 2341 *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
// 2342 *
// 2343 * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
// 2344 *              remove.
// 2345 *
// 2346 *
// 2347 *              CASE 0: TCB list is empty, nothing to do.
// 2348 *
// 2349 *              CASE 1: Only 1 OS_TCBs in the list.
// 2350 *
// 2351 *                     OS_RDY_LIST
// 2352 *                     +--------------+          OS_TCB
// 2353 *                     | TailPtr      |--+---> +------------+
// 2354 *                     +--------------+  |     | NextPtr    |->0
// 2355 *                     | HeadPtr      |--/     +------------+
// 2356 *                     +--------------+     0<-| PrevPtr    |
// 2357 *                     | NbrEntries=1 |        +------------+
// 2358 *                     +--------------+        :            :
// 2359 *                                             :            :
// 2360 *                                             +------------+
// 2361 *
// 2362 *              CASE N: Two or more OS_TCBs in the list.
// 2363 *
// 2364 *                     OS_RDY_LIST
// 2365 *                     +--------------+
// 2366 *                     | TailPtr      |-----------------------------------------------+
// 2367 *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
// 2368 *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
// 2369 *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
// 2370 *                     | NbrEntries=N |        +------------+       +------------+        +------------+
// 2371 *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
// 2372 *                                             +------------+       +------------+        +------------+
// 2373 *                                             :            :       :            :        :            :
// 2374 *                                             :            :       :            :        :            :
// 2375 *                                             +------------+       +------------+        +------------+
// 2376 *
// 2377 *
// 2378 * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
// 2379 *              -----
// 2380 *
// 2381 * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
// 2382 *
// 2383 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2384 ************************************************************************************************************************
// 2385 */
// 2386 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2387 void  OS_RdyListRemove (OS_TCB  *p_tcb)
OS_RdyListRemove:
        CODE
// 2388 {
        REQUIRE ?V0
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2389     OS_RDY_LIST  *p_rdy_list;
// 2390     OS_TCB       *p_tcb1;
// 2391     OS_TCB       *p_tcb2;
// 2392 
// 2393 
// 2394 
// 2395     p_rdy_list = &OSRdyList[p_tcb->Prio];
        MOV     A,R6
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#OSRdyList & 0xff
        ADD     A,R0
        MOV     R4,A
        MOV     A,#(OSRdyList >> 8) & 0xff
        ADDC    A,R1
        MOV     R5,A
// 2396     p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 2397     p_tcb2     = p_tcb->NextPtr;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
// 2398     if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_RdyListRemove_0
// 2399         if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
        MOV     A,R2
        ORL     A,R3
        JNZ     ??OS_RdyListRemove_1
// 2400             p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2401             p_rdy_list->HeadPtr    = (OS_TCB   *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2402             p_rdy_list->TailPtr    = (OS_TCB   *)0;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2403             OS_PrioRemove(p_tcb->Prio);
        ; Setup parameters for call to function OS_PrioRemove
        MOV     A,R6
        ADD     A,#0x1d
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   OS_PrioRemove
        SJMP    ??OS_RdyListRemove_2
// 2404         } else {
// 2405             p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
??OS_RdyListRemove_1:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
// 2406             p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2407             p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
        MOV     DPL,R4
        MOV     DPH,R5
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        SJMP    ??OS_RdyListRemove_2
// 2408         }
// 2409     } else {
// 2410         p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
??OS_RdyListRemove_0:
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
// 2411         p_tcb1->NextPtr = p_tcb2;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2412         if (p_tcb2 == (OS_TCB *)0) {
        MOV     A,R2
        ORL     A,R3
        JNZ     ??OS_RdyListRemove_3
// 2413             p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??OS_RdyListRemove_2
// 2414         } else {
// 2415             p_tcb2->PrevPtr     = p_tcb1;
??OS_RdyListRemove_3:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2416         }
// 2417     }
// 2418     p_tcb->PrevPtr = (OS_TCB *)0;
??OS_RdyListRemove_2:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2419     p_tcb->NextPtr = (OS_TCB *)0;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2420 }
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
// 2421 
// 2422 /*$PAGE*/
// 2423 /*
// 2424 ************************************************************************************************************************
// 2425 *                                             SCHEDULE THE ISR HANDLER TASK
// 2426 *
// 2427 * Description: This function is called by other uC/OS-III services to schedule task at priority 0 which is always the
// 2428 *              ISR handler task.
// 2429 *
// 2430 * Arguments  : none
// 2431 *
// 2432 * Returns    : none
// 2433 *
// 2434 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2435 ************************************************************************************************************************
// 2436 */
// 2437 
// 2438 #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
// 2439 void  OS_Sched0 (void)
// 2440 {
// 2441     CPU_SR_ALLOC();
// 2442 
// 2443 
// 2444 
// 2445     CPU_INT_DIS();
// 2446     OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
// 2447     OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
// 2448 #if OS_CFG_TASK_PROFILE_EN > 0u
// 2449     OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
// 2450 #endif
// 2451     OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
// 2452     OS_TASK_SW();                                           /* Perform a task level context switch                    */
// 2453     CPU_INT_EN();
// 2454 }
// 2455 #endif
// 2456 
// 2457 /*$PAGE*/
// 2458 /*
// 2459 ************************************************************************************************************************
// 2460 *                                               SCHEDULER LOCK TIME MEASUREMENT
// 2461 *
// 2462 * Description: These functions are used to measure the peak amount of time that the scheduler is locked
// 2463 *
// 2464 * Arguments  : none
// 2465 *
// 2466 * Returns    : none
// 2467 *
// 2468 * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
// 2469 *
// 2470 *              2) It's assumed that these functions are called when interrupts are disabled.
// 2471 *
// 2472 *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
// 2473 *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
// 2474 *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
// 2475 *                 real-time system.
// 2476 ************************************************************************************************************************
// 2477 */
// 2478 
// 2479 #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
// 2480 void  OS_SchedLockTimeMeasStart (void)
// 2481 {
// 2482     if (OSSchedLockNestingCtr == 1u) {
// 2483         OSSchedLockTimeBegin = CPU_TS_TmrRd();
// 2484     }
// 2485 }
// 2486 
// 2487 
// 2488 
// 2489 
// 2490 void  OS_SchedLockTimeMeasStop (void)
// 2491 {
// 2492     CPU_TS_TMR  delta;
// 2493 
// 2494 
// 2495     if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
// 2496         delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
// 2497               - OSSchedLockTimeBegin;
// 2498         if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
// 2499             OSSchedLockTimeMax    = delta;
// 2500         }
// 2501         if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
// 2502             OSSchedLockTimeMaxCur = delta;
// 2503         }
// 2504     }
// 2505 }
// 2506 #endif
// 2507 
// 2508 /*$PAGE*/
// 2509 /*
// 2510 ************************************************************************************************************************
// 2511 *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
// 2512 *
// 2513 * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
// 2514 *
// 2515 *
// 2516 * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
// 2517 *              ----------
// 2518 *
// 2519 * Returns    : none
// 2520 *
// 2521 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2522 ************************************************************************************************************************
// 2523 */
// 2524 
// 2525 #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2526 void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
OS_SchedRoundRobin:
        CODE
// 2527 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V4,R2
        MOV     ?V5,R3
// 2528     OS_TCB   *p_tcb;
// 2529     CPU_SR_ALLOC();
        MOV     R6,#0x0
// 2530 
// 2531 
// 2532 
// 2533     if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
        MOV     DPTR,#OSSchedRoundRobinEn
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      $+5
        LJMP    ??OS_SchedRoundRobin_0
// 2534         return;
// 2535     }
// 2536 
// 2537     CPU_CRITICAL_ENTER();
        ; Setup parameters for call to function CPU_SR_Save
        LCALL   CPU_SR_Save
        MOV     A,R1
        MOV     R6,A
// 2538     p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2539 
// 2540     if (p_tcb == (OS_TCB *)0) {
        MOV     A,R4
        ORL     A,R5
        JNZ     ??OS_SchedRoundRobin_1
// 2541         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2542         return;
        LJMP    ??OS_SchedRoundRobin_0
// 2543     }
// 2544 
// 2545     if (p_tcb == &OSIdleTaskTCB) {
??OS_SchedRoundRobin_1:
        MOV     A,R4
        XRL     A,#OSIdleTaskTCB & 0xff
        JNZ     ??OS_SchedRoundRobin_2
        MOV     A,R5
        XRL     A,#(OSIdleTaskTCB >> 8) & 0xff
??OS_SchedRoundRobin_2:
        JNZ     ??OS_SchedRoundRobin_3
// 2546         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2547         return;
        LJMP    ??OS_SchedRoundRobin_0
// 2548     }
// 2549 
// 2550     if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
??OS_SchedRoundRobin_3:
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R0
        ORL     A,R1
        ORL     A,R2
        ORL     A,R3
        JZ      ??OS_SchedRoundRobin_4
// 2551         p_tcb->TimeQuantaCtr--;
        MOV     DPTR,#__Constant_ffffffff
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        MOV     R0,#?V0
        LCALL   ?L_ADD_TO_X
// 2552     }
// 2553 
// 2554     if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
??OS_SchedRoundRobin_4:
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R0
        ORL     A,R1
        ORL     A,R2
        ORL     A,R3
        JZ      ??OS_SchedRoundRobin_5
// 2555         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2556         return;
        SJMP    ??OS_SchedRoundRobin_0
// 2557     }
// 2558 
// 2559     if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
??OS_SchedRoundRobin_5:
        MOV     DPL,?V4
        MOV     DPH,?V5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#0x2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x0
        JNC     ??OS_SchedRoundRobin_6
// 2560         CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2561         return;
        SJMP    ??OS_SchedRoundRobin_0
// 2562     }
// 2563 
// 2564     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
??OS_SchedRoundRobin_6:
        MOV     DPTR,#OSSchedLockNestingCtr
        MOVX    A,@DPTR
        JZ      ??OS_SchedRoundRobin_7
// 2565         CPU_CRITICAL_EXIT();
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2566         return;
        SJMP    ??OS_SchedRoundRobin_0
// 2567     }
// 2568 
// 2569     OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
??OS_SchedRoundRobin_7:
        ; Setup parameters for call to function OS_RdyListMoveHeadToTail
        MOV     R2,?V4
        MOV     R3,?V5
        LCALL   OS_RdyListMoveHeadToTail
// 2570     p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
        MOV     DPL,?V4
        MOV     DPH,?V5
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 2571     if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
        MOV     A,R4
        ADD     A,#0x38
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R0
        ORL     A,R1
        ORL     A,R2
        ORL     A,R3
        JNZ     ??OS_SchedRoundRobin_8
// 2572         p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
        MOV     DPTR,#OSSchedRoundRobinDfltTimeQuanta
        LCALL   ?XLOAD_R0123
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XSTORE_R0123
        SJMP    ??OS_SchedRoundRobin_9
// 2573     } else {
// 2574         p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
??OS_SchedRoundRobin_8:
        MOV     A,R4
        ADD     A,#0x38
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XLOAD_R0123
        MOV     A,R4
        ADD     A,#0x3c
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
        LCALL   ?XSTORE_R0123
// 2575     }
// 2576     CPU_CRITICAL_EXIT();
??OS_SchedRoundRobin_9:
        ; Setup parameters for call to function CPU_SR_Restore
        MOV     A,R6
        MOV     R1,A
        LCALL   CPU_SR_Restore
// 2577 }
??OS_SchedRoundRobin_0:
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 2578 #endif
// 2579 
// 2580 /*$PAGE*/
// 2581 /*
// 2582 ************************************************************************************************************************
// 2583 *                                                     BLOCK A TASK
// 2584 *
// 2585 * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
// 2586 *              the specified timeout is non-zero.
// 2587 *
// 2588 * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
// 2589 *              -----
// 2590 *
// 2591 *              timeout        is the desired timeout
// 2592 *
// 2593 * Returns    : none
// 2594 *
// 2595 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2596 ************************************************************************************************************************
// 2597 */
// 2598 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2599 void  OS_TaskBlock (OS_TCB   *p_tcb,
OS_TaskBlock:
        CODE
// 2600                     OS_TICK   timeout)
// 2601 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 13
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
// 2602     OS_ERR  err;
// 2603 
// 2604 
// 2605     if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
        MOV     A,?V0
        ORL     A,?V1
        ORL     A,?V2
        ORL     A,?V3
        JZ      ??OS_TaskBlock_0
// 2606         OS_TickListInsert(p_tcb,
// 2607                           timeout,
// 2608                           OS_OPT_TIME_TIMEOUT,
// 2609                          &err);
        ; Setup parameters for call to function OS_TickListInsert
        MOV     R0,?XSP + 0
        MOV     R1,?XSP + 1
        MOV     ?V4,R0
        MOV     ?V5,R1
        MOV     R0,#?V4
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_FOUR
        MOV     R4,#0x2
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickListInsert
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
// 2610         if (err == OS_ERR_NONE) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??OS_TaskBlock_1
// 2611             p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x3
        MOVX    @DPTR,A
        SJMP    ??OS_TaskBlock_2
// 2612         } else {
// 2613             p_tcb->TaskState = OS_TASK_STATE_PEND;
??OS_TaskBlock_1:
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x2
        MOVX    @DPTR,A
        SJMP    ??OS_TaskBlock_2
// 2614         }
// 2615     } else {
// 2616         p_tcb->TaskState = OS_TASK_STATE_PEND;
??OS_TaskBlock_0:
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOV     A,#0x2
        MOVX    @DPTR,A
// 2617     }
// 2618     OS_RdyListRemove(p_tcb);
??OS_TaskBlock_2:
        ; Setup parameters for call to function OS_RdyListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_RdyListRemove
// 2619 }
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
// 2620 
// 2621 /*$PAGE*/
// 2622 /*
// 2623 ************************************************************************************************************************
// 2624 *                                                     READY A TASK
// 2625 *
// 2626 * Description: This function is called to make a task ready-to-run.
// 2627 *
// 2628 * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
// 2629 *              -----
// 2630 *
// 2631 * Returns    : none
// 2632 *
// 2633 * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
// 2634 ************************************************************************************************************************
// 2635 */
// 2636 

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 2637 void  OS_TaskRdy (OS_TCB  *p_tcb)
OS_TaskRdy:
        CODE
// 2638 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 8
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2639     OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
        ; Setup parameters for call to function OS_TickListRemove
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_TickListRemove
// 2640     if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
        MOV     A,R6
        ADD     A,#0x1c
        MOV     DPL,A
        CLR     A
        ADDC    A,R7
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JC      ??OS_TaskRdy_0
// 2641         OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
        ; Setup parameters for call to function OS_RdyListInsert
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   OS_RdyListInsert
// 2642     }
// 2643 }
??OS_TaskRdy_0:
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "uC/OS-III Idle Ta`:
        DB "uC/OS-III Idle Task"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Task Q">>`:
        DB "Task Q"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Task Sem">>`:
        DB "Task Sem"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant " ">>`:
        DB " "

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_a>`:
        DATA32
        DD 10

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_1>`:
        DATA32
        DD 1

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_0>`:
        DATA32
        DD 0

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_ffffffff>`:
        DATA32
        DD 4294967295

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "uC/OS-III Idle Task">`:
        DS 20
        REQUIRE `?<Initializer for <Constant "uC/OS-III Idle Ta`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Task Q">`:
        DS 7
        REQUIRE `?<Initializer for <Constant "Task Q">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Task Sem">`:
        DS 9
        REQUIRE `?<Initializer for <Constant "Task Sem">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA16
`?<Constant " ">`:
        DS 2
        REQUIRE `?<Initializer for <Constant " ">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_a:
        DS 4
        REQUIRE `?<Initializer for __Constant_a>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_1:
        DS 4
        REQUIRE `?<Initializer for __Constant_1>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_0:
        DS 4
        REQUIRE `?<Initializer for __Constant_0>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_ffffffff:
        DS 4
        REQUIRE `?<Initializer for __Constant_ffffffff>`
        REQUIRE __INIT_XDATA_I

        END
// 
// 6 773 bytes in segment NEAR_CODE
//     3 bytes in segment SFR_AN
//    54 bytes in segment XDATA_I
//    54 bytes in segment XDATA_ID
// 
// 6 811 bytes of CODE  memory (+ 16 bytes shared)
//     0 bytes of DATA  memory (+  3 bytes shared)
//    38 bytes of XDATA memory (+ 16 bytes shared)
//
//Errors: none
//Warnings: none
